{"version":3,"sources":["webpack:///webpack/bootstrap 12e26e6e975b351a2a5f","webpack:///external \"React\"","webpack:///./node_modules/sharedb/lib/error.js","webpack:///./node_modules/sharedb/lib/types.js","webpack:///./node_modules/sharedb/lib/util.js","webpack:///./node_modules/sharedb/lib/emitter.js","webpack:///./node_modules/fbjs/lib/emptyFunction.js","webpack:///./node_modules/fbjs/lib/invariant.js","webpack:///./node_modules/prop-types/lib/ReactPropTypesSecret.js","webpack:///./node_modules/sharedb/lib/ot.js","webpack:///./node_modules/sharedb/lib/projections.js","webpack:///./node_modules/underscore/underscore.js","webpack:///./node_modules/fbjs/lib/warning.js","webpack:///./node_modules/sharedb/lib/client/connection.js","webpack:///./node_modules/sharedb/lib/client/doc.js","webpack:///./node_modules/ot-json0/lib/index.js","webpack:///./node_modules/ot-json0/lib/bootstrapTransform.js","webpack:///./node_modules/sharedb/lib/client/query.js","webpack:///./node_modules/async/lib/async.js","webpack:///./node_modules/sharedb/lib/agent.js","webpack:///./node_modules/sharedb/lib/db/memory.js","webpack:///./node_modules/sharedb/lib/db/index.js","webpack:///./node_modules/sharedb/lib/pubsub/memory.js","webpack:///./node_modules/sharedb/lib/pubsub/index.js","webpack:///external \"util\"","webpack:///external \"stream\"","webpack:///./node_modules/sharedb/lib/query-emitter.js","webpack:///./node_modules/sharedb/lib/submit-request.js","webpack:///./src/browser/browser_main.tsx","webpack:///external \"ReactDOM\"","webpack:///./src/browser/ts/nav_bar.tsx","webpack:///./src/browser/ts/tab.tsx","webpack:///./src/browser/ts/sidebar.tsx","webpack:///./src/browser/ts/chat.tsx","webpack:///external \"clipboard\"","webpack:///./node_modules/react-switch/dist/index.js","webpack:///./node_modules/prop-types/index.js","webpack:///./node_modules/prop-types/factoryWithTypeCheckers.js","webpack:///./node_modules/object-assign/index.js","webpack:///./node_modules/prop-types/checkPropTypes.js","webpack:///./node_modules/prop-types/factoryWithThrowingShims.js","webpack:///./node_modules/react-switch/dist/icons.js","webpack:///./node_modules/react-switch/dist/getBackgroundColor.js","webpack:///external \"electron\"","webpack:///external \"url\"","webpack:///./src/utils/sharedb_wrapper.ts","webpack:///./node_modules/sharedb/lib/client/index.js","webpack:///external \"events\"","webpack:///./node_modules/make-error/index.js","webpack:///./node_modules/ot-json0/lib/json0.js","webpack:///./node_modules/ot-json0/lib/text0.js","webpack:///./node_modules/sharedb/lib/index.js","webpack:///./node_modules/sharedb/lib/backend.js","webpack:///./node_modules/hat/index.js","webpack:///./node_modules/sharedb/lib/op-stream.js","webpack:///./node_modules/arraydiff/index.js","webpack:///./node_modules/deep-is/index.js","webpack:///./node_modules/sharedb/lib/stream-socket.js","webpack:///./src/utils/chat_doc.ts","webpack:///./src/utils/typed_event_emitter.ts"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;AC7DA,uB;;;;;;ACAA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;;;ACRA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;ACTA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;ACPA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;ACTA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,+B;;;;;;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,qDAAqD;AACrD,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA,0BAA0B;AAC1B;AACA;AACA;;AAEA,2B;;;;;;;ACpDA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;;;;;;ACXA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;;AAEA,GAAG;AACH,iCAAiC;;AAEjC,GAAG;AACH,YAAY;AACZ;;AAEA;AACA,YAAY;AACZ;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;;AAEA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,YAAY;AACZ;;AAEA;AACA;AACA,+BAA+B;;AAE/B;AACA;AACA;AACA,uBAAuB;;AAEvB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA,8BAA8B;;AAE9B,wCAAwC;AACxC;AACA,qBAAqB;;AAErB;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;;AAEA;AACA;AACA,cAAc;AACd;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,GAAG;AACH;AACA,uBAAuB;;AAEvB;AACA;AACA,yBAAyB;AACzB;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;;;;;;ACtJA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB,eAAe;AAChC;AACA;;AAEA;AACA,kBAAkB;;AAElB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,eAAe;AAChC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACnHA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yBAAyB,gBAAgB;AACzC;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,YAAY;AAClD;AACA;AACA,KAAK;AACL;AACA,uCAAuC,YAAY;AACnD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,gBAAgB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,8BAA8B;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,gBAAgB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,gBAAgB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,YAAY;AACtD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,YAAY;AACtD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,gBAAgB;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA,oDAAoD;AACpD,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,0CAA0C;AAC1C,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,4DAA4D,YAAY;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,YAAY;AAC1D;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,8CAA8C,YAAY;AAC1D;AACA;AACA,qBAAqB,gBAAgB;AACrC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,gBAAgB;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,6CAA6C,YAAY;AACzD;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,8BAA8B;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,0BAA0B;AACpE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,cAAc;AACnC;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,YAAY;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO,eAAe;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,qBAAqB,eAAe;AACpC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,YAAY;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA,yBAAyB,gBAAgB;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,YAAY;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yCAAyC,YAAY;AACrD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yCAAyC,YAAY;AACrD;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,4CAA4C,mBAAmB;AAC/D;AACA;AACA,yCAAyC,YAAY;AACrD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qDAAqD;AACrD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,YAAY;AAC/B;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;;AAEA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe;AACf,cAAc;AACd,cAAc;AACd,gBAAgB;AAChB,gBAAgB;AAChB,gBAAgB;AAChB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;;AAE5B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP,qBAAqB;AACrB;;AAEA;AACA;AACA,KAAK;AACL,iBAAiB;;AAEjB;AACA,kDAAkD,EAAE,iBAAiB;;AAErE;AACA,wBAAwB,8BAA8B;AACtD,2BAA2B;;AAE3B;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,kDAAkD,iBAAiB;;AAEnE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AAAA;AACL;AACA,CAAC;;;;;;;;AC3gDD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,sFAAsF,aAAa;AACnG;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;;AAEA;AACA,4FAA4F,eAAe;AAC3G;AACA;;AAEA;AACA;AACA;AACA;;AAEA,yB;;;;;;AC7DA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA,mBAAmB;AACnB;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,KAAK;AACL;;AAEA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gCAAgC;AAC/C,GAAG;AACH,eAAe,uCAAuC;AACtD;AACA;AACA;AACA,eAAe,mDAAmD;AAClE,GAAG;AACH,eAAe,4CAA4C;AAC3D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,8EAA8E;AAC9E,2DAA2D;AAC3D;AACA;AACA;AACA,GAAG;AACH;AACA,mBAAmB;AACnB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,sCAAsC;;AAEtC;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACjkBA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wBAAwB,SAAS,IAAI;AACrC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,GAAG;AACH;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iBAAiB,4BAA4B;AAC7C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,kBAAkB;AACvC;AACA,2BAA2B;AAC3B;AACA;AACA;AACA,iCAAiC,4BAA4B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,mBAAmB,4BAA4B;AAC/C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC74BA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;ACNA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mBAAmB,oBAAoB;AACvC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT,yBAAyB,mBAAmB;AAC5C;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,yBAAyB,oBAAoB;AAC7C;AACA;AACA,yBAAyB,oBAAoB;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC7EA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,mEAAmE;AACnE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,yBAAyB;AAC5C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,0BAA0B,qBAAqB;AAC/C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;;AAEA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;ACtMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,mDAAmD,UAAU,EAAE;AAC/D;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA,uBAAuB,gBAAgB;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,gBAAgB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,oBAAoB;AAClD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA,kCAAkC,uBAAuB;AACzD;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,6BAA6B;AACjE;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;;;AAIA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,8DAA8D,yBAAyB;AACvF,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,yCAAyC,QAAQ;AACjD;AACA;AACA;AACA;AACA,+BAA+B,kBAAkB;AACjD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,uCAAuC;;AAEvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sC;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,OAAO;AACxD;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA,aAAa;AACb,SAAS;AACT;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AAAA;AACT;AACA;AACA;AACA;AACA;;AAEA,CAAC;;;;;;;AChvCD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,wFAAwF;;AAExF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,kCAAkC;AAClD;;AAEA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gCAAgC;AAChD;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;;AAEA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qCAAqC,gCAAgC;;AAErE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,0CAA0C;AAC5E;AACA;AACA,kBAAkB,kDAAkD;AACpE;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sBAAsB,gCAAgC;AACtD,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,8BAA8B;AACpD,KAAK;AACL,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,gCAAgC;AACtD,KAAK;AACL;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,8BAA8B;AACpD,KAAK;AACL;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;;;;;;ACvkBA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,0DAA0D,iBAAiB;AAC3E;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,gBAAgB;AACrC;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,2EAA2E;AAC3E;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wEAAwE;AACxE;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;ACvLA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,4BAA4B,KAAK;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;ACvGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;;;;;;ACrCA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,gEAAgE;AAChE;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC1HA,iC;;;;;;ACAA,mC;;;;;;ACAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA,qBAAqB,wBAAwB;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA,qBAAqB,wBAAwB;AAC7C;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;;;;;;ACxSA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;;AAEhB;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE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AAW,EAAE,KAAK,EAAE,IAAI,CAAC,KAAK,CAAC,QAAQ,GAAa,CAChL,CACL,CAAC;IACX,CAAC;IAAA,CAAC;CACL;AA5ED,4CA4EC;AAAA,CAAC;;;;;;;AC5FF,sC;;;;;;;ACAA;;AAEA;AACA;AACA,CAAC;;AAED,gCAAgC,2CAA2C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD,2DAA2D,EAAE,EAAE,yDAAyD,qEAAqE,6DAA6D,oBAAoB,GAAG,EAAE;;AAEjjB;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,sCAAsC,uCAAuC,gBAAgB;;AAE7F,iDAAiD,0CAA0C,0DAA0D,EAAE;;AAEvJ,iDAAiD,aAAa,uFAAuF,EAAE,uFAAuF;;AAE9O,0CAA0C,+DAA+D,qGAAqG,EAAE,yEAAyE,eAAe,yEAAyE,EAAE,EAAE,uHAAuH;;AAE5e;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,WAAW;AAChC;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS,yCAAyC;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,aAAa,0BAA0B;AACvC;AACA;AACA;AACA;AACA,aAAa,4BAA4B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,mBAAmB;AACvD,WAAW;AACX;AACA,oCAAoC,oBAAoB;AACxD,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,GAAG;;AAEH;AACA,CAAC;;AAED;AACA;;AAEA;AACA,qBAAqB,oCAAoC;AACzD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,6BAA6B;AAClD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,uBAAuB,kCAAkC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,uBAAuB,qDAAqD;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,qBAAqB,qDAAqD;AAC1E;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,kCAAkC;AACvD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yB;;;;;;AC1XA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;;;;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,0CAA0C;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,6BAA6B;AAC7B,QAAQ;AACR;AACA;AACA;AACA;AACA,+BAA+B,KAAK;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,4BAA4B;AAC5B,OAAO;AACP;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,sBAAsB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB,2BAA2B;AAChD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,gCAAgC;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,gCAAgC;AACrD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;AC7hBA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH,kCAAkC;AAClC;AACA;AACA;;AAEA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,gBAAgB,sBAAsB;AACtC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;ACzFA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,UAAU;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gGAAgG;AAChG;AACA,SAAS;AACT;AACA;AACA,gGAAgG;AAChG;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AC1DA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;ACzDA;;AAEA;AACA;AACA,CAAC;AACD;;AAEA;;AAEA;;AAEA,sCAAsC,uCAAuC,gBAAgB;;AAE7F;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH,E;;;;;;;ACjEA;;AAEA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,C;;;;;;AC5CA,qC;;;;;;ACAA,gC;;;;;;;;;;;;;;;;;ACAA,8CAAoD;AACpD,wCAAmC;AAKnC;IAII,YAAY,MAAc,EAAE,UAAqB;QAHzC,SAAI,GAAmC,IAAI,GAAG,EAA8B,CAAC;QAIjF,EAAE,EAAC,MAAM,CAAC,CAAC,CAAC;YACR,IAAI,CAAC,UAAU,GAAG,IAAI,aAAa,CAAC,UAAU,CAAC,UAAU,CAAC,CAAC;QAC/D,CAAC;QAAC,IAAI,CAAC,CAAC;YACJ,IAAI,CAAC,KAAK,GAAG,IAAI,OAAO,EAAE,CAAC;YAC3B,IAAI,CAAC,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AAA,CAAC;IACK,OAAO;QACV,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC;IACzB,CAAC;IAAA,CAAC;IACK,OAAO;QACV,IAAI,CAAC,GAAG,CAAC,OAAO,EAAE,CAAC;QACnB,IAAI,CAAC,GAAG,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;IAC7B,CAAC;IAAA,CAAC;CACL;AAlED,wBAkEC;AAAA,CAAC;;;;;;;ACtHF;AACA;AACA;AACA;AACA;;;;;;;ACJA,mC;;;;;;;ACAA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,+BAA+B;;AAE/B;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;AC7IA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,YAAY;;AAEZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,eAAe;AAChC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,iBAAiB,eAAe;AAChC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mBAAmB,gBAAgB;AACnC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,eAAe;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,eAAe;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iBAAiB,eAAe;AAChC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL,+BAA+B;AAC/B,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,iBAAiB,gBAAgB;AACjC;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,iBAAiB,eAAe;AAChC;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,iBAAiB,UAAU;AAC3B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,kCAAkC,OAAO;AACzC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,2BAA2B,gBAAgB;AAC3C;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,4BAA4B,qBAAqB;AACjD,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;ACvpBA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,eAAe;AACpB,KAAK,eAAe;AACpB;AACA;AACA;AACA;AACA;AACA,OAAO,aAAa;AACpB;AACA,OAAO,WAAW,GAAG,WAAW,GAAG,WAAW;;AAE9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,eAAe;AAChC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iBAAiB,eAAe;AAChC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,iCAAiC;;AAEjC,KAAK;AACL;AACA,iCAAiC;;AAEjC,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM,eAAe;AACrB;AACA;AACA;AACA;;AAEA,iBAAiB,eAAe;AAChC;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,eAAe;AAChC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,kBAAkB,0DAA0D;AAC5E,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,sBAAsB,oCAAoC;AAC1D;AACA;AACA;AACA,sBAAsB,+BAA+B;;AAErD,KAAK;AACL;AACA;AACA,sBAAsB,iCAAiC;AACvD;AACA;AACA;AACA;AACA,oBAAoB;;AAEpB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,0BAA0B,aAAa,IAAI;AAC3C;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,eAAe;AAChC;AACA;AACA;AACA;;AAEA;;;;;;;AC/PA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,uCAAuC;AACvC;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,yBAAyB;AAC3D;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,mEAAmE,cAAc;AACjF;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI,IAAI,GAAG,QAAQ,KAAK,KAAK;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,6BAA6B,uCAAuC;AACpE;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,8BAA8B,mDAAmD;AACjF;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA,kDAAkD,qBAAqB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qDAAqD;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,oCAAoC;AAC1E;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;;;;;;;AC3gBA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,qBAAqB;AACxC;AACA;;AAEA;;AAEA;;AAEA,mBAAmB,wBAAwB;AAC3C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;AC7DA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,iBAAiB;;AAExC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yBAAyB,WAAW;AACpC,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;AC1DA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,4BAA4B;AACvD;AACA,4BAA4B,0BAA0B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,4BAA4B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0BAA0B,0BAA0B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,mBAAmB;AAChC;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;;AAEA;AACA,yBAAyB,KAAK;AAC9B;AACA;AACA,yBAAyB,KAAK;AAC9B;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,SAAS;AAChC;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,aAAa,iBAAiB;AAC9B;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;ACpLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA,GAAG;AACH;;AAEA,GAAG;AACH;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,YAAY;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAA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","file":"browser_bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 27);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 12e26e6e975b351a2a5f","module.exports = React;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"React\"\n// module id = 0\n// module chunks = 0","var makeError = require('make-error');\n\nfunction ShareDBError(code, message) {\n  ShareDBError.super.call(this, message);\n  this.code = code;\n}\n\nmakeError(ShareDBError);\n\nmodule.exports = ShareDBError;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/sharedb/lib/error.js\n// module id = 1\n// module chunks = 0","\nexports.defaultType = require('ot-json0').type;\n\nexports.map = {};\n\nexports.register = function(type) {\n  if (type.name) exports.map[type.name] = type;\n  if (type.uri) exports.map[type.uri] = type;\n};\n\nexports.register(exports.defaultType);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/sharedb/lib/types.js\n// module id = 2\n// module chunks = 0","\nexports.doNothing = doNothing;\nfunction doNothing() {}\n\nexports.hasKeys = function(object) {\n  for (var key in object) return true;\n  return false;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/sharedb/lib/util.js\n// module id = 3\n// module chunks = 0","var EventEmitter = require('events').EventEmitter;\n\nexports.EventEmitter = EventEmitter;\nexports.mixin = mixin;\n\nfunction mixin(Constructor) {\n  for (var key in EventEmitter.prototype) {\n    Constructor.prototype[key] = EventEmitter.prototype[key];\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/sharedb/lib/emitter.js\n// module id = 4\n// module chunks = 0","\"use strict\";\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nfunction makeEmptyFunction(arg) {\n  return function () {\n    return arg;\n  };\n}\n\n/**\n * This function accepts and discards inputs; it has no side effects. This is\n * primarily useful idiomatically for overridable function endpoints which\n * always need to be callable, since JS lacks a null-call idiom ala Cocoa.\n */\nvar emptyFunction = function emptyFunction() {};\n\nemptyFunction.thatReturns = makeEmptyFunction;\nemptyFunction.thatReturnsFalse = makeEmptyFunction(false);\nemptyFunction.thatReturnsTrue = makeEmptyFunction(true);\nemptyFunction.thatReturnsNull = makeEmptyFunction(null);\nemptyFunction.thatReturnsThis = function () {\n  return this;\n};\nemptyFunction.thatReturnsArgument = function (arg) {\n  return arg;\n};\n\nmodule.exports = emptyFunction;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/fbjs/lib/emptyFunction.js\n// module id = 5\n// module chunks = 0","/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n'use strict';\n\n/**\n * Use invariant() to assert state which your program assumes to be true.\n *\n * Provide sprintf-style format (only %s is supported) and arguments\n * to provide information about what broke and what you were\n * expecting.\n *\n * The invariant message will be stripped in production, but the invariant\n * will remain to ensure logic does not differ in production.\n */\n\nvar validateFormat = function validateFormat(format) {};\n\nif (process.env.NODE_ENV !== 'production') {\n  validateFormat = function validateFormat(format) {\n    if (format === undefined) {\n      throw new Error('invariant requires an error message argument');\n    }\n  };\n}\n\nfunction invariant(condition, format, a, b, c, d, e, f) {\n  validateFormat(format);\n\n  if (!condition) {\n    var error;\n    if (format === undefined) {\n      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');\n    } else {\n      var args = [a, b, c, d, e, f];\n      var argIndex = 0;\n      error = new Error(format.replace(/%s/g, function () {\n        return args[argIndex++];\n      }));\n      error.name = 'Invariant Violation';\n    }\n\n    error.framesToPop = 1; // we don't care about invariant's own frame\n    throw error;\n  }\n}\n\nmodule.exports = invariant;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/fbjs/lib/invariant.js\n// module id = 6\n// module chunks = 0","/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nvar ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';\n\nmodule.exports = ReactPropTypesSecret;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/prop-types/lib/ReactPropTypesSecret.js\n// module id = 7\n// module chunks = 0","// This contains the master OT functions for the database. They look like\n// ot-types style operational transform functions, but they're a bit different.\n// These functions understand versions and can deal with out of bound create &\n// delete operations.\n\nvar types = require('./types').map;\n\n// Returns an error string on failure. Rockin' it C style.\nexports.checkOp = function(op) {\n  if (op == null || typeof op !== 'object') {\n    return {code: 4004, message: 'Missing op'};\n  }\n\n  if (op.create != null) {\n    if (typeof op.create !== 'object') {\n      return {code: 4006, message: 'create data must be an object'};\n    }\n    var typeName = op.create.type;\n    if (typeof typeName !== 'string') {\n      return {code: 4007, message: 'Missing create type'};\n    }\n    var type = types[typeName];\n    if (type == null || typeof type !== 'object') {\n      return {code: 4008, message: 'Unknown type'};\n    }\n\n  } else if (op.del != null) {\n    if (op.del !== true) return {code: 4009, message: 'del value must be true'};\n\n  } else if (op.op == null) {\n    return {code: 4010, message: 'Missing op, create, or del'};\n  }\n\n  if (op.src != null && typeof op.src !== 'string') {\n    return {code: 4011, message: 'Invalid src'};\n  }\n  if (op.seq != null && typeof op.seq !== 'number') {\n    return {code: 4012, message: 'Invalid seq'};\n  }\n  if (\n    (op.src == null && op.seq != null) ||\n    (op.src != null && op.seq == null)\n  ) {\n    return {code: 4013, message: 'Both src and seq must be set together'};\n  }\n\n  if (op.m != null && typeof op.m !== 'object') {\n    return {code: 4014, message: 'op.m invalid'};\n  }\n};\n\n// Takes in a string (type name or URI) and returns the normalized name (uri)\nexports.normalizeType = function(typeName) {\n  return types[typeName] && types[typeName].uri;\n};\n\n// This is the super apply function that takes in snapshot data (including the\n// type) and edits it in-place. Returns an error or null for success.\nexports.apply = function(snapshot, op) {\n  if (typeof snapshot !== 'object') {\n    return {code: 5002, message: 'Missing snapshot'};\n  }\n  if (snapshot.v != null && op.v != null && snapshot.v !== op.v) {\n    return {code: 5003, message: 'Version mismatch'};\n  }\n\n  // Create operation\n  if (op.create) {\n    if (snapshot.type) return {code: 4016, message: 'Document already exists'};\n\n    // The document doesn't exist, although it might have once existed\n    var create = op.create;\n    var type = types[create.type];\n    if (!type) return {code: 4008, message: 'Unknown type'};\n\n    try {\n      snapshot.data = type.create(create.data);\n      snapshot.type = type.uri;\n      snapshot.v++;\n    } catch (err) {\n      return err;\n    }\n\n  // Delete operation\n  } else if (op.del) {\n    snapshot.data = undefined;\n    snapshot.type = null;\n    snapshot.v++;\n\n  // Edit operation\n  } else if (op.op) {\n    var err = applyOpEdit(snapshot, op.op);\n    if (err) return err;\n    snapshot.v++;\n\n  // No-op, and we don't have to do anything\n  } else {\n    snapshot.v++;\n  }\n};\n\nfunction applyOpEdit(snapshot, edit) {\n  if (!snapshot.type) return {code: 4015, message: 'Document does not exist'};\n\n  if (typeof edit !== 'object') return {code: 5004, message: 'Missing op'};\n  var type = types[snapshot.type];\n  if (!type) return {code: 4008, message: 'Unknown type'};\n\n  try {\n    snapshot.data = type.apply(snapshot.data, edit);\n  } catch (err) {\n    return err;\n  }\n}\n\nexports.transform = function(type, op, appliedOp) {\n  // There are 16 cases this function needs to deal with - which are all the\n  // combinations of create/delete/op/noop from both op and appliedOp\n  if (op.v != null && op.v !== appliedOp.v) {\n    return {code: 5006, message: 'Version mismatch'};\n  }\n\n  if (appliedOp.del) {\n    if (op.create || op.op) {\n      return {code: 4017, message: 'Document was deleted'};\n    }\n  } else if (\n    (appliedOp.create && (op.op || op.create || op.del)) ||\n    (appliedOp.op && op.create)\n  ) {\n    // If appliedOp.create is not true, appliedOp contains an op - which\n    // also means the document exists remotely.\n    return {code: 4018, message: 'Document was created remotely'};\n  } else if (appliedOp.op && op.op) {\n    // If we reach here, they both have a .op property.\n    if (!type) return {code: 5005, message: 'Document does not exist'};\n\n    if (typeof type === 'string') {\n      type = types[type];\n      if (!type) return {code: 4008, message: 'Unknown type'};\n    }\n\n    try {\n      op.op = type.transform(op.op, appliedOp.op, 'left');\n    } catch (err) {\n      return err;\n    }\n  }\n\n  if (op.v != null) op.v++;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/sharedb/lib/ot.js\n// module id = 8\n// module chunks = 0","var json0 = require('ot-json0').type;\n\nexports.projectSnapshot = projectSnapshot;\nexports.projectOp = projectOp;\nexports.isSnapshotAllowed = isSnapshotAllowed;\nexports.isOpAllowed = isOpAllowed;\n\n\n// Project a snapshot in place to only include specified fields\nfunction projectSnapshot(fields, snapshot) {\n  // Only json0 supported right now\n  if (snapshot.type && snapshot.type !== json0.uri) {\n    throw new Error(4023, 'Cannot project snapshots of type ' + snapshot.type);\n  }\n  snapshot.data = projectData(fields, snapshot.data);\n}\n\nfunction projectOp(fields, op) {\n  if (op.create) {\n    projectSnapshot(fields, op.create);\n  }\n  if (op.op) {\n    op.op = projectEdit(fields, op.op);\n  }\n}\n\nfunction projectEdit(fields, op) {\n  // So, we know the op is a JSON op\n  var result = [];\n\n  for (var i = 0; i < op.length; i++) {\n    var c = op[i];\n    var path = c.p;\n\n    if (path.length === 0) {\n      var newC = {p:[]};\n\n      if (c.od !== undefined || c.oi !== undefined) {\n        if (c.od !== undefined) {\n          newC.od = projectData(fields, c.od);\n        }\n        if (c.oi !== undefined) {\n          newC.oi = projectData(fields, c.oi);\n        }\n        result.push(newC);\n      }\n    } else {\n      // The path has a first element. Just check it against the fields.\n      if (fields[path[0]]) {\n        result.push(c);\n      }\n    }\n  }\n  return result;\n}\n\nfunction isOpAllowed(knownType, fields, op) {\n  if (op.create) {\n    return isSnapshotAllowed(fields, op.create);\n  }\n  if (op.op) {\n    if (knownType && knownType !== json0.uri) return false;\n    return isEditAllowed(fields, op.op);\n  }\n  // Noop and del are both ok.\n  return true;\n}\n\n// Basically, would the projected version of this data be the same as the original?\nfunction isSnapshotAllowed(fields, snapshot) {\n  if (snapshot.type && snapshot.type !== json0.uri) {\n    return false;\n  }\n  if (snapshot.data == null) {\n    return true;\n  }\n  // Data must be an object if not null\n  if (typeof snapshot.data !== 'object' || Array.isArray(snapshot.data)) {\n    return false;\n  }\n  for (var k in snapshot.data) {\n    if (!fields[k]) return false;\n  }\n  return true;\n}\n\nfunction isEditAllowed(fields, op) {\n  for (var i = 0; i < op.length; i++) {\n    var c = op[i];\n    if (c.p.length === 0) {\n      return false;\n    } else if (!fields[c.p[0]]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction projectData(fields, data) {\n  // Return back null or undefined\n  if (data == null) {\n    return data;\n  }\n  // If data is not an object, the projected version just looks like null.\n  if (typeof data !== 'object' || Array.isArray(data)) {\n    return null;\n  }\n  // Shallow copy of each field\n  var result = {};\n  for (var key in fields) {\n    if (data.hasOwnProperty(key)) {\n      result[key] = data[key];\n    }\n  }\n  return result;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/sharedb/lib/projections.js\n// module id = 9\n// module chunks = 0","//     Underscore.js 1.8.3\n//     http://underscorejs.org\n//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n//     Underscore may be freely distributed under the MIT license.\n\n(function() {\n\n  // Baseline setup\n  // --------------\n\n  // Establish the root object, `window` in the browser, or `exports` on the server.\n  var root = this;\n\n  // Save the previous value of the `_` variable.\n  var previousUnderscore = root._;\n\n  // Save bytes in the minified (but not gzipped) version:\n  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;\n\n  // Create quick reference variables for speed access to core prototypes.\n  var\n    push             = ArrayProto.push,\n    slice            = ArrayProto.slice,\n    toString         = ObjProto.toString,\n    hasOwnProperty   = ObjProto.hasOwnProperty;\n\n  // All **ECMAScript 5** native function implementations that we hope to use\n  // are declared here.\n  var\n    nativeIsArray      = Array.isArray,\n    nativeKeys         = Object.keys,\n    nativeBind         = FuncProto.bind,\n    nativeCreate       = Object.create;\n\n  // Naked function reference for surrogate-prototype-swapping.\n  var Ctor = function(){};\n\n  // Create a safe reference to the Underscore object for use below.\n  var _ = function(obj) {\n    if (obj instanceof _) return obj;\n    if (!(this instanceof _)) return new _(obj);\n    this._wrapped = obj;\n  };\n\n  // Export the Underscore object for **Node.js**, with\n  // backwards-compatibility for the old `require()` API. If we're in\n  // the browser, add `_` as a global object.\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = _;\n    }\n    exports._ = _;\n  } else {\n    root._ = _;\n  }\n\n  // Current version.\n  _.VERSION = '1.8.3';\n\n  // Internal function that returns an efficient (for current engines) version\n  // of the passed-in callback, to be repeatedly applied in other Underscore\n  // functions.\n  var optimizeCb = function(func, context, argCount) {\n    if (context === void 0) return func;\n    switch (argCount == null ? 3 : argCount) {\n      case 1: return function(value) {\n        return func.call(context, value);\n      };\n      case 2: return function(value, other) {\n        return func.call(context, value, other);\n      };\n      case 3: return function(value, index, collection) {\n        return func.call(context, value, index, collection);\n      };\n      case 4: return function(accumulator, value, index, collection) {\n        return func.call(context, accumulator, value, index, collection);\n      };\n    }\n    return function() {\n      return func.apply(context, arguments);\n    };\n  };\n\n  // A mostly-internal function to generate callbacks that can be applied\n  // to each element in a collection, returning the desired result  either\n  // identity, an arbitrary callback, a property matcher, or a property accessor.\n  var cb = function(value, context, argCount) {\n    if (value == null) return _.identity;\n    if (_.isFunction(value)) return optimizeCb(value, context, argCount);\n    if (_.isObject(value)) return _.matcher(value);\n    return _.property(value);\n  };\n  _.iteratee = function(value, context) {\n    return cb(value, context, Infinity);\n  };\n\n  // An internal function for creating assigner functions.\n  var createAssigner = function(keysFunc, undefinedOnly) {\n    return function(obj) {\n      var length = arguments.length;\n      if (length < 2 || obj == null) return obj;\n      for (var index = 1; index < length; index++) {\n        var source = arguments[index],\n            keys = keysFunc(source),\n            l = keys.length;\n        for (var i = 0; i < l; i++) {\n          var key = keys[i];\n          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];\n        }\n      }\n      return obj;\n    };\n  };\n\n  // An internal function for creating a new object that inherits from another.\n  var baseCreate = function(prototype) {\n    if (!_.isObject(prototype)) return {};\n    if (nativeCreate) return nativeCreate(prototype);\n    Ctor.prototype = prototype;\n    var result = new Ctor;\n    Ctor.prototype = null;\n    return result;\n  };\n\n  var property = function(key) {\n    return function(obj) {\n      return obj == null ? void 0 : obj[key];\n    };\n  };\n\n  // Helper for collection methods to determine whether a collection\n  // should be iterated as an array or as an object\n  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength\n  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094\n  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;\n  var getLength = property('length');\n  var isArrayLike = function(collection) {\n    var length = getLength(collection);\n    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;\n  };\n\n  // Collection Functions\n  // --------------------\n\n  // The cornerstone, an `each` implementation, aka `forEach`.\n  // Handles raw objects in addition to array-likes. Treats all\n  // sparse array-likes as if they were dense.\n  _.each = _.forEach = function(obj, iteratee, context) {\n    iteratee = optimizeCb(iteratee, context);\n    var i, length;\n    if (isArrayLike(obj)) {\n      for (i = 0, length = obj.length; i < length; i++) {\n        iteratee(obj[i], i, obj);\n      }\n    } else {\n      var keys = _.keys(obj);\n      for (i = 0, length = keys.length; i < length; i++) {\n        iteratee(obj[keys[i]], keys[i], obj);\n      }\n    }\n    return obj;\n  };\n\n  // Return the results of applying the iteratee to each element.\n  _.map = _.collect = function(obj, iteratee, context) {\n    iteratee = cb(iteratee, context);\n    var keys = !isArrayLike(obj) && _.keys(obj),\n        length = (keys || obj).length,\n        results = Array(length);\n    for (var index = 0; index < length; index++) {\n      var currentKey = keys ? keys[index] : index;\n      results[index] = iteratee(obj[currentKey], currentKey, obj);\n    }\n    return results;\n  };\n\n  // Create a reducing function iterating left or right.\n  function createReduce(dir) {\n    // Optimized iterator function as using arguments.length\n    // in the main function will deoptimize the, see #1991.\n    function iterator(obj, iteratee, memo, keys, index, length) {\n      for (; index >= 0 && index < length; index += dir) {\n        var currentKey = keys ? keys[index] : index;\n        memo = iteratee(memo, obj[currentKey], currentKey, obj);\n      }\n      return memo;\n    }\n\n    return function(obj, iteratee, memo, context) {\n      iteratee = optimizeCb(iteratee, context, 4);\n      var keys = !isArrayLike(obj) && _.keys(obj),\n          length = (keys || obj).length,\n          index = dir > 0 ? 0 : length - 1;\n      // Determine the initial value if none is provided.\n      if (arguments.length < 3) {\n        memo = obj[keys ? keys[index] : index];\n        index += dir;\n      }\n      return iterator(obj, iteratee, memo, keys, index, length);\n    };\n  }\n\n  // **Reduce** builds up a single result from a list of values, aka `inject`,\n  // or `foldl`.\n  _.reduce = _.foldl = _.inject = createReduce(1);\n\n  // The right-associative version of reduce, also known as `foldr`.\n  _.reduceRight = _.foldr = createReduce(-1);\n\n  // Return the first value which passes a truth test. Aliased as `detect`.\n  _.find = _.detect = function(obj, predicate, context) {\n    var key;\n    if (isArrayLike(obj)) {\n      key = _.findIndex(obj, predicate, context);\n    } else {\n      key = _.findKey(obj, predicate, context);\n    }\n    if (key !== void 0 && key !== -1) return obj[key];\n  };\n\n  // Return all the elements that pass a truth test.\n  // Aliased as `select`.\n  _.filter = _.select = function(obj, predicate, context) {\n    var results = [];\n    predicate = cb(predicate, context);\n    _.each(obj, function(value, index, list) {\n      if (predicate(value, index, list)) results.push(value);\n    });\n    return results;\n  };\n\n  // Return all the elements for which a truth test fails.\n  _.reject = function(obj, predicate, context) {\n    return _.filter(obj, _.negate(cb(predicate)), context);\n  };\n\n  // Determine whether all of the elements match a truth test.\n  // Aliased as `all`.\n  _.every = _.all = function(obj, predicate, context) {\n    predicate = cb(predicate, context);\n    var keys = !isArrayLike(obj) && _.keys(obj),\n        length = (keys || obj).length;\n    for (var index = 0; index < length; index++) {\n      var currentKey = keys ? keys[index] : index;\n      if (!predicate(obj[currentKey], currentKey, obj)) return false;\n    }\n    return true;\n  };\n\n  // Determine if at least one element in the object matches a truth test.\n  // Aliased as `any`.\n  _.some = _.any = function(obj, predicate, context) {\n    predicate = cb(predicate, context);\n    var keys = !isArrayLike(obj) && _.keys(obj),\n        length = (keys || obj).length;\n    for (var index = 0; index < length; index++) {\n      var currentKey = keys ? keys[index] : index;\n      if (predicate(obj[currentKey], currentKey, obj)) return true;\n    }\n    return false;\n  };\n\n  // Determine if the array or object contains a given item (using `===`).\n  // Aliased as `includes` and `include`.\n  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {\n    if (!isArrayLike(obj)) obj = _.values(obj);\n    if (typeof fromIndex != 'number' || guard) fromIndex = 0;\n    return _.indexOf(obj, item, fromIndex) >= 0;\n  };\n\n  // Invoke a method (with arguments) on every item in a collection.\n  _.invoke = function(obj, method) {\n    var args = slice.call(arguments, 2);\n    var isFunc = _.isFunction(method);\n    return _.map(obj, function(value) {\n      var func = isFunc ? method : value[method];\n      return func == null ? func : func.apply(value, args);\n    });\n  };\n\n  // Convenience version of a common use case of `map`: fetching a property.\n  _.pluck = function(obj, key) {\n    return _.map(obj, _.property(key));\n  };\n\n  // Convenience version of a common use case of `filter`: selecting only objects\n  // containing specific `key:value` pairs.\n  _.where = function(obj, attrs) {\n    return _.filter(obj, _.matcher(attrs));\n  };\n\n  // Convenience version of a common use case of `find`: getting the first object\n  // containing specific `key:value` pairs.\n  _.findWhere = function(obj, attrs) {\n    return _.find(obj, _.matcher(attrs));\n  };\n\n  // Return the maximum element (or element-based computation).\n  _.max = function(obj, iteratee, context) {\n    var result = -Infinity, lastComputed = -Infinity,\n        value, computed;\n    if (iteratee == null && obj != null) {\n      obj = isArrayLike(obj) ? obj : _.values(obj);\n      for (var i = 0, length = obj.length; i < length; i++) {\n        value = obj[i];\n        if (value > result) {\n          result = value;\n        }\n      }\n    } else {\n      iteratee = cb(iteratee, context);\n      _.each(obj, function(value, index, list) {\n        computed = iteratee(value, index, list);\n        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {\n          result = value;\n          lastComputed = computed;\n        }\n      });\n    }\n    return result;\n  };\n\n  // Return the minimum element (or element-based computation).\n  _.min = function(obj, iteratee, context) {\n    var result = Infinity, lastComputed = Infinity,\n        value, computed;\n    if (iteratee == null && obj != null) {\n      obj = isArrayLike(obj) ? obj : _.values(obj);\n      for (var i = 0, length = obj.length; i < length; i++) {\n        value = obj[i];\n        if (value < result) {\n          result = value;\n        }\n      }\n    } else {\n      iteratee = cb(iteratee, context);\n      _.each(obj, function(value, index, list) {\n        computed = iteratee(value, index, list);\n        if (computed < lastComputed || computed === Infinity && result === Infinity) {\n          result = value;\n          lastComputed = computed;\n        }\n      });\n    }\n    return result;\n  };\n\n  // Shuffle a collection, using the modern version of the\n  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/FisherYates_shuffle).\n  _.shuffle = function(obj) {\n    var set = isArrayLike(obj) ? obj : _.values(obj);\n    var length = set.length;\n    var shuffled = Array(length);\n    for (var index = 0, rand; index < length; index++) {\n      rand = _.random(0, index);\n      if (rand !== index) shuffled[index] = shuffled[rand];\n      shuffled[rand] = set[index];\n    }\n    return shuffled;\n  };\n\n  // Sample **n** random values from a collection.\n  // If **n** is not specified, returns a single random element.\n  // The internal `guard` argument allows it to work with `map`.\n  _.sample = function(obj, n, guard) {\n    if (n == null || guard) {\n      if (!isArrayLike(obj)) obj = _.values(obj);\n      return obj[_.random(obj.length - 1)];\n    }\n    return _.shuffle(obj).slice(0, Math.max(0, n));\n  };\n\n  // Sort the object's values by a criterion produced by an iteratee.\n  _.sortBy = function(obj, iteratee, context) {\n    iteratee = cb(iteratee, context);\n    return _.pluck(_.map(obj, function(value, index, list) {\n      return {\n        value: value,\n        index: index,\n        criteria: iteratee(value, index, list)\n      };\n    }).sort(function(left, right) {\n      var a = left.criteria;\n      var b = right.criteria;\n      if (a !== b) {\n        if (a > b || a === void 0) return 1;\n        if (a < b || b === void 0) return -1;\n      }\n      return left.index - right.index;\n    }), 'value');\n  };\n\n  // An internal function used for aggregate \"group by\" operations.\n  var group = function(behavior) {\n    return function(obj, iteratee, context) {\n      var result = {};\n      iteratee = cb(iteratee, context);\n      _.each(obj, function(value, index) {\n        var key = iteratee(value, index, obj);\n        behavior(result, value, key);\n      });\n      return result;\n    };\n  };\n\n  // Groups the object's values by a criterion. Pass either a string attribute\n  // to group by, or a function that returns the criterion.\n  _.groupBy = group(function(result, value, key) {\n    if (_.has(result, key)) result[key].push(value); else result[key] = [value];\n  });\n\n  // Indexes the object's values by a criterion, similar to `groupBy`, but for\n  // when you know that your index values will be unique.\n  _.indexBy = group(function(result, value, key) {\n    result[key] = value;\n  });\n\n  // Counts instances of an object that group by a certain criterion. Pass\n  // either a string attribute to count by, or a function that returns the\n  // criterion.\n  _.countBy = group(function(result, value, key) {\n    if (_.has(result, key)) result[key]++; else result[key] = 1;\n  });\n\n  // Safely create a real, live array from anything iterable.\n  _.toArray = function(obj) {\n    if (!obj) return [];\n    if (_.isArray(obj)) return slice.call(obj);\n    if (isArrayLike(obj)) return _.map(obj, _.identity);\n    return _.values(obj);\n  };\n\n  // Return the number of elements in an object.\n  _.size = function(obj) {\n    if (obj == null) return 0;\n    return isArrayLike(obj) ? obj.length : _.keys(obj).length;\n  };\n\n  // Split a collection into two arrays: one whose elements all satisfy the given\n  // predicate, and one whose elements all do not satisfy the predicate.\n  _.partition = function(obj, predicate, context) {\n    predicate = cb(predicate, context);\n    var pass = [], fail = [];\n    _.each(obj, function(value, key, obj) {\n      (predicate(value, key, obj) ? pass : fail).push(value);\n    });\n    return [pass, fail];\n  };\n\n  // Array Functions\n  // ---------------\n\n  // Get the first element of an array. Passing **n** will return the first N\n  // values in the array. Aliased as `head` and `take`. The **guard** check\n  // allows it to work with `_.map`.\n  _.first = _.head = _.take = function(array, n, guard) {\n    if (array == null) return void 0;\n    if (n == null || guard) return array[0];\n    return _.initial(array, array.length - n);\n  };\n\n  // Returns everything but the last entry of the array. Especially useful on\n  // the arguments object. Passing **n** will return all the values in\n  // the array, excluding the last N.\n  _.initial = function(array, n, guard) {\n    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));\n  };\n\n  // Get the last element of an array. Passing **n** will return the last N\n  // values in the array.\n  _.last = function(array, n, guard) {\n    if (array == null) return void 0;\n    if (n == null || guard) return array[array.length - 1];\n    return _.rest(array, Math.max(0, array.length - n));\n  };\n\n  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.\n  // Especially useful on the arguments object. Passing an **n** will return\n  // the rest N values in the array.\n  _.rest = _.tail = _.drop = function(array, n, guard) {\n    return slice.call(array, n == null || guard ? 1 : n);\n  };\n\n  // Trim out all falsy values from an array.\n  _.compact = function(array) {\n    return _.filter(array, _.identity);\n  };\n\n  // Internal implementation of a recursive `flatten` function.\n  var flatten = function(input, shallow, strict, startIndex) {\n    var output = [], idx = 0;\n    for (var i = startIndex || 0, length = getLength(input); i < length; i++) {\n      var value = input[i];\n      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {\n        //flatten current level of array or arguments object\n        if (!shallow) value = flatten(value, shallow, strict);\n        var j = 0, len = value.length;\n        output.length += len;\n        while (j < len) {\n          output[idx++] = value[j++];\n        }\n      } else if (!strict) {\n        output[idx++] = value;\n      }\n    }\n    return output;\n  };\n\n  // Flatten out an array, either recursively (by default), or just one level.\n  _.flatten = function(array, shallow) {\n    return flatten(array, shallow, false);\n  };\n\n  // Return a version of the array that does not contain the specified value(s).\n  _.without = function(array) {\n    return _.difference(array, slice.call(arguments, 1));\n  };\n\n  // Produce a duplicate-free version of the array. If the array has already\n  // been sorted, you have the option of using a faster algorithm.\n  // Aliased as `unique`.\n  _.uniq = _.unique = function(array, isSorted, iteratee, context) {\n    if (!_.isBoolean(isSorted)) {\n      context = iteratee;\n      iteratee = isSorted;\n      isSorted = false;\n    }\n    if (iteratee != null) iteratee = cb(iteratee, context);\n    var result = [];\n    var seen = [];\n    for (var i = 0, length = getLength(array); i < length; i++) {\n      var value = array[i],\n          computed = iteratee ? iteratee(value, i, array) : value;\n      if (isSorted) {\n        if (!i || seen !== computed) result.push(value);\n        seen = computed;\n      } else if (iteratee) {\n        if (!_.contains(seen, computed)) {\n          seen.push(computed);\n          result.push(value);\n        }\n      } else if (!_.contains(result, value)) {\n        result.push(value);\n      }\n    }\n    return result;\n  };\n\n  // Produce an array that contains the union: each distinct element from all of\n  // the passed-in arrays.\n  _.union = function() {\n    return _.uniq(flatten(arguments, true, true));\n  };\n\n  // Produce an array that contains every item shared between all the\n  // passed-in arrays.\n  _.intersection = function(array) {\n    var result = [];\n    var argsLength = arguments.length;\n    for (var i = 0, length = getLength(array); i < length; i++) {\n      var item = array[i];\n      if (_.contains(result, item)) continue;\n      for (var j = 1; j < argsLength; j++) {\n        if (!_.contains(arguments[j], item)) break;\n      }\n      if (j === argsLength) result.push(item);\n    }\n    return result;\n  };\n\n  // Take the difference between one array and a number of other arrays.\n  // Only the elements present in just the first array will remain.\n  _.difference = function(array) {\n    var rest = flatten(arguments, true, true, 1);\n    return _.filter(array, function(value){\n      return !_.contains(rest, value);\n    });\n  };\n\n  // Zip together multiple lists into a single array -- elements that share\n  // an index go together.\n  _.zip = function() {\n    return _.unzip(arguments);\n  };\n\n  // Complement of _.zip. Unzip accepts an array of arrays and groups\n  // each array's elements on shared indices\n  _.unzip = function(array) {\n    var length = array && _.max(array, getLength).length || 0;\n    var result = Array(length);\n\n    for (var index = 0; index < length; index++) {\n      result[index] = _.pluck(array, index);\n    }\n    return result;\n  };\n\n  // Converts lists into objects. Pass either a single array of `[key, value]`\n  // pairs, or two parallel arrays of the same length -- one of keys, and one of\n  // the corresponding values.\n  _.object = function(list, values) {\n    var result = {};\n    for (var i = 0, length = getLength(list); i < length; i++) {\n      if (values) {\n        result[list[i]] = values[i];\n      } else {\n        result[list[i][0]] = list[i][1];\n      }\n    }\n    return result;\n  };\n\n  // Generator function to create the findIndex and findLastIndex functions\n  function createPredicateIndexFinder(dir) {\n    return function(array, predicate, context) {\n      predicate = cb(predicate, context);\n      var length = getLength(array);\n      var index = dir > 0 ? 0 : length - 1;\n      for (; index >= 0 && index < length; index += dir) {\n        if (predicate(array[index], index, array)) return index;\n      }\n      return -1;\n    };\n  }\n\n  // Returns the first index on an array-like that passes a predicate test\n  _.findIndex = createPredicateIndexFinder(1);\n  _.findLastIndex = createPredicateIndexFinder(-1);\n\n  // Use a comparator function to figure out the smallest index at which\n  // an object should be inserted so as to maintain order. Uses binary search.\n  _.sortedIndex = function(array, obj, iteratee, context) {\n    iteratee = cb(iteratee, context, 1);\n    var value = iteratee(obj);\n    var low = 0, high = getLength(array);\n    while (low < high) {\n      var mid = Math.floor((low + high) / 2);\n      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;\n    }\n    return low;\n  };\n\n  // Generator function to create the indexOf and lastIndexOf functions\n  function createIndexFinder(dir, predicateFind, sortedIndex) {\n    return function(array, item, idx) {\n      var i = 0, length = getLength(array);\n      if (typeof idx == 'number') {\n        if (dir > 0) {\n            i = idx >= 0 ? idx : Math.max(idx + length, i);\n        } else {\n            length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;\n        }\n      } else if (sortedIndex && idx && length) {\n        idx = sortedIndex(array, item);\n        return array[idx] === item ? idx : -1;\n      }\n      if (item !== item) {\n        idx = predicateFind(slice.call(array, i, length), _.isNaN);\n        return idx >= 0 ? idx + i : -1;\n      }\n      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {\n        if (array[idx] === item) return idx;\n      }\n      return -1;\n    };\n  }\n\n  // Return the position of the first occurrence of an item in an array,\n  // or -1 if the item is not included in the array.\n  // If the array is large and already in sort order, pass `true`\n  // for **isSorted** to use binary search.\n  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);\n  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);\n\n  // Generate an integer Array containing an arithmetic progression. A port of\n  // the native Python `range()` function. See\n  // [the Python documentation](http://docs.python.org/library/functions.html#range).\n  _.range = function(start, stop, step) {\n    if (stop == null) {\n      stop = start || 0;\n      start = 0;\n    }\n    step = step || 1;\n\n    var length = Math.max(Math.ceil((stop - start) / step), 0);\n    var range = Array(length);\n\n    for (var idx = 0; idx < length; idx++, start += step) {\n      range[idx] = start;\n    }\n\n    return range;\n  };\n\n  // Function (ahem) Functions\n  // ------------------\n\n  // Determines whether to execute a function as a constructor\n  // or a normal function with the provided arguments\n  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {\n    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);\n    var self = baseCreate(sourceFunc.prototype);\n    var result = sourceFunc.apply(self, args);\n    if (_.isObject(result)) return result;\n    return self;\n  };\n\n  // Create a function bound to a given object (assigning `this`, and arguments,\n  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if\n  // available.\n  _.bind = function(func, context) {\n    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));\n    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');\n    var args = slice.call(arguments, 2);\n    var bound = function() {\n      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));\n    };\n    return bound;\n  };\n\n  // Partially apply a function by creating a version that has had some of its\n  // arguments pre-filled, without changing its dynamic `this` context. _ acts\n  // as a placeholder, allowing any combination of arguments to be pre-filled.\n  _.partial = function(func) {\n    var boundArgs = slice.call(arguments, 1);\n    var bound = function() {\n      var position = 0, length = boundArgs.length;\n      var args = Array(length);\n      for (var i = 0; i < length; i++) {\n        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];\n      }\n      while (position < arguments.length) args.push(arguments[position++]);\n      return executeBound(func, bound, this, this, args);\n    };\n    return bound;\n  };\n\n  // Bind a number of an object's methods to that object. Remaining arguments\n  // are the method names to be bound. Useful for ensuring that all callbacks\n  // defined on an object belong to it.\n  _.bindAll = function(obj) {\n    var i, length = arguments.length, key;\n    if (length <= 1) throw new Error('bindAll must be passed function names');\n    for (i = 1; i < length; i++) {\n      key = arguments[i];\n      obj[key] = _.bind(obj[key], obj);\n    }\n    return obj;\n  };\n\n  // Memoize an expensive function by storing its results.\n  _.memoize = function(func, hasher) {\n    var memoize = function(key) {\n      var cache = memoize.cache;\n      var address = '' + (hasher ? hasher.apply(this, arguments) : key);\n      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);\n      return cache[address];\n    };\n    memoize.cache = {};\n    return memoize;\n  };\n\n  // Delays a function for the given number of milliseconds, and then calls\n  // it with the arguments supplied.\n  _.delay = function(func, wait) {\n    var args = slice.call(arguments, 2);\n    return setTimeout(function(){\n      return func.apply(null, args);\n    }, wait);\n  };\n\n  // Defers a function, scheduling it to run after the current call stack has\n  // cleared.\n  _.defer = _.partial(_.delay, _, 1);\n\n  // Returns a function, that, when invoked, will only be triggered at most once\n  // during a given window of time. Normally, the throttled function will run\n  // as much as it can, without ever going more than once per `wait` duration;\n  // but if you'd like to disable the execution on the leading edge, pass\n  // `{leading: false}`. To disable execution on the trailing edge, ditto.\n  _.throttle = function(func, wait, options) {\n    var context, args, result;\n    var timeout = null;\n    var previous = 0;\n    if (!options) options = {};\n    var later = function() {\n      previous = options.leading === false ? 0 : _.now();\n      timeout = null;\n      result = func.apply(context, args);\n      if (!timeout) context = args = null;\n    };\n    return function() {\n      var now = _.now();\n      if (!previous && options.leading === false) previous = now;\n      var remaining = wait - (now - previous);\n      context = this;\n      args = arguments;\n      if (remaining <= 0 || remaining > wait) {\n        if (timeout) {\n          clearTimeout(timeout);\n          timeout = null;\n        }\n        previous = now;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      } else if (!timeout && options.trailing !== false) {\n        timeout = setTimeout(later, remaining);\n      }\n      return result;\n    };\n  };\n\n  // Returns a function, that, as long as it continues to be invoked, will not\n  // be triggered. The function will be called after it stops being called for\n  // N milliseconds. If `immediate` is passed, trigger the function on the\n  // leading edge, instead of the trailing.\n  _.debounce = function(func, wait, immediate) {\n    var timeout, args, context, timestamp, result;\n\n    var later = function() {\n      var last = _.now() - timestamp;\n\n      if (last < wait && last >= 0) {\n        timeout = setTimeout(later, wait - last);\n      } else {\n        timeout = null;\n        if (!immediate) {\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        }\n      }\n    };\n\n    return function() {\n      context = this;\n      args = arguments;\n      timestamp = _.now();\n      var callNow = immediate && !timeout;\n      if (!timeout) timeout = setTimeout(later, wait);\n      if (callNow) {\n        result = func.apply(context, args);\n        context = args = null;\n      }\n\n      return result;\n    };\n  };\n\n  // Returns the first function passed as an argument to the second,\n  // allowing you to adjust arguments, run code before and after, and\n  // conditionally execute the original function.\n  _.wrap = function(func, wrapper) {\n    return _.partial(wrapper, func);\n  };\n\n  // Returns a negated version of the passed-in predicate.\n  _.negate = function(predicate) {\n    return function() {\n      return !predicate.apply(this, arguments);\n    };\n  };\n\n  // Returns a function that is the composition of a list of functions, each\n  // consuming the return value of the function that follows.\n  _.compose = function() {\n    var args = arguments;\n    var start = args.length - 1;\n    return function() {\n      var i = start;\n      var result = args[start].apply(this, arguments);\n      while (i--) result = args[i].call(this, result);\n      return result;\n    };\n  };\n\n  // Returns a function that will only be executed on and after the Nth call.\n  _.after = function(times, func) {\n    return function() {\n      if (--times < 1) {\n        return func.apply(this, arguments);\n      }\n    };\n  };\n\n  // Returns a function that will only be executed up to (but not including) the Nth call.\n  _.before = function(times, func) {\n    var memo;\n    return function() {\n      if (--times > 0) {\n        memo = func.apply(this, arguments);\n      }\n      if (times <= 1) func = null;\n      return memo;\n    };\n  };\n\n  // Returns a function that will be executed at most one time, no matter how\n  // often you call it. Useful for lazy initialization.\n  _.once = _.partial(_.before, 2);\n\n  // Object Functions\n  // ----------------\n\n  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.\n  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');\n  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',\n                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];\n\n  function collectNonEnumProps(obj, keys) {\n    var nonEnumIdx = nonEnumerableProps.length;\n    var constructor = obj.constructor;\n    var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;\n\n    // Constructor is a special case.\n    var prop = 'constructor';\n    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);\n\n    while (nonEnumIdx--) {\n      prop = nonEnumerableProps[nonEnumIdx];\n      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {\n        keys.push(prop);\n      }\n    }\n  }\n\n  // Retrieve the names of an object's own properties.\n  // Delegates to **ECMAScript 5**'s native `Object.keys`\n  _.keys = function(obj) {\n    if (!_.isObject(obj)) return [];\n    if (nativeKeys) return nativeKeys(obj);\n    var keys = [];\n    for (var key in obj) if (_.has(obj, key)) keys.push(key);\n    // Ahem, IE < 9.\n    if (hasEnumBug) collectNonEnumProps(obj, keys);\n    return keys;\n  };\n\n  // Retrieve all the property names of an object.\n  _.allKeys = function(obj) {\n    if (!_.isObject(obj)) return [];\n    var keys = [];\n    for (var key in obj) keys.push(key);\n    // Ahem, IE < 9.\n    if (hasEnumBug) collectNonEnumProps(obj, keys);\n    return keys;\n  };\n\n  // Retrieve the values of an object's properties.\n  _.values = function(obj) {\n    var keys = _.keys(obj);\n    var length = keys.length;\n    var values = Array(length);\n    for (var i = 0; i < length; i++) {\n      values[i] = obj[keys[i]];\n    }\n    return values;\n  };\n\n  // Returns the results of applying the iteratee to each element of the object\n  // In contrast to _.map it returns an object\n  _.mapObject = function(obj, iteratee, context) {\n    iteratee = cb(iteratee, context);\n    var keys =  _.keys(obj),\n          length = keys.length,\n          results = {},\n          currentKey;\n      for (var index = 0; index < length; index++) {\n        currentKey = keys[index];\n        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);\n      }\n      return results;\n  };\n\n  // Convert an object into a list of `[key, value]` pairs.\n  _.pairs = function(obj) {\n    var keys = _.keys(obj);\n    var length = keys.length;\n    var pairs = Array(length);\n    for (var i = 0; i < length; i++) {\n      pairs[i] = [keys[i], obj[keys[i]]];\n    }\n    return pairs;\n  };\n\n  // Invert the keys and values of an object. The values must be serializable.\n  _.invert = function(obj) {\n    var result = {};\n    var keys = _.keys(obj);\n    for (var i = 0, length = keys.length; i < length; i++) {\n      result[obj[keys[i]]] = keys[i];\n    }\n    return result;\n  };\n\n  // Return a sorted list of the function names available on the object.\n  // Aliased as `methods`\n  _.functions = _.methods = function(obj) {\n    var names = [];\n    for (var key in obj) {\n      if (_.isFunction(obj[key])) names.push(key);\n    }\n    return names.sort();\n  };\n\n  // Extend a given object with all the properties in passed-in object(s).\n  _.extend = createAssigner(_.allKeys);\n\n  // Assigns a given object with all the own properties in the passed-in object(s)\n  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)\n  _.extendOwn = _.assign = createAssigner(_.keys);\n\n  // Returns the first key on an object that passes a predicate test\n  _.findKey = function(obj, predicate, context) {\n    predicate = cb(predicate, context);\n    var keys = _.keys(obj), key;\n    for (var i = 0, length = keys.length; i < length; i++) {\n      key = keys[i];\n      if (predicate(obj[key], key, obj)) return key;\n    }\n  };\n\n  // Return a copy of the object only containing the whitelisted properties.\n  _.pick = function(object, oiteratee, context) {\n    var result = {}, obj = object, iteratee, keys;\n    if (obj == null) return result;\n    if (_.isFunction(oiteratee)) {\n      keys = _.allKeys(obj);\n      iteratee = optimizeCb(oiteratee, context);\n    } else {\n      keys = flatten(arguments, false, false, 1);\n      iteratee = function(value, key, obj) { return key in obj; };\n      obj = Object(obj);\n    }\n    for (var i = 0, length = keys.length; i < length; i++) {\n      var key = keys[i];\n      var value = obj[key];\n      if (iteratee(value, key, obj)) result[key] = value;\n    }\n    return result;\n  };\n\n   // Return a copy of the object without the blacklisted properties.\n  _.omit = function(obj, iteratee, context) {\n    if (_.isFunction(iteratee)) {\n      iteratee = _.negate(iteratee);\n    } else {\n      var keys = _.map(flatten(arguments, false, false, 1), String);\n      iteratee = function(value, key) {\n        return !_.contains(keys, key);\n      };\n    }\n    return _.pick(obj, iteratee, context);\n  };\n\n  // Fill in a given object with default properties.\n  _.defaults = createAssigner(_.allKeys, true);\n\n  // Creates an object that inherits from the given prototype object.\n  // If additional properties are provided then they will be added to the\n  // created object.\n  _.create = function(prototype, props) {\n    var result = baseCreate(prototype);\n    if (props) _.extendOwn(result, props);\n    return result;\n  };\n\n  // Create a (shallow-cloned) duplicate of an object.\n  _.clone = function(obj) {\n    if (!_.isObject(obj)) return obj;\n    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);\n  };\n\n  // Invokes interceptor with the obj, and then returns obj.\n  // The primary purpose of this method is to \"tap into\" a method chain, in\n  // order to perform operations on intermediate results within the chain.\n  _.tap = function(obj, interceptor) {\n    interceptor(obj);\n    return obj;\n  };\n\n  // Returns whether an object has a given set of `key:value` pairs.\n  _.isMatch = function(object, attrs) {\n    var keys = _.keys(attrs), length = keys.length;\n    if (object == null) return !length;\n    var obj = Object(object);\n    for (var i = 0; i < length; i++) {\n      var key = keys[i];\n      if (attrs[key] !== obj[key] || !(key in obj)) return false;\n    }\n    return true;\n  };\n\n\n  // Internal recursive comparison function for `isEqual`.\n  var eq = function(a, b, aStack, bStack) {\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\n    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).\n    if (a === b) return a !== 0 || 1 / a === 1 / b;\n    // A strict comparison is necessary because `null == undefined`.\n    if (a == null || b == null) return a === b;\n    // Unwrap any wrapped objects.\n    if (a instanceof _) a = a._wrapped;\n    if (b instanceof _) b = b._wrapped;\n    // Compare `[[Class]]` names.\n    var className = toString.call(a);\n    if (className !== toString.call(b)) return false;\n    switch (className) {\n      // Strings, numbers, regular expressions, dates, and booleans are compared by value.\n      case '[object RegExp]':\n      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')\n      case '[object String]':\n        // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n        // equivalent to `new String(\"5\")`.\n        return '' + a === '' + b;\n      case '[object Number]':\n        // `NaN`s are equivalent, but non-reflexive.\n        // Object(NaN) is equivalent to NaN\n        if (+a !== +a) return +b !== +b;\n        // An `egal` comparison is performed for other numeric values.\n        return +a === 0 ? 1 / +a === 1 / b : +a === +b;\n      case '[object Date]':\n      case '[object Boolean]':\n        // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n        // millisecond representations. Note that invalid dates with millisecond representations\n        // of `NaN` are not equivalent.\n        return +a === +b;\n    }\n\n    var areArrays = className === '[object Array]';\n    if (!areArrays) {\n      if (typeof a != 'object' || typeof b != 'object') return false;\n\n      // Objects with different constructors are not equivalent, but `Object`s or `Array`s\n      // from different frames are.\n      var aCtor = a.constructor, bCtor = b.constructor;\n      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&\n                               _.isFunction(bCtor) && bCtor instanceof bCtor)\n                          && ('constructor' in a && 'constructor' in b)) {\n        return false;\n      }\n    }\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n\n    // Initializing stack of traversed objects.\n    // It's done here since we only need them for objects and arrays comparison.\n    aStack = aStack || [];\n    bStack = bStack || [];\n    var length = aStack.length;\n    while (length--) {\n      // Linear search. Performance is inversely proportional to the number of\n      // unique nested structures.\n      if (aStack[length] === a) return bStack[length] === b;\n    }\n\n    // Add the first object to the stack of traversed objects.\n    aStack.push(a);\n    bStack.push(b);\n\n    // Recursively compare objects and arrays.\n    if (areArrays) {\n      // Compare array lengths to determine if a deep comparison is necessary.\n      length = a.length;\n      if (length !== b.length) return false;\n      // Deep compare the contents, ignoring non-numeric properties.\n      while (length--) {\n        if (!eq(a[length], b[length], aStack, bStack)) return false;\n      }\n    } else {\n      // Deep compare objects.\n      var keys = _.keys(a), key;\n      length = keys.length;\n      // Ensure that both objects contain the same number of properties before comparing deep equality.\n      if (_.keys(b).length !== length) return false;\n      while (length--) {\n        // Deep compare each member\n        key = keys[length];\n        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;\n      }\n    }\n    // Remove the first object from the stack of traversed objects.\n    aStack.pop();\n    bStack.pop();\n    return true;\n  };\n\n  // Perform a deep comparison to check if two objects are equal.\n  _.isEqual = function(a, b) {\n    return eq(a, b);\n  };\n\n  // Is a given array, string, or object empty?\n  // An \"empty\" object has no enumerable own-properties.\n  _.isEmpty = function(obj) {\n    if (obj == null) return true;\n    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;\n    return _.keys(obj).length === 0;\n  };\n\n  // Is a given value a DOM element?\n  _.isElement = function(obj) {\n    return !!(obj && obj.nodeType === 1);\n  };\n\n  // Is a given value an array?\n  // Delegates to ECMA5's native Array.isArray\n  _.isArray = nativeIsArray || function(obj) {\n    return toString.call(obj) === '[object Array]';\n  };\n\n  // Is a given variable an object?\n  _.isObject = function(obj) {\n    var type = typeof obj;\n    return type === 'function' || type === 'object' && !!obj;\n  };\n\n  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.\n  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {\n    _['is' + name] = function(obj) {\n      return toString.call(obj) === '[object ' + name + ']';\n    };\n  });\n\n  // Define a fallback version of the method in browsers (ahem, IE < 9), where\n  // there isn't any inspectable \"Arguments\" type.\n  if (!_.isArguments(arguments)) {\n    _.isArguments = function(obj) {\n      return _.has(obj, 'callee');\n    };\n  }\n\n  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,\n  // IE 11 (#1621), and in Safari 8 (#1929).\n  if (typeof /./ != 'function' && typeof Int8Array != 'object') {\n    _.isFunction = function(obj) {\n      return typeof obj == 'function' || false;\n    };\n  }\n\n  // Is a given object a finite number?\n  _.isFinite = function(obj) {\n    return isFinite(obj) && !isNaN(parseFloat(obj));\n  };\n\n  // Is the given value `NaN`? (NaN is the only number which does not equal itself).\n  _.isNaN = function(obj) {\n    return _.isNumber(obj) && obj !== +obj;\n  };\n\n  // Is a given value a boolean?\n  _.isBoolean = function(obj) {\n    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';\n  };\n\n  // Is a given value equal to null?\n  _.isNull = function(obj) {\n    return obj === null;\n  };\n\n  // Is a given variable undefined?\n  _.isUndefined = function(obj) {\n    return obj === void 0;\n  };\n\n  // Shortcut function for checking if an object has a given property directly\n  // on itself (in other words, not on a prototype).\n  _.has = function(obj, key) {\n    return obj != null && hasOwnProperty.call(obj, key);\n  };\n\n  // Utility Functions\n  // -----------------\n\n  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its\n  // previous owner. Returns a reference to the Underscore object.\n  _.noConflict = function() {\n    root._ = previousUnderscore;\n    return this;\n  };\n\n  // Keep the identity function around for default iteratees.\n  _.identity = function(value) {\n    return value;\n  };\n\n  // Predicate-generating functions. Often useful outside of Underscore.\n  _.constant = function(value) {\n    return function() {\n      return value;\n    };\n  };\n\n  _.noop = function(){};\n\n  _.property = property;\n\n  // Generates a function for a given object that returns a given property.\n  _.propertyOf = function(obj) {\n    return obj == null ? function(){} : function(key) {\n      return obj[key];\n    };\n  };\n\n  // Returns a predicate for checking whether an object has a given set of\n  // `key:value` pairs.\n  _.matcher = _.matches = function(attrs) {\n    attrs = _.extendOwn({}, attrs);\n    return function(obj) {\n      return _.isMatch(obj, attrs);\n    };\n  };\n\n  // Run a function **n** times.\n  _.times = function(n, iteratee, context) {\n    var accum = Array(Math.max(0, n));\n    iteratee = optimizeCb(iteratee, context, 1);\n    for (var i = 0; i < n; i++) accum[i] = iteratee(i);\n    return accum;\n  };\n\n  // Return a random integer between min and max (inclusive).\n  _.random = function(min, max) {\n    if (max == null) {\n      max = min;\n      min = 0;\n    }\n    return min + Math.floor(Math.random() * (max - min + 1));\n  };\n\n  // A (possibly faster) way to get the current timestamp as an integer.\n  _.now = Date.now || function() {\n    return new Date().getTime();\n  };\n\n   // List of HTML entities for escaping.\n  var escapeMap = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#x27;',\n    '`': '&#x60;'\n  };\n  var unescapeMap = _.invert(escapeMap);\n\n  // Functions for escaping and unescaping strings to/from HTML interpolation.\n  var createEscaper = function(map) {\n    var escaper = function(match) {\n      return map[match];\n    };\n    // Regexes for identifying a key that needs to be escaped\n    var source = '(?:' + _.keys(map).join('|') + ')';\n    var testRegexp = RegExp(source);\n    var replaceRegexp = RegExp(source, 'g');\n    return function(string) {\n      string = string == null ? '' : '' + string;\n      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;\n    };\n  };\n  _.escape = createEscaper(escapeMap);\n  _.unescape = createEscaper(unescapeMap);\n\n  // If the value of the named `property` is a function then invoke it with the\n  // `object` as context; otherwise, return it.\n  _.result = function(object, property, fallback) {\n    var value = object == null ? void 0 : object[property];\n    if (value === void 0) {\n      value = fallback;\n    }\n    return _.isFunction(value) ? value.call(object) : value;\n  };\n\n  // Generate a unique integer id (unique within the entire client session).\n  // Useful for temporary DOM ids.\n  var idCounter = 0;\n  _.uniqueId = function(prefix) {\n    var id = ++idCounter + '';\n    return prefix ? prefix + id : id;\n  };\n\n  // By default, Underscore uses ERB-style template delimiters, change the\n  // following template settings to use alternative delimiters.\n  _.templateSettings = {\n    evaluate    : /<%([\\s\\S]+?)%>/g,\n    interpolate : /<%=([\\s\\S]+?)%>/g,\n    escape      : /<%-([\\s\\S]+?)%>/g\n  };\n\n  // When customizing `templateSettings`, if you don't want to define an\n  // interpolation, evaluation or escaping regex, we need one that is\n  // guaranteed not to match.\n  var noMatch = /(.)^/;\n\n  // Certain characters need to be escaped so that they can be put into a\n  // string literal.\n  var escapes = {\n    \"'\":      \"'\",\n    '\\\\':     '\\\\',\n    '\\r':     'r',\n    '\\n':     'n',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n  };\n\n  var escaper = /\\\\|'|\\r|\\n|\\u2028|\\u2029/g;\n\n  var escapeChar = function(match) {\n    return '\\\\' + escapes[match];\n  };\n\n  // JavaScript micro-templating, similar to John Resig's implementation.\n  // Underscore templating handles arbitrary delimiters, preserves whitespace,\n  // and correctly escapes quotes within interpolated code.\n  // NB: `oldSettings` only exists for backwards compatibility.\n  _.template = function(text, settings, oldSettings) {\n    if (!settings && oldSettings) settings = oldSettings;\n    settings = _.defaults({}, settings, _.templateSettings);\n\n    // Combine delimiters into one regular expression via alternation.\n    var matcher = RegExp([\n      (settings.escape || noMatch).source,\n      (settings.interpolate || noMatch).source,\n      (settings.evaluate || noMatch).source\n    ].join('|') + '|$', 'g');\n\n    // Compile the template source, escaping string literals appropriately.\n    var index = 0;\n    var source = \"__p+='\";\n    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {\n      source += text.slice(index, offset).replace(escaper, escapeChar);\n      index = offset + match.length;\n\n      if (escape) {\n        source += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";\n      } else if (interpolate) {\n        source += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";\n      } else if (evaluate) {\n        source += \"';\\n\" + evaluate + \"\\n__p+='\";\n      }\n\n      // Adobe VMs need the match returned to produce the correct offest.\n      return match;\n    });\n    source += \"';\\n\";\n\n    // If a variable is not specified, place data values in local scope.\n    if (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\n\n    source = \"var __t,__p='',__j=Array.prototype.join,\" +\n      \"print=function(){__p+=__j.call(arguments,'');};\\n\" +\n      source + 'return __p;\\n';\n\n    try {\n      var render = new Function(settings.variable || 'obj', '_', source);\n    } catch (e) {\n      e.source = source;\n      throw e;\n    }\n\n    var template = function(data) {\n      return render.call(this, data, _);\n    };\n\n    // Provide the compiled source as a convenience for precompilation.\n    var argument = settings.variable || 'obj';\n    template.source = 'function(' + argument + '){\\n' + source + '}';\n\n    return template;\n  };\n\n  // Add a \"chain\" function. Start chaining a wrapped Underscore object.\n  _.chain = function(obj) {\n    var instance = _(obj);\n    instance._chain = true;\n    return instance;\n  };\n\n  // OOP\n  // ---------------\n  // If Underscore is called as a function, it returns a wrapped object that\n  // can be used OO-style. This wrapper holds altered versions of all the\n  // underscore functions. Wrapped objects may be chained.\n\n  // Helper function to continue chaining intermediate results.\n  var result = function(instance, obj) {\n    return instance._chain ? _(obj).chain() : obj;\n  };\n\n  // Add your own custom functions to the Underscore object.\n  _.mixin = function(obj) {\n    _.each(_.functions(obj), function(name) {\n      var func = _[name] = obj[name];\n      _.prototype[name] = function() {\n        var args = [this._wrapped];\n        push.apply(args, arguments);\n        return result(this, func.apply(_, args));\n      };\n    });\n  };\n\n  // Add all of the Underscore functions to the wrapper object.\n  _.mixin(_);\n\n  // Add all mutator Array functions to the wrapper.\n  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      var obj = this._wrapped;\n      method.apply(obj, arguments);\n      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];\n      return result(this, obj);\n    };\n  });\n\n  // Add all accessor Array functions to the wrapper.\n  _.each(['concat', 'join', 'slice'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      return result(this, method.apply(this._wrapped, arguments));\n    };\n  });\n\n  // Extracts the result from a wrapped and chained object.\n  _.prototype.value = function() {\n    return this._wrapped;\n  };\n\n  // Provide unwrapping proxy for some methods used in engine operations\n  // such as arithmetic and JSON stringification.\n  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;\n\n  _.prototype.toString = function() {\n    return '' + this._wrapped;\n  };\n\n  // AMD registration happens at the end for compatibility with AMD loaders\n  // that may not enforce next-turn semantics on modules. Even though general\n  // practice for AMD registration is to be anonymous, underscore registers\n  // as a named module because, like jQuery, it is a base library that is\n  // popular enough to be bundled in a third party lib, but not be part of\n  // an AMD load request. Those cases could generate an error when an\n  // anonymous define() is called outside of a loader request.\n  if (typeof define === 'function' && define.amd) {\n    define('underscore', [], function() {\n      return _;\n    });\n  }\n}.call(this));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/underscore/underscore.js\n// module id = 10\n// module chunks = 0","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n'use strict';\n\nvar emptyFunction = require('./emptyFunction');\n\n/**\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */\n\nvar warning = emptyFunction;\n\nif (process.env.NODE_ENV !== 'production') {\n  var printWarning = function printWarning(format) {\n    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    var argIndex = 0;\n    var message = 'Warning: ' + format.replace(/%s/g, function () {\n      return args[argIndex++];\n    });\n    if (typeof console !== 'undefined') {\n      console.error(message);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) {}\n  };\n\n  warning = function warning(condition, format) {\n    if (format === undefined) {\n      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');\n    }\n\n    if (format.indexOf('Failed Composite propType: ') === 0) {\n      return; // Ignore CompositeComponent proptype check.\n    }\n\n    if (!condition) {\n      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n        args[_key2 - 2] = arguments[_key2];\n      }\n\n      printWarning.apply(undefined, [format].concat(args));\n    }\n  };\n}\n\nmodule.exports = warning;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/fbjs/lib/warning.js\n// module id = 11\n// module chunks = 0","var Doc = require('./doc');\nvar Query = require('./query');\nvar emitter = require('../emitter');\nvar ShareDBError = require('../error');\nvar types = require('../types');\nvar util = require('../util');\n\n/**\n * Handles communication with the sharejs server and provides queries and\n * documents.\n *\n * We create a connection with a socket object\n *   connection = new sharejs.Connection(sockset)\n * The socket may be any object handling the websocket protocol. See the\n * documentation of bindToSocket() for details. We then wait for the connection\n * to connect\n *   connection.on('connected', ...)\n * and are finally able to work with shared documents\n *   connection.get('food', 'steak') // Doc\n *\n * @param socket @see bindToSocket\n */\nmodule.exports = Connection;\nfunction Connection(socket) {\n  emitter.EventEmitter.call(this);\n\n  // Map of collection -> id -> doc object for created documents.\n  // (created documents MUST BE UNIQUE)\n  this.collections = {};\n\n  // Each query is created with an id that the server uses when it sends us\n  // info about the query (updates, etc)\n  this.nextQueryId = 1;\n\n  // Map from query ID -> query object.\n  this.queries = {};\n\n  // A unique message number for the given id\n  this.seq = 1;\n\n  // Equals agent.clientId on the server\n  this.id = null;\n\n  // This direct reference from connection to agent is not used internal to\n  // ShareDB, but it is handy for server-side only user code that may cache\n  // state on the agent and read it in middleware\n  this.agent = null;\n\n  this.debug = false;\n\n  this.bindToSocket(socket);\n}\nemitter.mixin(Connection);\n\n\n/**\n * Use socket to communicate with server\n *\n * Socket is an object that can handle the websocket protocol. This method\n * installs the onopen, onclose, onmessage and onerror handlers on the socket to\n * handle communication and sends messages by calling socket.send(message). The\n * sockets `readyState` property is used to determine the initaial state.\n *\n * @param socket Handles the websocket protocol\n * @param socket.readyState\n * @param socket.close\n * @param socket.send\n * @param socket.onopen\n * @param socket.onclose\n * @param socket.onmessage\n * @param socket.onerror\n */\nConnection.prototype.bindToSocket = function(socket) {\n  if (this.socket) {\n    this.socket.close();\n    this.socket.onmessage = null;\n    this.socket.onopen = null;\n    this.socket.onerror = null;\n    this.socket.onclose = null;\n  }\n\n  this.socket = socket;\n\n  // State of the connection. The correspoding events are emmited when this changes\n  //\n  // - 'connecting'   The connection is still being established, or we are still\n  //                    waiting on the server to send us the initialization message\n  // - 'connected'    The connection is open and we have connected to a server\n  //                    and recieved the initialization message\n  // - 'disconnected' Connection is closed, but it will reconnect automatically\n  // - 'closed'       The connection was closed by the client, and will not reconnect\n  // - 'stopped'      The connection was closed by the server, and will not reconnect\n  this.state = (socket.readyState === 0 || socket.readyState === 1) ? 'connecting' : 'disconnected';\n\n  // This is a helper variable the document uses to see whether we're\n  // currently in a 'live' state. It is true if and only if we're connected\n  this.canSend = false;\n\n  var connection = this;\n\n  socket.onmessage = function(event) {\n    try {\n      var data = (typeof event.data === 'string') ?\n        JSON.parse(event.data) : event.data;\n    } catch (err) {\n      console.warn('Failed to parse message', event);\n      return;\n    }\n\n    if (connection.debug) console.log('RECV', JSON.stringify(data));\n\n    var request = {data: data};\n    connection.emit('receive', request);\n    if (!request.data) return;\n\n    try {\n      connection.handleMessage(request.data);\n    } catch (err) {\n      process.nextTick(function() {\n        connection.emit('error', err);\n      });\n    }\n  };\n\n  socket.onopen = function() {\n    connection._setState('connecting');\n  };\n\n  socket.onerror = function(err) {\n    // This isn't the same as a regular error, because it will happen normally\n    // from time to time. Your connection should probably automatically\n    // reconnect anyway, but that should be triggered off onclose not onerror.\n    // (onclose happens when onerror gets called anyway).\n    connection.emit('connection error', err);\n  };\n\n  socket.onclose = function(reason) {\n    // node-browserchannel reason values:\n    //   'Closed' - The socket was manually closed by calling socket.close()\n    //   'Stopped by server' - The server sent the stop message to tell the client not to try connecting\n    //   'Request failed' - Server didn't respond to request (temporary, usually offline)\n    //   'Unknown session ID' - Server session for client is missing (temporary, will immediately reestablish)\n\n    if (reason === 'closed' || reason === 'Closed') {\n      connection._setState('closed', reason);\n\n    } else if (reason === 'stopped' || reason === 'Stopped by server') {\n      connection._setState('stopped', reason);\n\n    } else {\n      connection._setState('disconnected', reason);\n    }\n  };\n};\n\n/**\n * @param {object} message\n * @param {String} message.a action\n */\nConnection.prototype.handleMessage = function(message) {\n  var err = null;\n  if (message.error) {\n    // wrap in Error object so can be passed through event emitters\n    err = new Error(message.error.message);\n    err.code = message.error.code;\n    // Add the message data to the error object for more context\n    err.data = message;\n    delete message.error;\n  }\n  // Switch on the message action. Most messages are for documents and are\n  // handled in the doc class.\n  switch (message.a) {\n    case 'init':\n      // Client initialization packet\n      if (message.protocol !== 1) {\n        err = new ShareDBError(4019, 'Invalid protocol version');\n        return this.emit('error', err);\n      }\n      if (types.map[message.type] !== types.defaultType) {\n        err = new ShareDBError(4020, 'Invalid default type');\n        return this.emit('error', err);\n      }\n      if (typeof message.id !== 'string') {\n        err = new ShareDBError(4021, 'Invalid client id');\n        return this.emit('error', err);\n      }\n      this.id = message.id;\n\n      this._setState('connected');\n      return;\n\n    case 'qf':\n      var query = this.queries[message.id];\n      if (query) query._handleFetch(err, message.data, message.extra);\n      return;\n    case 'qs':\n      var query = this.queries[message.id];\n      if (query) query._handleSubscribe(err, message.data, message.extra);\n      return;\n    case 'qu':\n      // Queries are removed immediately on calls to destroy, so we ignore\n      // replies to query unsubscribes. Perhaps there should be a callback for\n      // destroy, but this is currently unimplemented\n      return;\n    case 'q':\n      // Query message. Pass this to the appropriate query object.\n      var query = this.queries[message.id];\n      if (!query) return;\n      if (err) return query._handleError(err);\n      if (message.diff) query._handleDiff(message.diff);\n      if (message.hasOwnProperty('extra')) query._handleExtra(message.extra);\n      return;\n\n    case 'bf':\n      return this._handleBulkMessage(message, '_handleFetch');\n    case 'bs':\n      return this._handleBulkMessage(message, '_handleSubscribe');\n    case 'bu':\n      return this._handleBulkMessage(message, '_handleUnsubscribe');\n\n    case 'f':\n      var doc = this.getExisting(message.c, message.d);\n      if (doc) doc._handleFetch(err, message.data);\n      return;\n    case 's':\n      var doc = this.getExisting(message.c, message.d);\n      if (doc) doc._handleSubscribe(err, message.data);\n      return;\n    case 'u':\n      var doc = this.getExisting(message.c, message.d);\n      if (doc) doc._handleUnsubscribe(err);\n      return;\n    case 'op':\n      var doc = this.getExisting(message.c, message.d);\n      if (doc) doc._handleOp(err, message);\n      return;\n\n    default:\n      console.warn('Ignoring unrecognized message', message);\n  }\n};\n\nConnection.prototype._handleBulkMessage = function(message, method) {\n  if (message.data) {\n    for (var id in message.data) {\n      var doc = this.getExisting(message.c, id);\n      if (doc) doc[method](message.error, message.data[id]);\n    }\n  } else if (Array.isArray(message.b)) {\n    for (var i = 0; i < message.b.length; i++) {\n      var id = message.b[i];\n      var doc = this.getExisting(message.c, id);\n      if (doc) doc[method](message.error);\n    }\n  } else if (message.b) {\n    for (var id in message.b) {\n      var doc = this.getExisting(message.c, id);\n      if (doc) doc[method](message.error);\n    }\n  } else {\n    console.error('Invalid bulk message', message);\n  }\n};\n\nConnection.prototype._reset = function() {\n  this.seq = 1;\n  this.id = null;\n  this.agent = null;\n};\n\n// Set the connection's state. The connection is basically a state machine.\nConnection.prototype._setState = function(newState, reason) {\n  if (this.state === newState) return;\n\n  // I made a state diagram. The only invalid transitions are getting to\n  // 'connecting' from anywhere other than 'disconnected' and getting to\n  // 'connected' from anywhere other than 'connecting'.\n  if (\n    (newState === 'connecting' && this.state !== 'disconnected' && this.state !== 'stopped' && this.state !== 'closed') ||\n    (newState === 'connected' && this.state !== 'connecting')\n  ) {\n    var err = new ShareDBError(5007, 'Cannot transition directly from ' + this.state + ' to ' + newState);\n    return this.emit('error', err);\n  }\n\n  this.state = newState;\n  this.canSend = (newState === 'connected');\n\n  if (newState === 'disconnected' || newState === 'stopped' || newState === 'closed') this._reset();\n\n  // Group subscribes together to help server make more efficient calls\n  this.startBulk();\n  // Emit the event to all queries\n  for (var id in this.queries) {\n    var query = this.queries[id];\n    query._onConnectionStateChanged();\n  }\n  // Emit the event to all documents\n  for (var collection in this.collections) {\n    var docs = this.collections[collection];\n    for (var id in docs) {\n      docs[id]._onConnectionStateChanged();\n    }\n  }\n  this.endBulk();\n\n  this.emit(newState, reason);\n  this.emit('state', newState, reason);\n};\n\nConnection.prototype.startBulk = function() {\n  if (!this.bulk) this.bulk = {};\n};\n\nConnection.prototype.endBulk = function() {\n  if (this.bulk) {\n    for (var collection in this.bulk) {\n      var actions = this.bulk[collection];\n      this._sendBulk('f', collection, actions.f);\n      this._sendBulk('s', collection, actions.s);\n      this._sendBulk('u', collection, actions.u);\n    }\n  }\n  this.bulk = null;\n};\n\nConnection.prototype._sendBulk = function(action, collection, values) {\n  if (!values) return;\n  var ids = [];\n  var versions = {};\n  var versionsCount = 0;\n  var versionId;\n  for (var id in values) {\n    var value = values[id];\n    if (value == null) {\n      ids.push(id);\n    } else {\n      versions[id] = value;\n      versionId = id;\n      versionsCount++;\n    }\n  }\n  if (ids.length === 1) {\n    var id = ids[0];\n    this.send({a: action, c: collection, d: id});\n  } else if (ids.length) {\n    this.send({a: 'b' + action, c: collection, b: ids});\n  }\n  if (versionsCount === 1) {\n    var version = versions[versionId];\n    this.send({a: action, c: collection, d: versionId, v: version});\n  } else if (versionsCount) {\n    this.send({a: 'b' + action, c: collection, b: versions});\n  }\n};\n\nConnection.prototype._sendAction = function(action, doc, version) {\n  // Ensure the doc is registered so that it receives the reply message\n  this._addDoc(doc);\n  if (this.bulk) {\n    // Bulk subscribe\n    var actions = this.bulk[doc.collection] || (this.bulk[doc.collection] = {});\n    var versions = actions[action] || (actions[action] = {});\n    var isDuplicate = versions.hasOwnProperty(doc.id);\n    versions[doc.id] = version;\n    return isDuplicate;\n  } else {\n    // Send single doc subscribe message\n    var message = {a: action, c: doc.collection, d: doc.id, v: version};\n    this.send(message);\n  }\n};\n\nConnection.prototype.sendFetch = function(doc) {\n  return this._sendAction('f', doc, doc.version);\n};\n\nConnection.prototype.sendSubscribe = function(doc) {\n  return this._sendAction('s', doc, doc.version);\n};\n\nConnection.prototype.sendUnsubscribe = function(doc) {\n  return this._sendAction('u', doc);\n};\n\nConnection.prototype.sendOp = function(doc, op) {\n  // Ensure the doc is registered so that it receives the reply message\n  this._addDoc(doc);\n  var message = {\n    a: 'op',\n    c: doc.collection,\n    d: doc.id,\n    v: doc.version,\n    src: op.src,\n    seq: op.seq\n  };\n  if (op.op) message.op = op.op;\n  if (op.create) message.create = op.create;\n  if (op.del) message.del = op.del;\n  this.send(message);\n};\n\n\n/**\n * Sends a message down the socket\n */\nConnection.prototype.send = function(message) {\n  if (this.debug) console.log('SEND', JSON.stringify(message));\n\n  this.emit('send', message);\n  this.socket.send(JSON.stringify(message));\n};\n\n\n/**\n * Closes the socket and emits 'closed'\n */\nConnection.prototype.close = function() {\n  this.socket.close();\n};\n\nConnection.prototype.getExisting = function(collection, id) {\n  if (this.collections[collection]) return this.collections[collection][id];\n};\n\n\n/**\n * Get or create a document.\n *\n * @param collection\n * @param id\n * @return {Doc}\n */\nConnection.prototype.get = function(collection, id) {\n  var docs = this.collections[collection] ||\n    (this.collections[collection] = {});\n\n  var doc = docs[id];\n  if (!doc) {\n    doc = docs[id] = new Doc(this, collection, id);\n    this.emit('doc', doc);\n  }\n\n  return doc;\n};\n\n\n/**\n * Remove document from this.collections\n *\n * @private\n */\nConnection.prototype._destroyDoc = function(doc) {\n  var docs = this.collections[doc.collection];\n  if (!docs) return;\n\n  delete docs[doc.id];\n\n  // Delete the collection container if its empty. This could be a source of\n  // memory leaks if you slowly make a billion collections, which you probably\n  // won't do anyway, but whatever.\n  if (!util.hasKeys(docs)) {\n    delete this.collections[doc.collection];\n  }\n};\n\nConnection.prototype._addDoc = function(doc) {\n  var docs = this.collections[doc.collection];\n  if (!docs) {\n    docs = this.collections[doc.collection] = {};\n  }\n  if (docs[doc.id] !== doc) {\n    docs[doc.id] = doc;\n  }\n};\n\n// Helper for createFetchQuery and createSubscribeQuery, below.\nConnection.prototype._createQuery = function(action, collection, q, options, callback) {\n  var id = this.nextQueryId++;\n  var query = new Query(action, this, id, collection, q, options, callback);\n  this.queries[id] = query;\n  query.send();\n  return query;\n};\n\n// Internal function. Use query.destroy() to remove queries.\nConnection.prototype._destroyQuery = function(query) {\n  delete this.queries[query.id];\n};\n\n// The query options object can contain the following fields:\n//\n// db: Name of the db for the query. You can attach extraDbs to ShareDB and\n//   pick which one the query should hit using this parameter.\n\n// Create a fetch query. Fetch queries are only issued once, returning the\n// results directly into the callback.\n//\n// The callback should have the signature function(error, results, extra)\n// where results is a list of Doc objects.\nConnection.prototype.createFetchQuery = function(collection, q, options, callback) {\n  return this._createQuery('qf', collection, q, options, callback);\n};\n\n// Create a subscribe query. Subscribe queries return with the initial data\n// through the callback, then update themselves whenever the query result set\n// changes via their own event emitter.\n//\n// If present, the callback should have the signature function(error, results, extra)\n// where results is a list of Doc objects.\nConnection.prototype.createSubscribeQuery = function(collection, q, options, callback) {\n  return this._createQuery('qs', collection, q, options, callback);\n};\n\nConnection.prototype.hasPending = function() {\n  return !!(\n    this._firstDoc(hasPending) ||\n    this._firstQuery(hasPending)\n  );\n};\nfunction hasPending(object) {\n  return object.hasPending();\n}\n\nConnection.prototype.hasWritePending = function() {\n  return !!this._firstDoc(hasWritePending);\n};\nfunction hasWritePending(object) {\n  return object.hasWritePending();\n}\n\nConnection.prototype.whenNothingPending = function(callback) {\n  var doc = this._firstDoc(hasPending);\n  if (doc) {\n    // If a document is found with a pending operation, wait for it to emit\n    // that nothing is pending anymore, and then recheck all documents again.\n    // We have to recheck all documents, just in case another mutation has\n    // been made in the meantime as a result of an event callback\n    doc.once('nothing pending', this._nothingPendingRetry(callback));\n    return;\n  }\n  var query = this._firstQuery(hasPending);\n  if (query) {\n    query.once('ready', this._nothingPendingRetry(callback));\n    return;\n  }\n  // Call back when no pending operations\n  process.nextTick(callback);\n};\nConnection.prototype._nothingPendingRetry = function(callback) {\n  var connection = this;\n  return function() {\n    process.nextTick(function() {\n      connection.whenNothingPending(callback);\n    });\n  };\n};\n\nConnection.prototype._firstDoc = function(fn) {\n  for (var collection in this.collections) {\n    var docs = this.collections[collection];\n    for (var id in docs) {\n      var doc = docs[id];\n      if (fn(doc)) {\n        return doc;\n      }\n    }\n  }\n};\n\nConnection.prototype._firstQuery = function(fn) {\n  for (var id in this.queries) {\n    var query = this.queries[id];\n    if (fn(query)) {\n      return query;\n    }\n  }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/sharedb/lib/client/connection.js\n// module id = 12\n// module chunks = 0","var emitter = require('../emitter');\nvar ShareDBError = require('../error');\nvar types = require('../types');\n\n/**\n * A Doc is a client's view on a sharejs document.\n *\n * It is is uniquely identified by its `id` and `collection`.  Documents\n * should not be created directly. Create them with connection.get()\n *\n *\n * Subscriptions\n * -------------\n *\n * We can subscribe a document to stay in sync with the server.\n *   doc.subscribe(function(error) {\n *     doc.subscribed // = true\n *   })\n * The server now sends us all changes concerning this document and these are\n * applied to our data. If the subscription was successful the initial\n * data and version sent by the server are loaded into the document.\n *\n * To stop listening to the changes we call `doc.unsubscribe()`.\n *\n * If we just want to load the data but not stay up-to-date, we call\n *   doc.fetch(function(error) {\n *     doc.data // sent by server\n *   })\n *\n *\n * Events\n * ------\n *\n * You can use doc.on(eventName, callback) to subscribe to the following events:\n * - `before op (op, source)` Fired before a partial operation is applied to the data.\n *   It may be used to read the old data just before applying an operation\n * - `op (op, source)` Fired after every partial operation with this operation as the\n *   first argument\n * - `create (source)` The document was created. That means its type was\n *   set and it has some initial data.\n * - `del (data, source)` Fired after the document is deleted, that is\n *   the data is null. It is passed the data before delteion as an\n *   arguments\n * - `load ()` Fired when a new snapshot is ingested from a fetch, subscribe, or query\n */\n\nmodule.exports = Doc;\nfunction Doc(connection, collection, id) {\n  emitter.EventEmitter.call(this);\n\n  this.connection = connection;\n\n  this.collection = collection;\n  this.id = id;\n\n  this.version = null;\n  this.type = null;\n  this.data = undefined;\n\n  // Array of callbacks or nulls as placeholders\n  this.inflightFetch = [];\n  this.inflightSubscribe = [];\n  this.inflightUnsubscribe = [];\n  this.pendingFetch = [];\n\n  // Whether we think we are subscribed on the server. Synchronously set to\n  // false on calls to unsubscribe and disconnect. Should never be true when\n  // this.wantSubscribe is false\n  this.subscribed = false;\n  // Whether to re-establish the subscription on reconnect\n  this.wantSubscribe = false;\n\n  // The op that is currently roundtripping to the server, or null.\n  //\n  // When the connection reconnects, the inflight op is resubmitted.\n  //\n  // This has the same format as an entry in pendingOps\n  this.inflightOp = null;\n\n  // All ops that are waiting for the server to acknowledge this.inflightOp\n  // This used to just be a single operation, but creates & deletes can't be\n  // composed with regular operations.\n  //\n  // This is a list of {[create:{...}], [del:true], [op:...], callbacks:[...]}\n  this.pendingOps = [];\n\n  // The OT type of this document. An uncreated document has type `null`\n  this.type = null;\n\n  // The applyStack enables us to track any ops submitted while we are\n  // applying an op incrementally. This value is an array when we are\n  // performing an incremental apply and null otherwise. When it is an array,\n  // all submitted ops should be pushed onto it. The `_otApply` method will\n  // reset it back to null when all incremental apply loops are complete.\n  this.applyStack = null;\n\n  // Disable the default behavior of composing submitted ops. This is read at\n  // the time of op submit, so it may be toggled on before submitting a\n  // specifc op and toggled off afterward\n  this.preventCompose = false;\n}\nemitter.mixin(Doc);\n\nDoc.prototype.destroy = function(callback) {\n  var doc = this;\n  doc.whenNothingPending(function() {\n    doc.connection._destroyDoc(doc);\n    if (doc.wantSubscribe) {\n      return doc.unsubscribe(callback);\n    }\n    if (callback) callback();\n  });\n};\n\n\n// ****** Manipulating the document data, version and type.\n\n// Set the document's type, and associated properties. Most of the logic in\n// this function exists to update the document based on any added & removed API\n// methods.\n//\n// @param newType OT type provided by the ottypes library or its name or uri\nDoc.prototype._setType = function(newType) {\n  if (typeof newType === 'string') {\n    newType = types.map[newType];\n  }\n\n  if (newType) {\n    this.type = newType;\n\n  } else if (newType === null) {\n    this.type = newType;\n    // If we removed the type from the object, also remove its data\n    this.data = undefined;\n\n  } else {\n    var err = new ShareDBError(4008, 'Missing type ' + newType);\n    return this.emit('error', err);\n  }\n};\n\n// Ingest snapshot data. This data must include a version, snapshot and type.\n// This is used both to ingest data that was exported with a webpage and data\n// that was received from the server during a fetch.\n//\n// @param snapshot.v    version\n// @param snapshot.data\n// @param snapshot.type\n// @param callback\nDoc.prototype.ingestSnapshot = function(snapshot, callback) {\n  if (!snapshot) return callback && callback();\n\n  if (typeof snapshot.v !== 'number') {\n    var err = new ShareDBError(5008, 'Missing version in ingested snapshot. ' + this.collection + '.' + this.id);\n    if (callback) return callback(err);\n    return this.emit('error', err);\n  }\n\n  // If the doc is already created or there are ops pending, we cannot use the\n  // ingested snapshot and need ops in order to update the document\n  if (this.type || this.hasWritePending()) {\n    // The version should only be null on a created document when it was\n    // created locally without fetching\n    if (this.version == null) {\n      if (this.hasWritePending()) {\n        // If we have pending ops and we get a snapshot for a locally created\n        // document, we have to wait for the pending ops to complete, because\n        // we don't know what version to fetch ops from. It is possible that\n        // the snapshot came from our local op, but it is also possible that\n        // the doc was created remotely (which would conflict and be an error)\n        return callback && this.once('no write pending', callback);\n      }\n      // Otherwise, we've encounted an error state\n      var err = new ShareDBError(5009, 'Cannot ingest snapshot in doc with null version. ' + this.collection + '.' + this.id);\n      if (callback) return callback(err);\n      return this.emit('error', err);\n    }\n    // If we got a snapshot for a version further along than the document is\n    // currently, issue a fetch to get the latest ops and catch us up\n    if (snapshot.v > this.version) return this.fetch(callback);\n    return callback && callback();\n  }\n\n  // Ignore the snapshot if we are already at a newer version. Under no\n  // circumstance should we ever set the current version backward\n  if (this.version > snapshot.v) return callback && callback();\n\n  this.version = snapshot.v;\n  var type = (snapshot.type === undefined) ? types.defaultType : snapshot.type;\n  this._setType(type);\n  this.data = (this.type && this.type.deserialize) ?\n    this.type.deserialize(snapshot.data) :\n    snapshot.data;\n  this.emit('load');\n  callback && callback();\n};\n\nDoc.prototype.whenNothingPending = function(callback) {\n  if (this.hasPending()) {\n    this.once('nothing pending', callback);\n    return;\n  }\n  callback();\n};\n\nDoc.prototype.hasPending = function() {\n  return !!(\n    this.inflightOp ||\n    this.pendingOps.length ||\n    this.inflightFetch.length ||\n    this.inflightSubscribe.length ||\n    this.inflightUnsubscribe.length ||\n    this.pendingFetch.length\n  );\n};\n\nDoc.prototype.hasWritePending = function() {\n  return !!(this.inflightOp || this.pendingOps.length);\n};\n\nDoc.prototype._emitNothingPending = function() {\n  if (this.hasWritePending()) return;\n  this.emit('no write pending');\n  if (this.hasPending()) return;\n  this.emit('nothing pending');\n};\n\n// **** Helpers for network messages\n\nDoc.prototype._emitResponseError = function(err, callback) {\n  if (callback) {\n    callback(err);\n    this._emitNothingPending();\n    return;\n  }\n  this._emitNothingPending();\n  this.emit('error', err);\n};\n\nDoc.prototype._handleFetch = function(err, snapshot) {\n  var callback = this.inflightFetch.shift();\n  if (err) return this._emitResponseError(err, callback);\n  this.ingestSnapshot(snapshot, callback);\n  this._emitNothingPending();\n};\n\nDoc.prototype._handleSubscribe = function(err, snapshot) {\n  var callback = this.inflightSubscribe.shift();\n  if (err) return this._emitResponseError(err, callback);\n  // Indicate we are subscribed only if the client still wants to be. In the\n  // time since calling subscribe and receiving a response from the server,\n  // unsubscribe could have been called and we might already be unsubscribed\n  // but not have received the response. Also, because requests from the\n  // client are not serialized and may take different async time to process,\n  // it is possible that we could hear responses back in a different order\n  // from the order originally sent\n  if (this.wantSubscribe) this.subscribed = true;\n  this.ingestSnapshot(snapshot, callback);\n  this._emitNothingPending();\n};\n\nDoc.prototype._handleUnsubscribe = function(err) {\n  var callback = this.inflightUnsubscribe.shift();\n  if (err) return this._emitResponseError(err, callback);\n  if (callback) callback();\n  this._emitNothingPending();\n};\n\nDoc.prototype._handleOp = function(err, message) {\n  if (err) {\n    if (this.inflightOp) {\n      // The server has rejected submission of the current operation. If we get\n      // an error code 4002 \"Op submit rejected\", this was done intentionally\n      // and we should roll back but not return an error to the user.\n      if (err.code === 4002) err = null;\n      return this._rollback(err);\n    }\n    return this.emit('error', err);\n  }\n\n  if (this.inflightOp &&\n      message.src === this.inflightOp.src &&\n      message.seq === this.inflightOp.seq) {\n    // The op has already been applied locally. Just update the version\n    // and pending state appropriately\n    this._opAcknowledged(message);\n    return;\n  }\n\n  if (this.version == null || message.v > this.version) {\n    // This will happen in normal operation if we become subscribed to a\n    // new document via a query. It can also happen if we get an op for\n    // a future version beyond the version we are expecting next. This\n    // could happen if the server doesn't publish an op for whatever reason\n    // or because of a race condition. In any case, we can send a fetch\n    // command to catch back up.\n    //\n    // Fetch only sends a new fetch command if no fetches are inflight, which\n    // will act as a natural debouncing so we don't send multiple fetch\n    // requests for many ops received at once.\n    this.fetch();\n    return;\n  }\n\n  if (message.v < this.version) {\n    // We can safely ignore the old (duplicate) operation.\n    return;\n  }\n\n  if (this.inflightOp) {\n    var transformErr = transformX(this.inflightOp, message);\n    if (transformErr) return this._hardRollback(transformErr);\n  }\n\n  for (var i = 0; i < this.pendingOps.length; i++) {\n    var transformErr = transformX(this.pendingOps[i], message);\n    if (transformErr) return this._hardRollback(transformErr);\n  }\n\n  this.version++;\n  this._otApply(message, false);\n  return;\n};\n\n// Called whenever (you guessed it!) the connection state changes. This will\n// happen when we get disconnected & reconnect.\nDoc.prototype._onConnectionStateChanged = function() {\n  if (this.connection.canSend) {\n    this.flush();\n    this._resubscribe();\n  } else {\n    if (this.inflightOp) {\n      this.pendingOps.unshift(this.inflightOp);\n      this.inflightOp = null;\n    }\n    this.subscribed = false;\n    if (this.inflightFetch.length || this.inflightSubscribe.length) {\n      this.pendingFetch = this.pendingFetch.concat(this.inflightFetch, this.inflightSubscribe);\n      this.inflightFetch.length = 0;\n      this.inflightSubscribe.length = 0;\n    }\n    if (this.inflightUnsubscribe.length) {\n      var callbacks = this.inflightUnsubscribe;\n      this.inflightUnsubscribe = [];\n      callEach(callbacks);\n    }\n  }\n};\n\nDoc.prototype._resubscribe = function() {\n  var callbacks = this.pendingFetch;\n  this.pendingFetch = [];\n\n  if (this.wantSubscribe) {\n    if (callbacks.length) {\n      this.subscribe(function(err) {\n        callEach(callbacks, err);\n      });\n      return;\n    }\n    this.subscribe();\n    return;\n  }\n\n  if (callbacks.length) {\n    this.fetch(function(err) {\n      callEach(callbacks, err);\n    });\n  }\n};\n\n// Request the current document snapshot or ops that bring us up to date\nDoc.prototype.fetch = function(callback) {\n  if (this.connection.canSend) {\n    var isDuplicate = this.connection.sendFetch(this);\n    pushActionCallback(this.inflightFetch, isDuplicate, callback);\n    return;\n  }\n  this.pendingFetch.push(callback);\n};\n\n// Fetch the initial document and keep receiving updates\nDoc.prototype.subscribe = function(callback) {\n  this.wantSubscribe = true;\n  if (this.connection.canSend) {\n    var isDuplicate = this.connection.sendSubscribe(this);\n    pushActionCallback(this.inflightSubscribe, isDuplicate, callback);\n    return;\n  }\n  this.pendingFetch.push(callback);\n};\n\n// Unsubscribe. The data will stay around in local memory, but we'll stop\n// receiving updates\nDoc.prototype.unsubscribe = function(callback) {\n  this.wantSubscribe = false;\n  // The subscribed state should be conservative in indicating when we are\n  // subscribed on the server. We'll actually be unsubscribed some time\n  // between sending the message and hearing back, but we cannot know exactly\n  // when. Thus, immediately mark us as not subscribed\n  this.subscribed = false;\n  if (this.connection.canSend) {\n    var isDuplicate = this.connection.sendUnsubscribe(this);\n    pushActionCallback(this.inflightUnsubscribe, isDuplicate, callback);\n    return;\n  }\n  if (callback) process.nextTick(callback);\n};\n\nfunction pushActionCallback(inflight, isDuplicate, callback) {\n  if (isDuplicate) {\n    var lastCallback = inflight.pop();\n    inflight.push(function(err) {\n      lastCallback && lastCallback(err);\n      callback && callback(err);\n    });\n  } else {\n    inflight.push(callback);\n  }\n}\n\n\n// Operations //\n\n// Send the next pending op to the server, if we can.\n//\n// Only one operation can be in-flight at a time. If an operation is already on\n// its way, or we're not currently connected, this method does nothing.\nDoc.prototype.flush = function() {\n  // Ignore if we can't send or we are already sending an op\n  if (!this.connection.canSend || this.inflightOp) return;\n\n  // Send first pending op unless paused\n  if (!this.paused && this.pendingOps.length) {\n    this._sendOp();\n  }\n};\n\n// Helper function to set op to contain a no-op.\nfunction setNoOp(op) {\n  delete op.op;\n  delete op.create;\n  delete op.del;\n}\n\n// Transform server op data by a client op, and vice versa. Ops are edited in place.\nfunction transformX(client, server) {\n  // Order of statements in this function matters. Be especially careful if\n  // refactoring this function\n\n  // A client delete op should dominate if both the server and the client\n  // delete the document. Thus, any ops following the client delete (such as a\n  // subsequent create) will be maintained, since the server op is transformed\n  // to a no-op\n  if (client.del) return setNoOp(server);\n\n  if (server.del) {\n    return new ShareDBError(4017, 'Document was deleted');\n  }\n  if (server.create) {\n    return new ShareDBError(4018, 'Document alredy created');\n  }\n\n  // Ignore no-op coming from server\n  if (!server.op) return;\n\n  // I believe that this should not occur, but check just in case\n  if (client.create) {\n    return new ShareDBError(4018, 'Document already created');\n  }\n\n  // They both edited the document. This is the normal case for this function -\n  // as in, most of the time we'll end up down here.\n  //\n  // You should be wondering why I'm using client.type instead of this.type.\n  // The reason is, if we get ops at an old version of the document, this.type\n  // might be undefined or a totally different type. By pinning the type to the\n  // op data, we make sure the right type has its transform function called.\n  if (client.type.transformX) {\n    var result = client.type.transformX(client.op, server.op);\n    client.op = result[0];\n    server.op = result[1];\n  } else {\n    var clientOp = client.type.transform(client.op, server.op, 'left');\n    var serverOp = client.type.transform(server.op, client.op, 'right');\n    client.op = clientOp;\n    server.op = serverOp;\n  }\n};\n\n/**\n * Applies the operation to the snapshot\n *\n * If the operation is create or delete it emits `create` or `del`. Then the\n * operation is applied to the snapshot and `op` and `after op` are emitted.\n * If the type supports incremental updates and `this.incremental` is true we\n * fire `op` after every small operation.\n *\n * This is the only function to fire the above mentioned events.\n *\n * @private\n */\nDoc.prototype._otApply = function(op, source) {\n  if (op.op) {\n    if (!this.type) {\n      var err = new ShareDBError(4015, 'Cannot apply op to uncreated document. ' + this.collection + '.' + this.id);\n      return this.emit('error', err);\n    }\n\n    // Iteratively apply multi-component remote operations and rollback ops\n    // (source === false) for the default JSON0 OT type. It could use\n    // type.shatter(), but since this code is so specific to use cases for the\n    // JSON0 type and ShareDB explicitly bundles the default type, we might as\n    // well write it this way and save needing to iterate through the op\n    // components twice.\n    //\n    // Ideally, we would not need this extra complexity. However, it is\n    // helpful for implementing bindings that update DOM nodes and other\n    // stateful objects by translating op events directly into corresponding\n    // mutations. Such bindings are most easily written as responding to\n    // individual op components one at a time in order, and it is important\n    // that the snapshot only include updates from the particular op component\n    // at the time of emission. Eliminating this would require rethinking how\n    // such external bindings are implemented.\n    if (!source && this.type === types.defaultType && op.op.length > 1) {\n      if (!this.applyStack) this.applyStack = [];\n      var stackLength = this.applyStack.length;\n      for (var i = 0; i < op.op.length; i++) {\n        var component = op.op[i];\n        var componentOp = {op: [component]};\n        // Transform componentOp against any ops that have been submitted\n        // sychronously inside of an op event handler since we began apply of\n        // our operation\n        for (var j = stackLength; j < this.applyStack.length; j++) {\n          var transformErr = transformX(this.applyStack[j], componentOp);\n          if (transformErr) return this._hardRollback(transformErr);\n        }\n        // Apply the individual op component\n        this.emit('before op', componentOp.op, source);\n        this.data = this.type.apply(this.data, componentOp.op);\n        this.emit('op', componentOp.op, source);\n      }\n      // Pop whatever was submitted since we started applying this op\n      this._popApplyStack(stackLength);\n      return;\n    }\n\n    // The 'before op' event enables clients to pull any necessary data out of\n    // the snapshot before it gets changed\n    this.emit('before op', op.op, source);\n    // Apply the operation to the local data, mutating it in place\n    this.data = this.type.apply(this.data, op.op);\n    // Emit an 'op' event once the local data includes the changes from the\n    // op. For locally submitted ops, this will be synchronously with\n    // submission and before the server or other clients have received the op.\n    // For ops from other clients, this will be after the op has been\n    // committed to the database and published\n    this.emit('op', op.op, source);\n    return;\n  }\n\n  if (op.create) {\n    this._setType(op.create.type);\n    this.data = (this.type.deserialize) ?\n      (this.type.createDeserialized) ?\n        this.type.createDeserialized(op.create.data) :\n        this.type.deserialize(this.type.create(op.create.data)) :\n      this.type.create(op.create.data);\n    this.emit('create', source);\n    return;\n  }\n\n  if (op.del) {\n    var oldData = this.data;\n    this._setType(null);\n    this.emit('del', oldData, source);\n    return;\n  }\n};\n\n\n// ***** Sending operations\n\n// Actually send op to the server.\nDoc.prototype._sendOp = function() {\n  // Wait until we have a src id from the server\n  var src = this.connection.id;\n  if (!src) return;\n\n  // When there is no inflightOp, send the first item in pendingOps. If\n  // there is inflightOp, try sending it again\n  if (!this.inflightOp) {\n    // Send first pending op\n    this.inflightOp = this.pendingOps.shift();\n  }\n  var op = this.inflightOp;\n  if (!op) {\n    var err = new ShareDBError(5010, 'No op to send on call to _sendOp');\n    return this.emit('error', err);\n  }\n\n  // Track data for retrying ops\n  op.sentAt = Date.now();\n  op.retries = (op.retries == null) ? 0 : op.retries + 1;\n\n  // The src + seq number is a unique ID representing this operation. This tuple\n  // is used on the server to detect when ops have been sent multiple times and\n  // on the client to match acknowledgement of an op back to the inflightOp.\n  // Note that the src could be different from this.connection.id after a\n  // reconnect, since an op may still be pending after the reconnection and\n  // this.connection.id will change. In case an op is sent multiple times, we\n  // also need to be careful not to override the original seq value.\n  if (op.seq == null) op.seq = this.connection.seq++;\n\n  this.connection.sendOp(this, op);\n\n  // src isn't needed on the first try, since the server session will have the\n  // same id, but it must be set on the inflightOp in case it is sent again\n  // after a reconnect and the connection's id has changed by then\n  if (op.src == null) op.src = src;\n};\n\n\n// Queues the operation for submission to the server and applies it locally.\n//\n// Internal method called to do the actual work for submit(), create() and del().\n// @private\n//\n// @param op\n// @param [op.op]\n// @param [op.del]\n// @param [op.create]\n// @param [callback] called when operation is submitted\nDoc.prototype._submit = function(op, source, callback) {\n  // Locally submitted ops must always have a truthy source\n  if (!source) source = true;\n\n  // The op contains either op, create, delete, or none of the above (a no-op).\n  if (op.op) {\n    if (!this.type) {\n      var err = new ShareDBError(4015, 'Cannot submit op. Document has not been created. ' + this.collection + '.' + this.id);\n      if (callback) return callback(err);\n      return this.emit('error', err);\n    }\n    // Try to normalize the op. This removes trailing skip:0's and things like that.\n    if (this.type.normalize) op.op = this.type.normalize(op.op);\n  }\n\n  this._pushOp(op, callback);\n  this._otApply(op, source);\n\n  // The call to flush is delayed so if submit() is called multiple times\n  // synchronously, all the ops are combined before being sent to the server.\n  var doc = this;\n  process.nextTick(function() {\n    doc.flush();\n  });\n};\n\nDoc.prototype._pushOp = function(op, callback) {\n  if (this.applyStack) {\n    // If we are in the process of incrementally applying an operation, don't\n    // compose the op and push it onto the applyStack so it can be transformed\n    // against other components from the op or ops being applied\n    this.applyStack.push(op);\n  } else {\n    // If the type supports composes, try to compose the operation onto the\n    // end of the last pending operation.\n    var composed = this._tryCompose(op);\n    if (composed) {\n      composed.callbacks.push(callback);\n      return;\n    }\n  }\n  // Push on to the pendingOps queue of ops to submit if we didn't compose\n  op.type = this.type;\n  op.callbacks = [callback];\n  this.pendingOps.push(op);\n};\n\nDoc.prototype._popApplyStack = function(to) {\n  if (to > 0) {\n    this.applyStack.length = to;\n    return;\n  }\n  // Once we have completed the outermost apply loop, reset to null and no\n  // longer add ops to the applyStack as they are submitted\n  var op = this.applyStack[0];\n  this.applyStack = null;\n  if (!op) return;\n  // Compose the ops added since the beginning of the apply stack, since we\n  // had to skip compose when they were originally pushed\n  var i = this.pendingOps.indexOf(op);\n  if (i === -1) return;\n  var ops = this.pendingOps.splice(i);\n  for (var i = 0; i < ops.length; i++) {\n    var op = ops[i];\n    var composed = this._tryCompose(op);\n    if (composed) {\n      composed.callbacks = composed.callbacks.concat(op.callbacks);\n    } else {\n      this.pendingOps.push(op);\n    }\n  }\n};\n\n// Try to compose a submitted op into the last pending op. Returns the\n// composed op if it succeeds, undefined otherwise\nDoc.prototype._tryCompose = function(op) {\n  if (this.preventCompose) return;\n\n  // We can only compose into the last pending op. Inflight ops have already\n  // been sent to the server, so we can't modify them\n  var last = this.pendingOps[this.pendingOps.length - 1];\n  if (!last) return;\n\n  // Compose an op into a create by applying it. This effectively makes the op\n  // invisible, as if the document were created including the op originally\n  if (last.create && op.op) {\n    last.create.data = this.type.apply(last.create.data, op.op);\n    return last;\n  }\n\n  // Compose two ops into a single op if supported by the type. Types that\n  // support compose must be able to compose any two ops together\n  if (last.op && op.op && this.type.compose) {\n    last.op = this.type.compose(last.op, op.op);\n    return last;\n  }\n};\n\n// *** Client OT entrypoints.\n\n// Submit an operation to the document.\n//\n// @param operation handled by the OT type\n// @param options  {source: ...}\n// @param [callback] called after operation submitted\n//\n// @fires before op, op, after op\nDoc.prototype.submitOp = function(component, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = null;\n  }\n  var op = {op: component};\n  var source = options && options.source;\n  this._submit(op, source, callback);\n};\n\n// Create the document, which in ShareJS semantics means to set its type. Every\n// object implicitly exists in the database but has no data and no type. Create\n// sets the type of the object and can optionally set some initial data on the\n// object, depending on the type.\n//\n// @param data  initial\n// @param type  OT type\n// @param options  {source: ...}\n// @param callback  called when operation submitted\nDoc.prototype.create = function(data, type, options, callback) {\n  if (typeof type === 'function') {\n    callback = type;\n    options = null;\n    type = null;\n  } else if (typeof options === 'function') {\n    callback = options;\n    options = null;\n  }\n  if (!type) {\n    type = types.defaultType.uri;\n  }\n  if (this.type) {\n    var err = new ShareDBError(4016, 'Document already exists');\n    if (callback) return callback(err);\n    return this.emit('error', err);\n  }\n  var op = {create: {type: type, data: data}};\n  var source = options && options.source;\n  this._submit(op, source, callback);\n};\n\n// Delete the document. This creates and submits a delete operation to the\n// server. Deleting resets the object's type to null and deletes its data. The\n// document still exists, and still has the version it used to have before you\n// deleted it (well, old version +1).\n//\n// @param options  {source: ...}\n// @param callback  called when operation submitted\nDoc.prototype.del = function(options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = null;\n  }\n  if (!this.type) {\n    var err = new ShareDBError(4015, 'Document does not exist');\n    if (callback) return callback(err);\n    return this.emit('error', err);\n  }\n  var op = {del: true};\n  var source = options && options.source;\n  this._submit(op, source, callback);\n};\n\n\n// Stops the document from sending any operations to the server.\nDoc.prototype.pause = function() {\n  this.paused = true;\n};\n\n// Continue sending operations to the server\nDoc.prototype.resume = function() {\n  this.paused = false;\n  this.flush();\n};\n\n\n// *** Receiving operations\n\n// This is called when the server acknowledges an operation from the client.\nDoc.prototype._opAcknowledged = function(message) {\n  if (this.inflightOp.create) {\n    this.version = message.v;\n\n  } else if (message.v !== this.version) {\n    // We should already be at the same version, because the server should\n    // have sent all the ops that have happened before acknowledging our op\n    console.warn('Invalid version from server. Expected: ' + this.version + ' Received: ' + message.v, message);\n\n    // Fetching should get us back to a working document state\n    return this.fetch();\n  }\n\n  // The op was committed successfully. Increment the version number\n  this.version++;\n\n  this._clearInflightOp();\n};\n\nDoc.prototype._rollback = function(err) {\n  // The server has rejected submission of the current operation. Invert by\n  // just the inflight op if possible. If not possible to invert, cancel all\n  // pending ops and fetch the latest from the server to get us back into a\n  // working state, then call back\n  var op = this.inflightOp;\n\n  if (op.op && op.type.invert) {\n    op.op = op.type.invert(op.op);\n\n    // Transform the undo operation by any pending ops.\n    for (var i = 0; i < this.pendingOps.length; i++) {\n      var transformErr = transformX(this.pendingOps[i], op);\n      if (transformErr) return this._hardRollback(transformErr);\n    }\n\n    // ... and apply it locally, reverting the changes.\n    //\n    // This operation is applied to look like it comes from a remote source.\n    // I'm still not 100% sure about this functionality, because its really a\n    // local op. Basically, the problem is that if the client's op is rejected\n    // by the server, the editor window should update to reflect the undo.\n    this._otApply(op, false);\n\n    this._clearInflightOp(err);\n    return;\n  }\n\n  this._hardRollback(err);\n};\n\nDoc.prototype._hardRollback = function(err) {\n  // Cancel all pending ops and reset if we can't invert\n  var op = this.inflightOp;\n  var pending = this.pendingOps;\n  this._setType(null);\n  this.version = null;\n  this.inflightOp = null;\n  this.pendingOps = [];\n\n  // Fetch the latest from the server to get us back into a working state\n  var doc = this;\n  this.fetch(function() {\n    var called = op && callEach(op.callbacks, err);\n    for (var i = 0; i < pending.length; i++) {\n      callEach(pending[i].callbacks, err);\n    }\n    if (err && !called) return doc.emit('error', err);\n  });\n};\n\nDoc.prototype._clearInflightOp = function(err) {\n  var called = callEach(this.inflightOp.callbacks, err);\n\n  this.inflightOp = null;\n  this.flush();\n  this._emitNothingPending();\n\n  if (err && !called) return this.emit('error', err);\n};\n\nfunction callEach(callbacks, err) {\n  var called = false;\n  for (var i = 0; i < callbacks.length; i++) {\n    var callback = callbacks[i];\n    if (callback) {\n      callback(err);\n      called = true;\n    }\n  }\n  return called;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/sharedb/lib/client/doc.js\n// module id = 13\n// module chunks = 0","// Only the JSON type is exported, because the text type is deprecated\n// otherwise. (If you want to use it somewhere, you're welcome to pull it out\n// into a separate module that json0 can depend on).\n\nmodule.exports = {\n  type: require('./json0')\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ot-json0/lib/index.js\n// module id = 14\n// module chunks = 0","// These methods let you build a transform function from a transformComponent\n// function for OT types like JSON0 in which operations are lists of components\n// and transforming them requires N^2 work. I find it kind of nasty that I need\n// this, but I'm not really sure what a better solution is. Maybe I should do\n// this automatically to types that don't have a compose function defined.\n\n// Add transform and transformX functions for an OT type which has\n// transformComponent defined.  transformComponent(destination array,\n// component, other component, side)\nmodule.exports = bootstrapTransform\nfunction bootstrapTransform(type, transformComponent, checkValidOp, append) {\n  var transformComponentX = function(left, right, destLeft, destRight) {\n    transformComponent(destLeft, left, right, 'left');\n    transformComponent(destRight, right, left, 'right');\n  };\n\n  var transformX = type.transformX = function(leftOp, rightOp) {\n    checkValidOp(leftOp);\n    checkValidOp(rightOp);\n    var newRightOp = [];\n\n    for (var i = 0; i < rightOp.length; i++) {\n      var rightComponent = rightOp[i];\n\n      // Generate newLeftOp by composing leftOp by rightComponent\n      var newLeftOp = [];\n      var k = 0;\n      while (k < leftOp.length) {\n        var nextC = [];\n        transformComponentX(leftOp[k], rightComponent, newLeftOp, nextC);\n        k++;\n\n        if (nextC.length === 1) {\n          rightComponent = nextC[0];\n        } else if (nextC.length === 0) {\n          for (var j = k; j < leftOp.length; j++) {\n            append(newLeftOp, leftOp[j]);\n          }\n          rightComponent = null;\n          break;\n        } else {\n          // Recurse.\n          var pair = transformX(leftOp.slice(k), nextC);\n          for (var l = 0; l < pair[0].length; l++) {\n            append(newLeftOp, pair[0][l]);\n          }\n          for (var r = 0; r < pair[1].length; r++) {\n            append(newRightOp, pair[1][r]);\n          }\n          rightComponent = null;\n          break;\n        }\n      }\n\n      if (rightComponent != null) {\n        append(newRightOp, rightComponent);\n      }\n      leftOp = newLeftOp;\n    }\n    return [leftOp, newRightOp];\n  };\n\n  // Transforms op with specified type ('left' or 'right') by otherOp.\n  type.transform = function(op, otherOp, type) {\n    if (!(type === 'left' || type === 'right'))\n      throw new Error(\"type must be 'left' or 'right'\");\n\n    if (otherOp.length === 0) return op;\n\n    if (op.length === 1 && otherOp.length === 1)\n      return transformComponent([], op[0], otherOp[0], type);\n\n    if (type === 'left')\n      return transformX(op, otherOp)[0];\n    else\n      return transformX(otherOp, op)[1];\n  };\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ot-json0/lib/bootstrapTransform.js\n// module id = 15\n// module chunks = 0","var emitter = require('../emitter');\n\n// Queries are live requests to the database for particular sets of fields.\n//\n// The server actively tells the client when there's new data that matches\n// a set of conditions.\nmodule.exports = Query;\nfunction Query(action, connection, id, collection, query, options, callback) {\n  emitter.EventEmitter.call(this);\n\n  // 'qf' or 'qs'\n  this.action = action;\n\n  this.connection = connection;\n  this.id = id;\n  this.collection = collection;\n\n  // The query itself. For mongo, this should look something like {\"data.x\":5}\n  this.query = query;\n\n  // A list of resulting documents. These are actual documents, complete with\n  // data and all the rest. It is possible to pass in an initial results set,\n  // so that a query can be serialized and then re-established\n  this.results = null;\n  if (options && options.results) {\n    this.results = options.results;\n    delete options.results;\n  }\n  this.extra = undefined;\n\n  // Options to pass through with the query\n  this.options = options;\n\n  this.callback = callback;\n  this.ready = false;\n  this.sent = false;\n}\nemitter.mixin(Query);\n\nQuery.prototype.hasPending = function() {\n  return !this.ready;\n};\n\n// Helper for subscribe & fetch, since they share the same message format.\n//\n// This function actually issues the query.\nQuery.prototype.send = function() {\n  if (!this.connection.canSend) return;\n\n  var message = {\n    a: this.action,\n    id: this.id,\n    c: this.collection,\n    q: this.query\n  };\n  if (this.options) {\n    message.o = this.options;\n  }\n  if (this.results) {\n    // Collect the version of all the documents in the current result set so we\n    // don't need to be sent their snapshots again.\n    var results = [];\n    for (var i = 0; i < this.results.length; i++) {\n      var doc = this.results[i];\n      results.push([doc.id, doc.version]);\n    }\n    message.r = results;\n  }\n\n  this.connection.send(message);\n  this.sent = true;\n};\n\n// Destroy the query object. Any subsequent messages for the query will be\n// ignored by the connection.\nQuery.prototype.destroy = function(callback) {\n  if (this.connection.canSend && this.action === 'qs') {\n    this.connection.send({a: 'qu', id: this.id});\n  }\n  this.connection._destroyQuery(this);\n  // There is a callback for consistency, but we don't actually wait for the\n  // server's unsubscribe message currently\n  if (callback) process.nextTick(callback);\n};\n\nQuery.prototype._onConnectionStateChanged = function() {\n  if (this.connection.canSend && !this.sent) {\n    this.send();\n  } else {\n    this.sent = false;\n  }\n};\n\nQuery.prototype._handleFetch = function(err, data, extra) {\n  // Once a fetch query gets its data, it is destroyed.\n  this.connection._destroyQuery(this);\n  this._handleResponse(err, data, extra);\n};\n\nQuery.prototype._handleSubscribe = function(err, data, extra) {\n  this._handleResponse(err, data, extra);\n};\n\nQuery.prototype._handleResponse = function(err, data, extra) {\n  var callback = this.callback;\n  this.callback = null;\n  if (err) return this._finishResponse(err, callback);\n  if (!data) return this._finishResponse(null, callback);\n\n  var query = this;\n  var wait = 1;\n  var finish = function(err) {\n    if (err) return query._finishResponse(err, callback);\n    if (--wait) return;\n    query._finishResponse(null, callback);\n  };\n\n  if (Array.isArray(data)) {\n    wait += data.length;\n    this.results = this._ingestSnapshots(data, finish);\n    this.extra = extra;\n\n  } else {\n    for (var id in data) {\n      wait++;\n      var snapshot = data[id];\n      var doc = this.connection.get(snapshot.c || this.collection, id);\n      doc.ingestSnapshot(snapshot, finish);\n    }\n  }\n\n  finish();\n};\n\nQuery.prototype._ingestSnapshots = function(snapshots, finish) {\n  var results = [];\n  for (var i = 0; i < snapshots.length; i++) {\n    var snapshot = snapshots[i];\n    var doc = this.connection.get(snapshot.c || this.collection, snapshot.d);\n    doc.ingestSnapshot(snapshot, finish);\n    results.push(doc);\n  }\n  return results;\n};\n\nQuery.prototype._finishResponse = function(err, callback) {\n  this.emit('ready');\n  this.ready = true;\n  if (err) {\n    this.connection._destroyQuery(this);\n    if (callback) return callback(err);\n    return this.emit('error', err);\n  }\n  if (callback) callback(null, this.results, this.extra);\n};\n\nQuery.prototype._handleError = function(err) {\n  this.emit('error', err);\n};\n\nQuery.prototype._handleDiff = function(diff) {\n  // We need to go through the list twice. First, we'll ingest all the new\n  // documents. After that we'll emit events and actually update our list.\n  // This avoids race conditions around setting documents to be subscribed &\n  // unsubscribing documents in event callbacks.\n  for (var i = 0; i < diff.length; i++) {\n    var d = diff[i];\n    if (d.type === 'insert') d.values = this._ingestSnapshots(d.values);\n  }\n\n  for (var i = 0; i < diff.length; i++) {\n    var d = diff[i];\n    switch (d.type) {\n      case 'insert':\n        var newDocs = d.values;\n        Array.prototype.splice.apply(this.results, [d.index, 0].concat(newDocs));\n        this.emit('insert', newDocs, d.index);\n        break;\n      case 'remove':\n        var howMany = d.howMany || 1;\n        var removed = this.results.splice(d.index, howMany);\n        this.emit('remove', removed, d.index);\n        break;\n      case 'move':\n        var howMany = d.howMany || 1;\n        var docs = this.results.splice(d.from, howMany);\n        Array.prototype.splice.apply(this.results, [d.to, 0].concat(docs));\n        this.emit('move', docs, d.from, d.to);\n        break;\n    }\n  }\n\n  this.emit('changed', this.results);\n};\n\nQuery.prototype._handleExtra = function(extra) {\n  this.extra = extra;\n  this.emit('extra', extra);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/sharedb/lib/client/query.js\n// module id = 16\n// module chunks = 0","/*!\n * async\n * https://github.com/caolan/async\n *\n * Copyright 2010-2014 Caolan McMahon\n * Released under the MIT license\n */\n(function () {\n\n    var async = {};\n    function noop() {}\n    function identity(v) {\n        return v;\n    }\n    function toBool(v) {\n        return !!v;\n    }\n    function notId(v) {\n        return !v;\n    }\n\n    // global on the server, window in the browser\n    var previous_async;\n\n    // Establish the root object, `window` (`self`) in the browser, `global`\n    // on the server, or `this` in some virtual machines. We use `self`\n    // instead of `window` for `WebWorker` support.\n    var root = typeof self === 'object' && self.self === self && self ||\n            typeof global === 'object' && global.global === global && global ||\n            this;\n\n    if (root != null) {\n        previous_async = root.async;\n    }\n\n    async.noConflict = function () {\n        root.async = previous_async;\n        return async;\n    };\n\n    function only_once(fn) {\n        return function() {\n            if (fn === null) throw new Error(\"Callback was already called.\");\n            fn.apply(this, arguments);\n            fn = null;\n        };\n    }\n\n    function _once(fn) {\n        return function() {\n            if (fn === null) return;\n            fn.apply(this, arguments);\n            fn = null;\n        };\n    }\n\n    //// cross-browser compatiblity functions ////\n\n    var _toString = Object.prototype.toString;\n\n    var _isArray = Array.isArray || function (obj) {\n        return _toString.call(obj) === '[object Array]';\n    };\n\n    // Ported from underscore.js isObject\n    var _isObject = function(obj) {\n        var type = typeof obj;\n        return type === 'function' || type === 'object' && !!obj;\n    };\n\n    function _isArrayLike(arr) {\n        return _isArray(arr) || (\n            // has a positive integer length property\n            typeof arr.length === \"number\" &&\n            arr.length >= 0 &&\n            arr.length % 1 === 0\n        );\n    }\n\n    function _arrayEach(arr, iterator) {\n        var index = -1,\n            length = arr.length;\n\n        while (++index < length) {\n            iterator(arr[index], index, arr);\n        }\n    }\n\n    function _map(arr, iterator) {\n        var index = -1,\n            length = arr.length,\n            result = Array(length);\n\n        while (++index < length) {\n            result[index] = iterator(arr[index], index, arr);\n        }\n        return result;\n    }\n\n    function _range(count) {\n        return _map(Array(count), function (v, i) { return i; });\n    }\n\n    function _reduce(arr, iterator, memo) {\n        _arrayEach(arr, function (x, i, a) {\n            memo = iterator(memo, x, i, a);\n        });\n        return memo;\n    }\n\n    function _forEachOf(object, iterator) {\n        _arrayEach(_keys(object), function (key) {\n            iterator(object[key], key);\n        });\n    }\n\n    function _indexOf(arr, item) {\n        for (var i = 0; i < arr.length; i++) {\n            if (arr[i] === item) return i;\n        }\n        return -1;\n    }\n\n    var _keys = Object.keys || function (obj) {\n        var keys = [];\n        for (var k in obj) {\n            if (obj.hasOwnProperty(k)) {\n                keys.push(k);\n            }\n        }\n        return keys;\n    };\n\n    function _keyIterator(coll) {\n        var i = -1;\n        var len;\n        var keys;\n        if (_isArrayLike(coll)) {\n            len = coll.length;\n            return function next() {\n                i++;\n                return i < len ? i : null;\n            };\n        } else {\n            keys = _keys(coll);\n            len = keys.length;\n            return function next() {\n                i++;\n                return i < len ? keys[i] : null;\n            };\n        }\n    }\n\n    // Similar to ES6's rest param (http://ariya.ofilabs.com/2013/03/es6-and-rest-parameter.html)\n    // This accumulates the arguments passed into an array, after a given index.\n    // From underscore.js (https://github.com/jashkenas/underscore/pull/2140).\n    function _restParam(func, startIndex) {\n        startIndex = startIndex == null ? func.length - 1 : +startIndex;\n        return function() {\n            var length = Math.max(arguments.length - startIndex, 0);\n            var rest = Array(length);\n            for (var index = 0; index < length; index++) {\n                rest[index] = arguments[index + startIndex];\n            }\n            switch (startIndex) {\n                case 0: return func.call(this, rest);\n                case 1: return func.call(this, arguments[0], rest);\n            }\n            // Currently unused but handle cases outside of the switch statement:\n            // var args = Array(startIndex + 1);\n            // for (index = 0; index < startIndex; index++) {\n            //     args[index] = arguments[index];\n            // }\n            // args[startIndex] = rest;\n            // return func.apply(this, args);\n        };\n    }\n\n    function _withoutIndex(iterator) {\n        return function (value, index, callback) {\n            return iterator(value, callback);\n        };\n    }\n\n    //// exported async module functions ////\n\n    //// nextTick implementation with browser-compatible fallback ////\n\n    // capture the global reference to guard against fakeTimer mocks\n    var _setImmediate = typeof setImmediate === 'function' && setImmediate;\n\n    var _delay = _setImmediate ? function(fn) {\n        // not a direct alias for IE10 compatibility\n        _setImmediate(fn);\n    } : function(fn) {\n        setTimeout(fn, 0);\n    };\n\n    if (typeof process === 'object' && typeof process.nextTick === 'function') {\n        async.nextTick = process.nextTick;\n    } else {\n        async.nextTick = _delay;\n    }\n    async.setImmediate = _setImmediate ? _delay : async.nextTick;\n\n\n    async.forEach =\n    async.each = function (arr, iterator, callback) {\n        return async.eachOf(arr, _withoutIndex(iterator), callback);\n    };\n\n    async.forEachSeries =\n    async.eachSeries = function (arr, iterator, callback) {\n        return async.eachOfSeries(arr, _withoutIndex(iterator), callback);\n    };\n\n\n    async.forEachLimit =\n    async.eachLimit = function (arr, limit, iterator, callback) {\n        return _eachOfLimit(limit)(arr, _withoutIndex(iterator), callback);\n    };\n\n    async.forEachOf =\n    async.eachOf = function (object, iterator, callback) {\n        callback = _once(callback || noop);\n        object = object || [];\n\n        var iter = _keyIterator(object);\n        var key, completed = 0;\n\n        while ((key = iter()) != null) {\n            completed += 1;\n            iterator(object[key], key, only_once(done));\n        }\n\n        if (completed === 0) callback(null);\n\n        function done(err) {\n            completed--;\n            if (err) {\n                callback(err);\n            }\n            // Check key is null in case iterator isn't exhausted\n            // and done resolved synchronously.\n            else if (key === null && completed <= 0) {\n                callback(null);\n            }\n        }\n    };\n\n    async.forEachOfSeries =\n    async.eachOfSeries = function (obj, iterator, callback) {\n        callback = _once(callback || noop);\n        obj = obj || [];\n        var nextKey = _keyIterator(obj);\n        var key = nextKey();\n        function iterate() {\n            var sync = true;\n            if (key === null) {\n                return callback(null);\n            }\n            iterator(obj[key], key, only_once(function (err) {\n                if (err) {\n                    callback(err);\n                }\n                else {\n                    key = nextKey();\n                    if (key === null) {\n                        return callback(null);\n                    } else {\n                        if (sync) {\n                            async.setImmediate(iterate);\n                        } else {\n                            iterate();\n                        }\n                    }\n                }\n            }));\n            sync = false;\n        }\n        iterate();\n    };\n\n\n\n    async.forEachOfLimit =\n    async.eachOfLimit = function (obj, limit, iterator, callback) {\n        _eachOfLimit(limit)(obj, iterator, callback);\n    };\n\n    function _eachOfLimit(limit) {\n\n        return function (obj, iterator, callback) {\n            callback = _once(callback || noop);\n            obj = obj || [];\n            var nextKey = _keyIterator(obj);\n            if (limit <= 0) {\n                return callback(null);\n            }\n            var done = false;\n            var running = 0;\n            var errored = false;\n\n            (function replenish () {\n                if (done && running <= 0) {\n                    return callback(null);\n                }\n\n                while (running < limit && !errored) {\n                    var key = nextKey();\n                    if (key === null) {\n                        done = true;\n                        if (running <= 0) {\n                            callback(null);\n                        }\n                        return;\n                    }\n                    running += 1;\n                    iterator(obj[key], key, only_once(function (err) {\n                        running -= 1;\n                        if (err) {\n                            callback(err);\n                            errored = true;\n                        }\n                        else {\n                            replenish();\n                        }\n                    }));\n                }\n            })();\n        };\n    }\n\n\n    function doParallel(fn) {\n        return function (obj, iterator, callback) {\n            return fn(async.eachOf, obj, iterator, callback);\n        };\n    }\n    function doParallelLimit(fn) {\n        return function (obj, limit, iterator, callback) {\n            return fn(_eachOfLimit(limit), obj, iterator, callback);\n        };\n    }\n    function doSeries(fn) {\n        return function (obj, iterator, callback) {\n            return fn(async.eachOfSeries, obj, iterator, callback);\n        };\n    }\n\n    function _asyncMap(eachfn, arr, iterator, callback) {\n        callback = _once(callback || noop);\n        arr = arr || [];\n        var results = _isArrayLike(arr) ? [] : {};\n        eachfn(arr, function (value, index, callback) {\n            iterator(value, function (err, v) {\n                results[index] = v;\n                callback(err);\n            });\n        }, function (err) {\n            callback(err, results);\n        });\n    }\n\n    async.map = doParallel(_asyncMap);\n    async.mapSeries = doSeries(_asyncMap);\n    async.mapLimit = doParallelLimit(_asyncMap);\n\n    // reduce only has a series version, as doing reduce in parallel won't\n    // work in many situations.\n    async.inject =\n    async.foldl =\n    async.reduce = function (arr, memo, iterator, callback) {\n        async.eachOfSeries(arr, function (x, i, callback) {\n            iterator(memo, x, function (err, v) {\n                memo = v;\n                callback(err);\n            });\n        }, function (err) {\n            callback(err, memo);\n        });\n    };\n\n    async.foldr =\n    async.reduceRight = function (arr, memo, iterator, callback) {\n        var reversed = _map(arr, identity).reverse();\n        async.reduce(reversed, memo, iterator, callback);\n    };\n\n    async.transform = function (arr, memo, iterator, callback) {\n        if (arguments.length === 3) {\n            callback = iterator;\n            iterator = memo;\n            memo = _isArray(arr) ? [] : {};\n        }\n\n        async.eachOf(arr, function(v, k, cb) {\n            iterator(memo, v, k, cb);\n        }, function(err) {\n            callback(err, memo);\n        });\n    };\n\n    function _filter(eachfn, arr, iterator, callback) {\n        var results = [];\n        eachfn(arr, function (x, index, callback) {\n            iterator(x, function (v) {\n                if (v) {\n                    results.push({index: index, value: x});\n                }\n                callback();\n            });\n        }, function () {\n            callback(_map(results.sort(function (a, b) {\n                return a.index - b.index;\n            }), function (x) {\n                return x.value;\n            }));\n        });\n    }\n\n    async.select =\n    async.filter = doParallel(_filter);\n\n    async.selectLimit =\n    async.filterLimit = doParallelLimit(_filter);\n\n    async.selectSeries =\n    async.filterSeries = doSeries(_filter);\n\n    function _reject(eachfn, arr, iterator, callback) {\n        _filter(eachfn, arr, function(value, cb) {\n            iterator(value, function(v) {\n                cb(!v);\n            });\n        }, callback);\n    }\n    async.reject = doParallel(_reject);\n    async.rejectLimit = doParallelLimit(_reject);\n    async.rejectSeries = doSeries(_reject);\n\n    function _createTester(eachfn, check, getResult) {\n        return function(arr, limit, iterator, cb) {\n            function done() {\n                if (cb) cb(getResult(false, void 0));\n            }\n            function iteratee(x, _, callback) {\n                if (!cb) return callback();\n                iterator(x, function (v) {\n                    if (cb && check(v)) {\n                        cb(getResult(true, x));\n                        cb = iterator = false;\n                    }\n                    callback();\n                });\n            }\n            if (arguments.length > 3) {\n                eachfn(arr, limit, iteratee, done);\n            } else {\n                cb = iterator;\n                iterator = limit;\n                eachfn(arr, iteratee, done);\n            }\n        };\n    }\n\n    async.any =\n    async.some = _createTester(async.eachOf, toBool, identity);\n\n    async.someLimit = _createTester(async.eachOfLimit, toBool, identity);\n\n    async.all =\n    async.every = _createTester(async.eachOf, notId, notId);\n\n    async.everyLimit = _createTester(async.eachOfLimit, notId, notId);\n\n    function _findGetResult(v, x) {\n        return x;\n    }\n    async.detect = _createTester(async.eachOf, identity, _findGetResult);\n    async.detectSeries = _createTester(async.eachOfSeries, identity, _findGetResult);\n    async.detectLimit = _createTester(async.eachOfLimit, identity, _findGetResult);\n\n    async.sortBy = function (arr, iterator, callback) {\n        async.map(arr, function (x, callback) {\n            iterator(x, function (err, criteria) {\n                if (err) {\n                    callback(err);\n                }\n                else {\n                    callback(null, {value: x, criteria: criteria});\n                }\n            });\n        }, function (err, results) {\n            if (err) {\n                return callback(err);\n            }\n            else {\n                callback(null, _map(results.sort(comparator), function (x) {\n                    return x.value;\n                }));\n            }\n\n        });\n\n        function comparator(left, right) {\n            var a = left.criteria, b = right.criteria;\n            return a < b ? -1 : a > b ? 1 : 0;\n        }\n    };\n\n    async.auto = function (tasks, concurrency, callback) {\n        if (typeof arguments[1] === 'function') {\n            // concurrency is optional, shift the args.\n            callback = concurrency;\n            concurrency = null;\n        }\n        callback = _once(callback || noop);\n        var keys = _keys(tasks);\n        var remainingTasks = keys.length;\n        if (!remainingTasks) {\n            return callback(null);\n        }\n        if (!concurrency) {\n            concurrency = remainingTasks;\n        }\n\n        var results = {};\n        var runningTasks = 0;\n\n        var hasError = false;\n\n        var listeners = [];\n        function addListener(fn) {\n            listeners.unshift(fn);\n        }\n        function removeListener(fn) {\n            var idx = _indexOf(listeners, fn);\n            if (idx >= 0) listeners.splice(idx, 1);\n        }\n        function taskComplete() {\n            remainingTasks--;\n            _arrayEach(listeners.slice(0), function (fn) {\n                fn();\n            });\n        }\n\n        addListener(function () {\n            if (!remainingTasks) {\n                callback(null, results);\n            }\n        });\n\n        _arrayEach(keys, function (k) {\n            if (hasError) return;\n            var task = _isArray(tasks[k]) ? tasks[k]: [tasks[k]];\n            var taskCallback = _restParam(function(err, args) {\n                runningTasks--;\n                if (args.length <= 1) {\n                    args = args[0];\n                }\n                if (err) {\n                    var safeResults = {};\n                    _forEachOf(results, function(val, rkey) {\n                        safeResults[rkey] = val;\n                    });\n                    safeResults[k] = args;\n                    hasError = true;\n\n                    callback(err, safeResults);\n                }\n                else {\n                    results[k] = args;\n                    async.setImmediate(taskComplete);\n                }\n            });\n            var requires = task.slice(0, task.length - 1);\n            // prevent dead-locks\n            var len = requires.length;\n            var dep;\n            while (len--) {\n                if (!(dep = tasks[requires[len]])) {\n                    throw new Error('Has nonexistent dependency in ' + requires.join(', '));\n                }\n                if (_isArray(dep) && _indexOf(dep, k) >= 0) {\n                    throw new Error('Has cyclic dependencies');\n                }\n            }\n            function ready() {\n                return runningTasks < concurrency && _reduce(requires, function (a, x) {\n                    return (a && results.hasOwnProperty(x));\n                }, true) && !results.hasOwnProperty(k);\n            }\n            if (ready()) {\n                runningTasks++;\n                task[task.length - 1](taskCallback, results);\n            }\n            else {\n                addListener(listener);\n            }\n            function listener() {\n                if (ready()) {\n                    runningTasks++;\n                    removeListener(listener);\n                    task[task.length - 1](taskCallback, results);\n                }\n            }\n        });\n    };\n\n\n\n    async.retry = function(times, task, callback) {\n        var DEFAULT_TIMES = 5;\n        var DEFAULT_INTERVAL = 0;\n\n        var attempts = [];\n\n        var opts = {\n            times: DEFAULT_TIMES,\n            interval: DEFAULT_INTERVAL\n        };\n\n        function parseTimes(acc, t){\n            if(typeof t === 'number'){\n                acc.times = parseInt(t, 10) || DEFAULT_TIMES;\n            } else if(typeof t === 'object'){\n                acc.times = parseInt(t.times, 10) || DEFAULT_TIMES;\n                acc.interval = parseInt(t.interval, 10) || DEFAULT_INTERVAL;\n            } else {\n                throw new Error('Unsupported argument type for \\'times\\': ' + typeof t);\n            }\n        }\n\n        var length = arguments.length;\n        if (length < 1 || length > 3) {\n            throw new Error('Invalid arguments - must be either (task), (task, callback), (times, task) or (times, task, callback)');\n        } else if (length <= 2 && typeof times === 'function') {\n            callback = task;\n            task = times;\n        }\n        if (typeof times !== 'function') {\n            parseTimes(opts, times);\n        }\n        opts.callback = callback;\n        opts.task = task;\n\n        function wrappedTask(wrappedCallback, wrappedResults) {\n            function retryAttempt(task, finalAttempt) {\n                return function(seriesCallback) {\n                    task(function(err, result){\n                        seriesCallback(!err || finalAttempt, {err: err, result: result});\n                    }, wrappedResults);\n                };\n            }\n\n            function retryInterval(interval){\n                return function(seriesCallback){\n                    setTimeout(function(){\n                        seriesCallback(null);\n                    }, interval);\n                };\n            }\n\n            while (opts.times) {\n\n                var finalAttempt = !(opts.times-=1);\n                attempts.push(retryAttempt(opts.task, finalAttempt));\n                if(!finalAttempt && opts.interval > 0){\n                    attempts.push(retryInterval(opts.interval));\n                }\n            }\n\n            async.series(attempts, function(done, data){\n                data = data[data.length - 1];\n                (wrappedCallback || opts.callback)(data.err, data.result);\n            });\n        }\n\n        // If a callback is passed, run this as a controll flow\n        return opts.callback ? wrappedTask() : wrappedTask;\n    };\n\n    async.waterfall = function (tasks, callback) {\n        callback = _once(callback || noop);\n        if (!_isArray(tasks)) {\n            var err = new Error('First argument to waterfall must be an array of functions');\n            return callback(err);\n        }\n        if (!tasks.length) {\n            return callback();\n        }\n        function wrapIterator(iterator) {\n            return _restParam(function (err, args) {\n                if (err) {\n                    callback.apply(null, [err].concat(args));\n                }\n                else {\n                    var next = iterator.next();\n                    if (next) {\n                        args.push(wrapIterator(next));\n                    }\n                    else {\n                        args.push(callback);\n                    }\n                    ensureAsync(iterator).apply(null, args);\n                }\n            });\n        }\n        wrapIterator(async.iterator(tasks))();\n    };\n\n    function _parallel(eachfn, tasks, callback) {\n        callback = callback || noop;\n        var results = _isArrayLike(tasks) ? [] : {};\n\n        eachfn(tasks, function (task, key, callback) {\n            task(_restParam(function (err, args) {\n                if (args.length <= 1) {\n                    args = args[0];\n                }\n                results[key] = args;\n                callback(err);\n            }));\n        }, function (err) {\n            callback(err, results);\n        });\n    }\n\n    async.parallel = function (tasks, callback) {\n        _parallel(async.eachOf, tasks, callback);\n    };\n\n    async.parallelLimit = function(tasks, limit, callback) {\n        _parallel(_eachOfLimit(limit), tasks, callback);\n    };\n\n    async.series = function(tasks, callback) {\n        _parallel(async.eachOfSeries, tasks, callback);\n    };\n\n    async.iterator = function (tasks) {\n        function makeCallback(index) {\n            function fn() {\n                if (tasks.length) {\n                    tasks[index].apply(null, arguments);\n                }\n                return fn.next();\n            }\n            fn.next = function () {\n                return (index < tasks.length - 1) ? makeCallback(index + 1): null;\n            };\n            return fn;\n        }\n        return makeCallback(0);\n    };\n\n    async.apply = _restParam(function (fn, args) {\n        return _restParam(function (callArgs) {\n            return fn.apply(\n                null, args.concat(callArgs)\n            );\n        });\n    });\n\n    function _concat(eachfn, arr, fn, callback) {\n        var result = [];\n        eachfn(arr, function (x, index, cb) {\n            fn(x, function (err, y) {\n                result = result.concat(y || []);\n                cb(err);\n            });\n        }, function (err) {\n            callback(err, result);\n        });\n    }\n    async.concat = doParallel(_concat);\n    async.concatSeries = doSeries(_concat);\n\n    async.whilst = function (test, iterator, callback) {\n        callback = callback || noop;\n        if (test()) {\n            var next = _restParam(function(err, args) {\n                if (err) {\n                    callback(err);\n                } else if (test.apply(this, args)) {\n                    iterator(next);\n                } else {\n                    callback.apply(null, [null].concat(args));\n                }\n            });\n            iterator(next);\n        } else {\n            callback(null);\n        }\n    };\n\n    async.doWhilst = function (iterator, test, callback) {\n        var calls = 0;\n        return async.whilst(function() {\n            return ++calls <= 1 || test.apply(this, arguments);\n        }, iterator, callback);\n    };\n\n    async.until = function (test, iterator, callback) {\n        return async.whilst(function() {\n            return !test.apply(this, arguments);\n        }, iterator, callback);\n    };\n\n    async.doUntil = function (iterator, test, callback) {\n        return async.doWhilst(iterator, function() {\n            return !test.apply(this, arguments);\n        }, callback);\n    };\n\n    async.during = function (test, iterator, callback) {\n        callback = callback || noop;\n\n        var next = _restParam(function(err, args) {\n            if (err) {\n                callback(err);\n            } else {\n                args.push(check);\n                test.apply(this, args);\n            }\n        });\n\n        var check = function(err, truth) {\n            if (err) {\n                callback(err);\n            } else if (truth) {\n                iterator(next);\n            } else {\n                callback(null);\n            }\n        };\n\n        test(check);\n    };\n\n    async.doDuring = function (iterator, test, callback) {\n        var calls = 0;\n        async.during(function(next) {\n            if (calls++ < 1) {\n                next(null, true);\n            } else {\n                test.apply(this, arguments);\n            }\n        }, iterator, callback);\n    };\n\n    function _queue(worker, concurrency, payload) {\n        if (concurrency == null) {\n            concurrency = 1;\n        }\n        else if(concurrency === 0) {\n            throw new Error('Concurrency must not be zero');\n        }\n        function _insert(q, data, pos, callback) {\n            if (callback != null && typeof callback !== \"function\") {\n                throw new Error(\"task callback must be a function\");\n            }\n            q.started = true;\n            if (!_isArray(data)) {\n                data = [data];\n            }\n            if(data.length === 0 && q.idle()) {\n                // call drain immediately if there are no tasks\n                return async.setImmediate(function() {\n                    q.drain();\n                });\n            }\n            _arrayEach(data, function(task) {\n                var item = {\n                    data: task,\n                    callback: callback || noop\n                };\n\n                if (pos) {\n                    q.tasks.unshift(item);\n                } else {\n                    q.tasks.push(item);\n                }\n\n                if (q.tasks.length === q.concurrency) {\n                    q.saturated();\n                }\n            });\n            async.setImmediate(q.process);\n        }\n        function _next(q, tasks) {\n            return function(){\n                workers -= 1;\n\n                var removed = false;\n                var args = arguments;\n                _arrayEach(tasks, function (task) {\n                    _arrayEach(workersList, function (worker, index) {\n                        if (worker === task && !removed) {\n                            workersList.splice(index, 1);\n                            removed = true;\n                        }\n                    });\n\n                    task.callback.apply(task, args);\n                });\n                if (q.tasks.length + workers === 0) {\n                    q.drain();\n                }\n                q.process();\n            };\n        }\n\n        var workers = 0;\n        var workersList = [];\n        var q = {\n            tasks: [],\n            concurrency: concurrency,\n            payload: payload,\n            saturated: noop,\n            empty: noop,\n            drain: noop,\n            started: false,\n            paused: false,\n            push: function (data, callback) {\n                _insert(q, data, false, callback);\n            },\n            kill: function () {\n                q.drain = noop;\n                q.tasks = [];\n            },\n            unshift: function (data, callback) {\n                _insert(q, data, true, callback);\n            },\n            process: function () {\n                while(!q.paused && workers < q.concurrency && q.tasks.length){\n\n                    var tasks = q.payload ?\n                        q.tasks.splice(0, q.payload) :\n                        q.tasks.splice(0, q.tasks.length);\n\n                    var data = _map(tasks, function (task) {\n                        return task.data;\n                    });\n\n                    if (q.tasks.length === 0) {\n                        q.empty();\n                    }\n                    workers += 1;\n                    workersList.push(tasks[0]);\n                    var cb = only_once(_next(q, tasks));\n                    worker(data, cb);\n                }\n            },\n            length: function () {\n                return q.tasks.length;\n            },\n            running: function () {\n                return workers;\n            },\n            workersList: function () {\n                return workersList;\n            },\n            idle: function() {\n                return q.tasks.length + workers === 0;\n            },\n            pause: function () {\n                q.paused = true;\n            },\n            resume: function () {\n                if (q.paused === false) { return; }\n                q.paused = false;\n                var resumeCount = Math.min(q.concurrency, q.tasks.length);\n                // Need to call q.process once per concurrent\n                // worker to preserve full concurrency after pause\n                for (var w = 1; w <= resumeCount; w++) {\n                    async.setImmediate(q.process);\n                }\n            }\n        };\n        return q;\n    }\n\n    async.queue = function (worker, concurrency) {\n        var q = _queue(function (items, cb) {\n            worker(items[0], cb);\n        }, concurrency, 1);\n\n        return q;\n    };\n\n    async.priorityQueue = function (worker, concurrency) {\n\n        function _compareTasks(a, b){\n            return a.priority - b.priority;\n        }\n\n        function _binarySearch(sequence, item, compare) {\n            var beg = -1,\n                end = sequence.length - 1;\n            while (beg < end) {\n                var mid = beg + ((end - beg + 1) >>> 1);\n                if (compare(item, sequence[mid]) >= 0) {\n                    beg = mid;\n                } else {\n                    end = mid - 1;\n                }\n            }\n            return beg;\n        }\n\n        function _insert(q, data, priority, callback) {\n            if (callback != null && typeof callback !== \"function\") {\n                throw new Error(\"task callback must be a function\");\n            }\n            q.started = true;\n            if (!_isArray(data)) {\n                data = [data];\n            }\n            if(data.length === 0) {\n                // call drain immediately if there are no tasks\n                return async.setImmediate(function() {\n                    q.drain();\n                });\n            }\n            _arrayEach(data, function(task) {\n                var item = {\n                    data: task,\n                    priority: priority,\n                    callback: typeof callback === 'function' ? callback : noop\n                };\n\n                q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);\n\n                if (q.tasks.length === q.concurrency) {\n                    q.saturated();\n                }\n                async.setImmediate(q.process);\n            });\n        }\n\n        // Start with a normal queue\n        var q = async.queue(worker, concurrency);\n\n        // Override push to accept second parameter representing priority\n        q.push = function (data, priority, callback) {\n            _insert(q, data, priority, callback);\n        };\n\n        // Remove unshift function\n        delete q.unshift;\n\n        return q;\n    };\n\n    async.cargo = function (worker, payload) {\n        return _queue(worker, 1, payload);\n    };\n\n    function _console_fn(name) {\n        return _restParam(function (fn, args) {\n            fn.apply(null, args.concat([_restParam(function (err, args) {\n                if (typeof console === 'object') {\n                    if (err) {\n                        if (console.error) {\n                            console.error(err);\n                        }\n                    }\n                    else if (console[name]) {\n                        _arrayEach(args, function (x) {\n                            console[name](x);\n                        });\n                    }\n                }\n            })]));\n        });\n    }\n    async.log = _console_fn('log');\n    async.dir = _console_fn('dir');\n    /*async.info = _console_fn('info');\n    async.warn = _console_fn('warn');\n    async.error = _console_fn('error');*/\n\n    async.memoize = function (fn, hasher) {\n        var memo = {};\n        var queues = {};\n        var has = Object.prototype.hasOwnProperty;\n        hasher = hasher || identity;\n        var memoized = _restParam(function memoized(args) {\n            var callback = args.pop();\n            var key = hasher.apply(null, args);\n            if (has.call(memo, key)) {   \n                async.setImmediate(function () {\n                    callback.apply(null, memo[key]);\n                });\n            }\n            else if (has.call(queues, key)) {\n                queues[key].push(callback);\n            }\n            else {\n                queues[key] = [callback];\n                fn.apply(null, args.concat([_restParam(function (args) {\n                    memo[key] = args;\n                    var q = queues[key];\n                    delete queues[key];\n                    for (var i = 0, l = q.length; i < l; i++) {\n                        q[i].apply(null, args);\n                    }\n                })]));\n            }\n        });\n        memoized.memo = memo;\n        memoized.unmemoized = fn;\n        return memoized;\n    };\n\n    async.unmemoize = function (fn) {\n        return function () {\n            return (fn.unmemoized || fn).apply(null, arguments);\n        };\n    };\n\n    function _times(mapper) {\n        return function (count, iterator, callback) {\n            mapper(_range(count), iterator, callback);\n        };\n    }\n\n    async.times = _times(async.map);\n    async.timesSeries = _times(async.mapSeries);\n    async.timesLimit = function (count, limit, iterator, callback) {\n        return async.mapLimit(_range(count), limit, iterator, callback);\n    };\n\n    async.seq = function (/* functions... */) {\n        var fns = arguments;\n        return _restParam(function (args) {\n            var that = this;\n\n            var callback = args[args.length - 1];\n            if (typeof callback == 'function') {\n                args.pop();\n            } else {\n                callback = noop;\n            }\n\n            async.reduce(fns, args, function (newargs, fn, cb) {\n                fn.apply(that, newargs.concat([_restParam(function (err, nextargs) {\n                    cb(err, nextargs);\n                })]));\n            },\n            function (err, results) {\n                callback.apply(that, [err].concat(results));\n            });\n        });\n    };\n\n    async.compose = function (/* functions... */) {\n        return async.seq.apply(null, Array.prototype.reverse.call(arguments));\n    };\n\n\n    function _applyEach(eachfn) {\n        return _restParam(function(fns, args) {\n            var go = _restParam(function(args) {\n                var that = this;\n                var callback = args.pop();\n                return eachfn(fns, function (fn, _, cb) {\n                    fn.apply(that, args.concat([cb]));\n                },\n                callback);\n            });\n            if (args.length) {\n                return go.apply(this, args);\n            }\n            else {\n                return go;\n            }\n        });\n    }\n\n    async.applyEach = _applyEach(async.eachOf);\n    async.applyEachSeries = _applyEach(async.eachOfSeries);\n\n\n    async.forever = function (fn, callback) {\n        var done = only_once(callback || noop);\n        var task = ensureAsync(fn);\n        function next(err) {\n            if (err) {\n                return done(err);\n            }\n            task(next);\n        }\n        next();\n    };\n\n    function ensureAsync(fn) {\n        return _restParam(function (args) {\n            var callback = args.pop();\n            args.push(function () {\n                var innerArgs = arguments;\n                if (sync) {\n                    async.setImmediate(function () {\n                        callback.apply(null, innerArgs);\n                    });\n                } else {\n                    callback.apply(null, innerArgs);\n                }\n            });\n            var sync = true;\n            fn.apply(this, args);\n            sync = false;\n        });\n    }\n\n    async.ensureAsync = ensureAsync;\n\n    async.constant = _restParam(function(values) {\n        var args = [null].concat(values);\n        return function (callback) {\n            return callback.apply(this, args);\n        };\n    });\n\n    async.wrapSync =\n    async.asyncify = function asyncify(func) {\n        return _restParam(function (args) {\n            var callback = args.pop();\n            var result;\n            try {\n                result = func.apply(this, args);\n            } catch (e) {\n                return callback(e);\n            }\n            // if result is Promise object\n            if (_isObject(result) && typeof result.then === \"function\") {\n                result.then(function(value) {\n                    callback(null, value);\n                })[\"catch\"](function(err) {\n                    callback(err.message ? err : new Error(err));\n                });\n            } else {\n                callback(null, result);\n            }\n        });\n    };\n\n    // Node.js\n    if (typeof module === 'object' && module.exports) {\n        module.exports = async;\n    }\n    // AMD / RequireJS\n    else if (typeof define === 'function' && define.amd) {\n        define([], function () {\n            return async;\n        });\n    }\n    // included directly via <script> tag\n    else {\n        root.async = async;\n    }\n\n}());\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/async/lib/async.js\n// module id = 17\n// module chunks = 0","var hat = require('hat');\nvar util = require('./util');\nvar types = require('./types');\n\n/**\n * Agent deserializes the wire protocol messages received from the stream and\n * calls the corresponding functions on its Agent. It uses the return values\n * to send responses back. Agent also handles piping the operation streams\n * provided by a Agent.\n *\n * @param {Backend} backend\n * @param {Duplex} stream connection to a client\n */\nfunction Agent(backend, stream) {\n  this.backend = backend;\n  this.stream = stream;\n\n  this.clientId = hat();\n  this.connectTime = Date.now();\n\n  // We need to track which documents are subscribed by the client. This is a\n  // map of collection -> id -> stream\n  this.subscribedDocs = {};\n\n  // Map from queryId -> emitter\n  this.subscribedQueries = {};\n\n  // We need to track this manually to make sure we don't reply to messages\n  // after the stream was closed.\n  this.closed = false;\n\n  // For custom use in middleware. The agent is a convenient place to cache\n  // session state in memory. It is in memory only as long as the session is\n  // active, and it is passed to each middleware call\n  this.custom = {};\n\n  // Initialize the remote client by sending it its agent Id.\n  this.send({\n    a: 'init',\n    protocol: 1,\n    id: this.clientId,\n    type: types.defaultType.uri\n  });\n}\nmodule.exports = Agent;\n\n// Close the agent with the client.\nAgent.prototype.close = function(err) {\n  if (err) {\n    console.warn('Agent closed due to error', this.clientId, err.stack || err);\n  }\n  if (this.closed) return;\n  // This will end the writable stream and emit 'finish'\n  this.stream.end();\n};\n\nAgent.prototype._cleanup = function() {\n  this.closed = true;\n\n  // Clean up doc subscription streams\n  for (var collection in this.subscribedDocs) {\n    var docs = this.subscribedDocs[collection];\n    for (var id in docs) {\n      var stream = docs[id];\n      stream.destroy();\n    }\n  }\n  this.subscribedDocs = {};\n\n  // Clean up query subscription streams\n  for (var id in this.subscribedQueries) {\n    var emitter = this.subscribedQueries[id];\n    emitter.destroy();\n  }\n  this.subscribedQueries = {};\n};\n\n/**\n * Passes operation data received on stream to the agent stream via\n * _sendOp()\n */\nAgent.prototype._subscribeToStream = function(collection, id, stream) {\n  if (this.closed) return stream.destroy();\n\n  var streams = this.subscribedDocs[collection] || (this.subscribedDocs[collection] = {});\n\n  // If already subscribed to this document, destroy the previously subscribed stream\n  var previous = streams[id];\n  if (previous) previous.destroy();\n  streams[id] = stream;\n\n  var agent = this;\n  stream.on('data', function(data) {\n    if (data.error) {\n      // Log then silently ignore errors in a subscription stream, since these\n      // may not be the client's fault, and they were not the result of a\n      // direct request by the client\n      console.error('Doc subscription stream error', collection, id, data.error);\n      return;\n    }\n    if (agent._isOwnOp(collection, data)) return;\n    agent._sendOp(collection, id, data);\n  });\n  stream.on('end', function() {\n    // The op stream is done sending, so release its reference\n    var streams = agent.subscribedDocs[collection];\n    if (!streams) return;\n    delete streams[id];\n    if (util.hasKeys(streams)) return;\n    delete agent.subscribedDocs[collection];\n  });\n};\n\nAgent.prototype._subscribeToQuery = function(emitter, queryId, collection, query) {\n  var previous = this.subscribedQueries[queryId];\n  if (previous) previous.destroy();\n  this.subscribedQueries[queryId] = emitter;\n\n  var agent = this;\n  emitter.onExtra = function(extra) {\n    agent.send({a: 'q', id: queryId, extra: extra});\n  };\n\n  emitter.onDiff = function(diff) {\n    for (var i = 0; i < diff.length; i++) {\n      var item = diff[i];\n      if (item.type === 'insert') {\n        item.values = getResultsData(item.values);\n      }\n    }\n    // Consider stripping the collection out of the data we send here\n    // if it matches the query's collection.\n    agent.send({a: 'q', id: queryId, diff: diff});\n  };\n\n  emitter.onError = function(err) {\n    // Log then silently ignore errors in a subscription stream, since these\n    // may not be the client's fault, and they were not the result of a\n    // direct request by the client\n    console.error('Query subscription stream error', collection, query, err);\n  };\n\n  emitter.onOp = function(op) {\n    var id = op.d;\n    if (agent._isOwnOp(collection, op)) return;\n    agent._sendOp(collection, id, op);\n  };\n\n  emitter._open();\n};\n\nAgent.prototype._isOwnOp = function(collection, op) {\n  // Detect ops from this client on the same projection. Since the client sent\n  // these in, the submit reply will be sufficient and we can silently ignore\n  // them in the streams for subscribed documents or queries\n  return (this.clientId === op.src) && (collection === (op.i || op.c));\n};\n\nAgent.prototype.send = function(message) {\n  // Quietly drop replies if the stream was closed\n  if (this.closed) return;\n\n  this.backend.emit('send', this, message);\n  this.stream.write(message);\n};\n\nAgent.prototype._sendOp = function(collection, id, op) {\n  var message = {\n    a: 'op',\n    c: collection,\n    d: id,\n    v: op.v,\n    src: op.src,\n    seq: op.seq\n  };\n  if (op.op) message.op = op.op;\n  if (op.create) message.create = op.create;\n  if (op.del) message.del = true;\n\n  this.send(message);\n};\n\nAgent.prototype._sendOps = function(collection, id, ops) {\n  for (var i = 0; i < ops.length; i++) {\n    this._sendOp(collection, id, ops[i]);\n  }\n};\n\nAgent.prototype._reply = function(request, err, message) {\n  if (err) {\n    if (typeof err === 'string') {\n      request.error = {\n        code: 4001,\n        message: err\n      };\n    } else {\n      if (err.stack) {\n        console.warn(err.stack);\n      }\n      request.error = {\n        code: err.code,\n        message: err.message\n      };\n    }\n    this.send(request);\n    return;\n  }\n  if (!message) message = {};\n\n  message.a = request.a;\n  if (request.id) {\n    message.id = request.id;\n  } else {\n    if (request.c) message.c = request.c;\n    if (request.d) message.d = request.d;\n    if (request.b && !message.data) message.b = request.b;\n  }\n\n  this.send(message);\n};\n\n// Start processing events from the stream\nAgent.prototype._open = function() {\n  if (this.closed) return;\n  this.backend.agentsCount++;\n  if (!this.stream.isServer) this.backend.remoteAgentsCount++;\n\n  var agent = this;\n  this.stream.on('data', function(chunk) {\n    if (agent.closed) return;\n\n    if (typeof chunk !== 'object') {\n      var err = {code: 4000, message: 'Received non-object message'};\n      return agent.close(err);\n    }\n\n    var request = {data: chunk};\n    agent.backend.trigger('receive', agent, request, function(err) {\n      var callback = function(err, message) {\n        agent._reply(request.data, err, message);\n      };\n      if (err) return callback(err);\n      agent._handleMessage(request.data, callback);\n    });\n  });\n\n  this.stream.on('end', function() {\n    agent.backend.agentsCount--;\n    if (!agent.stream.isServer) agent.backend.remoteAgentsCount--;\n    agent._cleanup();\n  });\n};\n\n// Check a request to see if its valid. Returns an error if there's a problem.\nAgent.prototype._checkRequest = function(request) {\n  if (request.a === 'qf' || request.a === 'qs' || request.a === 'qu') {\n    // Query messages need an ID property.\n    if (typeof request.id !== 'number') return 'Missing query ID';\n  } else if (request.a === 'op' || request.a === 'f' || request.a === 's' || request.a === 'u') {\n    // Doc-based request.\n    if (request.c != null && typeof request.c !== 'string') return 'Invalid collection';\n    if (request.d != null && typeof request.d !== 'string') return 'Invalid id';\n\n    if (request.a === 'op') {\n      if (request.v != null && (typeof request.v !== 'number' || request.v < 0)) return 'Invalid version';\n    }\n  } else if (request.a === 'bf' || request.a === 'bs' || request.a === 'bu') {\n    // Bulk request\n    if (request.c != null && typeof request.c !== 'string') return 'Invalid collection';\n    if (typeof request.b !== 'object') return 'Invalid bulk subscribe data';\n  }\n};\n\n// Handle an incoming message from the client\nAgent.prototype._handleMessage = function(request, callback) {\n  try {\n    var errMessage = this._checkRequest(request);\n    if (errMessage) return callback({code: 4000, message: errMessage});\n\n    switch (request.a) {\n      case 'qf':\n        return this._queryFetch(request.id, request.c, request.q, getQueryOptions(request), callback);\n      case 'qs':\n        return this._querySubscribe(request.id, request.c, request.q, getQueryOptions(request), callback);\n      case 'qu':\n        return this._queryUnsubscribe(request.id, callback);\n      case 'bf':\n        return this._fetchBulk(request.c, request.b, callback);\n      case 'bs':\n        return this._subscribeBulk(request.c, request.b, callback);\n      case 'bu':\n        return this._unsubscribeBulk(request.c, request.b, callback);\n      case 'f':\n        return this._fetch(request.c, request.d, request.v, callback);\n      case 's':\n        return this._subscribe(request.c, request.d, request.v, callback);\n      case 'u':\n        return this._unsubscribe(request.c, request.d, callback);\n      case 'op':\n        var op = this._createOp(request);\n        if (!op) return callback({code: 4000, message: 'Invalid op message'});\n        return this._submit(request.c, request.d, op, callback);\n      default:\n        callback({code: 4000, message: 'Invalid or unknown message'});\n    }\n  } catch (err) {\n    callback(err);\n  }\n};\nfunction getQueryOptions(request) {\n  var results = request.r;\n  var ids, fetch, fetchOps;\n  if (results) {\n    ids = [];\n    for (var i = 0; i < results.length; i++) {\n      var result = results[i];\n      var id = result[0];\n      var version = result[1];\n      ids.push(id);\n      if (version == null) {\n        if (fetch) {\n          fetch.push(id);\n        } else {\n          fetch = [id];\n        }\n      } else {\n        if (!fetchOps) fetchOps = {};\n        fetchOps[id] = version;\n      }\n    }\n  }\n  var options = request.o || {};\n  options.ids = ids;\n  options.fetch = fetch;\n  options.fetchOps = fetchOps;\n  return options;\n}\n\nAgent.prototype._queryFetch = function(queryId, collection, query, options, callback) {\n  // Fetch the results of a query once\n  var agent = this;\n  this.backend.queryFetch(this, collection, query, options, function(err, results, extra) {\n    if (err) return callback(err);\n    var message = {\n      data: getResultsData(results),\n      extra: extra\n    };\n    callback(null, message);\n  });\n};\n\nAgent.prototype._querySubscribe = function(queryId, collection, query, options, callback) {\n  // Subscribe to a query. The client is sent the query results and its\n  // notified whenever there's a change\n  var agent = this;\n  var wait = 1;\n  var message;\n  function finish(err) {\n    if (err) return callback(err);\n    if (--wait) return;\n    callback(null, message);\n  }\n  if (options.fetch) {\n    wait++;\n    this.backend.fetchBulk(this, collection, options.fetch, function(err, snapshotMap) {\n      if (err) return finish(err);\n      message = {data: getMapData(snapshotMap)};\n      finish();\n    });\n  }\n  if (options.fetchOps) {\n    wait++;\n    this._fetchBulkOps(collection, options.fetchOps, finish);\n  }\n  this.backend.querySubscribe(this, collection, query, options, function(err, emitter, results, extra) {\n    if (err) return finish(err);\n    if (this.closed) return emitter.destroy();\n\n    agent._subscribeToQuery(emitter, queryId, collection, query);\n    // No results are returned when ids are passed in as an option. Instead,\n    // want to re-poll the entire query once we've established listeners to\n    // emit any diff in results\n    if (!results) {\n      emitter.queryPoll(finish);\n      return;\n    }\n    message = {\n      data: getResultsData(results),\n      extra: extra\n    };\n    finish();\n  });\n};\n\nfunction getResultsData(results) {\n  var items = [];\n  for (var i = 0; i < results.length; i++) {\n    var result = results[i];\n    var item = getSnapshotData(result);\n    item.d = result.id;\n    items.push(item);\n  }\n  return items;\n}\n\nfunction getMapData(snapshotMap) {\n  var data = {};\n  for (var id in snapshotMap) {\n    data[id] = getSnapshotData(snapshotMap[id]);\n  }\n  return data;\n}\n\nfunction getSnapshotData(snapshot) {\n  var data = {\n    v: snapshot.v,\n    data: snapshot.data\n  };\n  if (types.defaultType !== types.map[snapshot.type]) {\n    data.type = snapshot.type;\n  }\n  return data;\n}\n\nAgent.prototype._queryUnsubscribe = function(queryId, callback) {\n  var emitter = this.subscribedQueries[queryId];\n  if (emitter) {\n    emitter.destroy();\n    delete this.subscribedQueries[queryId];\n  }\n  process.nextTick(callback);\n};\n\nAgent.prototype._fetch = function(collection, id, version, callback) {\n  if (version == null) {\n    // Fetch a snapshot\n    this.backend.fetch(this, collection, id, function(err, snapshot) {\n      if (err) return callback(err);\n      callback(null, {data: getSnapshotData(snapshot)});\n    });\n  } else {\n    // It says fetch on the tin, but if a version is specified the client\n    // actually wants me to fetch some ops\n    this._fetchOps(collection, id, version, callback);\n  }\n};\n\nAgent.prototype._fetchOps = function(collection, id, version, callback) {\n  var agent = this;\n  this.backend.getOps(this, collection, id, version, null, function(err, ops) {\n    if (err) return callback(err);\n    agent._sendOps(collection, id, ops);\n    callback();\n  });\n};\n\nAgent.prototype._fetchBulk = function(collection, versions, callback) {\n  if (Array.isArray(versions)) {\n    this.backend.fetchBulk(this, collection, versions, function(err, snapshotMap) {\n      if (err) return callback(err);\n      callback(null, {data: getMapData(snapshotMap)});\n    });\n  } else {\n    this._fetchBulkOps(collection, versions, callback);\n  }\n};\n\nAgent.prototype._fetchBulkOps = function(collection, versions, callback) {\n  var agent = this;\n  this.backend.getOpsBulk(this, collection, versions, null, function(err, opsMap) {\n    if (err) return callback(err);\n    for (var id in opsMap) {\n      var ops = opsMap[id];\n      agent._sendOps(collection, id, ops);\n    }\n    callback();\n  });\n};\n\nAgent.prototype._subscribe = function(collection, id, version, callback) {\n  // If the version is specified, catch the client up by sending all ops\n  // since the specified version\n  var agent = this;\n  this.backend.subscribe(this, collection, id, version, function(err, stream, snapshot) {\n    if (err) return callback(err);\n    agent._subscribeToStream(collection, id, stream);\n    // Snapshot is returned only when subscribing from a null version.\n    // Otherwise, ops will have been pushed into the stream\n    if (snapshot) {\n      callback(null, {data: getSnapshotData(snapshot)});\n    } else {\n      callback();\n    }\n  });\n};\n\nAgent.prototype._subscribeBulk = function(collection, versions, callback) {\n  var agent = this;\n  this.backend.subscribeBulk(this, collection, versions, function(err, streams, snapshotMap) {\n    if (err) return callback(err);\n    for (var id in streams) {\n      agent._subscribeToStream(collection, id, streams[id]);\n    }\n    if (snapshotMap) {\n      callback(null, {data: getMapData(snapshotMap)});\n    } else {\n      callback();\n    }\n  });\n};\n\nAgent.prototype._unsubscribe = function(collection, id, callback) {\n  // Unsubscribe from the specified document. This cancels the active\n  // stream or an inflight subscribing state\n  var docs = this.subscribedDocs[collection];\n  var stream = docs && docs[id];\n  if (stream) stream.destroy();\n  process.nextTick(callback);\n};\n\nAgent.prototype._unsubscribeBulk = function(collection, ids, callback) {\n  var docs = this.subscribedDocs[collection];\n  if (!docs) return process.nextTick(callback);\n  for (var i = 0; i < ids.length; i++) {\n    var id = ids[i];\n    var stream = docs[id];\n    if (stream) stream.destroy();\n  }\n  process.nextTick(callback);\n};\n\nAgent.prototype._submit = function(collection, id, op, callback) {\n  var agent = this;\n  this.backend.submit(this, collection, id, op, null, function(err, ops) {\n    // Message to acknowledge the op was successfully submitted\n    var ack = {src: op.src, seq: op.seq, v: op.v};\n    if (err) {\n      // Occassional 'Op already submitted' errors are expected to happen as\n      // part of normal operation, since inflight ops need to be resent after\n      // disconnect. In this case, ack the op so the client can proceed\n      if (err.code === 4001) return callback(null, ack);\n      return callback(err);\n    }\n\n    // Reply with any operations that the client is missing.\n    agent._sendOps(collection, id, ops);\n    callback(null, ack);\n  });\n};\n\nfunction CreateOp(src, seq, v, create) {\n  this.src = src;\n  this.seq = seq;\n  this.v = v;\n  this.create = create;\n  this.m = null;\n}\nfunction EditOp(src, seq, v, op) {\n  this.src = src;\n  this.seq = seq;\n  this.v = v;\n  this.op = op;\n  this.m = null;\n}\nfunction DeleteOp(src, seq, v, del) {\n  this.src = src;\n  this.seq = seq;\n  this.v = v;\n  this.del = del;\n  this.m = null;\n}\n// Normalize the properties submitted\nAgent.prototype._createOp = function(request) {\n  // src can be provided if it is not the same as the current agent,\n  // such as a resubmission after a reconnect, but it usually isn't needed\n  var src = request.src || this.clientId;\n  if (request.op) {\n    return new EditOp(src, request.seq, request.v, request.op);\n  } else if (request.create) {\n    return new CreateOp(src, request.seq, request.v, request.create);\n  } else if (request.del) {\n    return new DeleteOp(src, request.seq, request.v, request.del);\n  }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/sharedb/lib/agent.js\n// module id = 18\n// module chunks = 0","var DB = require('./index');\n\n// In-memory ShareDB database\n//\n// This adapter is not appropriate for production use. It is intended for\n// testing and as an API example for people implementing database adaptors. It\n// is fully functional, except it stores all documents & operations forever in\n// memory. As such, memory usage will grow without bound, it doesn't scale\n// across multiple node processes and you'll lose all your data if the server\n// restarts. Query APIs are adapter specific. Use with care.\n\nfunction MemoryDB(options) {\n  if (!(this instanceof MemoryDB)) return new MemoryDB(options);\n  DB.call(this, options);\n\n  // Map from collection name -> doc id -> doc snapshot ({v:, type:, data:})\n  this.docs = {};\n\n  // Map from collection name -> doc id -> list of operations. Operations\n  // don't store their version - instead their version is simply the index in\n  // the list.\n  this.ops = {};\n\n  this.closed = false;\n};\nmodule.exports = MemoryDB;\n\nMemoryDB.prototype = Object.create(DB.prototype);\n\nMemoryDB.prototype.close = function(callback) {\n  this.closed = true;\n  if (callback) callback();\n};\n\n// Persists an op and snapshot if it is for the next version. Calls back with\n// callback(err, succeeded)\nMemoryDB.prototype.commit = function(collection, id, op, snapshot, options, callback) {\n  var db = this;\n  if (typeof callback !== 'function') throw new Error('Callback required');\n  process.nextTick(function() {\n    var version = db._getVersionSync(collection, id);\n    if (snapshot.v !== version + 1) {\n      var succeeded = false;\n      return callback(null, succeeded);\n    }\n    var err = db._writeOpSync(collection, id, op);\n    if (err) return callback(err);\n    err = db._writeSnapshotSync(collection, id, snapshot);\n    if (err) return callback(err);\n    var succeeded = true;\n    callback(null, succeeded);\n  });\n};\n\n// Get the named document from the database. The callback is called with (err,\n// snapshot). A snapshot with a version of zero is returned if the docuemnt\n// has never been created in the database.\nMemoryDB.prototype.getSnapshot = function(collection, id, fields, options, callback) {\n  var includeMetadata = (fields && fields.$submit) || (options && options.metadata);\n  var db = this;\n  if (typeof callback !== 'function') throw new Error('Callback required');\n  process.nextTick(function() {\n    var snapshot = db._getSnapshotSync(collection, id, includeMetadata);\n    callback(null, snapshot);\n  });\n};\n\n// Get operations between [from, to) noninclusively. (Ie, the range should\n// contain start but not end).\n//\n// If end is null, this function should return all operations from start onwards.\n//\n// The operations that getOps returns don't need to have a version: field.\n// The version will be inferred from the parameters if it is missing.\n//\n// Callback should be called as callback(error, [list of ops]);\nMemoryDB.prototype.getOps = function(collection, id, from, to, options, callback) {\n  var includeMetadata = options && options.metadata;\n  var db = this;\n  if (typeof callback !== 'function') throw new Error('Callback required');\n  process.nextTick(function() {\n    var opLog = db._getOpLogSync(collection, id);\n    if (to == null) {\n      to = opLog.length;\n    }\n    var ops = clone(opLog.slice(from, to));\n    if (!includeMetadata) {\n      for (var i = 0; i < ops.length; i++) {\n        delete ops[i].m;\n      }\n    }\n    callback(null, ops);\n  });\n};\n\n// The memory database query function returns all documents in a collection\n// regardless of query by default\nMemoryDB.prototype.query = function(collection, query, fields, options, callback) {\n  var includeMetadata = options && options.metadata;\n  var db = this;\n  if (typeof callback !== 'function') throw new Error('Callback required');\n  process.nextTick(function() {\n    var collectionDocs = db.docs[collection];\n    var snapshots = [];\n    for (var id in collectionDocs || {}) {\n      var snapshot = db._getSnapshotSync(collection, id, includeMetadata);\n      snapshots.push(snapshot);\n    }\n    try {\n      var result = db._querySync(snapshots, query, options);\n      callback(null, result.snapshots, result.extra);\n    } catch (err) {\n      callback(err);\n    }\n  });\n};\n\n// For testing, it may be useful to implement the desired query\n// language by defining this function. Returns an object with\n// two properties:\n// - snapshots: array of query result snapshots\n// - extra: (optional) other types of results, such as counts\nMemoryDB.prototype._querySync = function(snapshots, query, options) {\n  return {snapshots: snapshots};\n};\n\nMemoryDB.prototype._writeOpSync = function(collection, id, op) {\n  var opLog = this._getOpLogSync(collection, id);\n  // This will write an op in the log at its version, which should always be\n  // the next item in the array under normal operation\n  opLog[op.v] = clone(op);\n};\n\n// Create, update, and delete snapshots. For creates and updates, a snapshot\n// object will be passed in with a type property. If there is no type property,\n// it should be considered a delete\nMemoryDB.prototype._writeSnapshotSync = function(collection, id, snapshot) {\n  var collectionDocs = this.docs[collection] || (this.docs[collection] = {});\n  if (!snapshot.type) {\n    delete collectionDocs[id];\n  } else {\n    collectionDocs[id] = clone(snapshot);\n  }\n};\n\nMemoryDB.prototype._getSnapshotSync = function(collection, id, includeMetadata) {\n  var collectionDocs = this.docs[collection];\n  // We need to clone the snapshot, because ShareDB assumes each call to\n  // getSnapshot returns a new object\n  var doc = collectionDocs && collectionDocs[id];\n  var snapshot;\n  if (doc) {\n    var data = clone(doc.data);\n    var meta = (includeMetadata) ? clone(doc.m) : undefined;\n    snapshot = new MemorySnapshot(id, doc.v, doc.type, data, meta);\n  } else {\n    var version = this._getVersionSync(collection, id);\n    snapshot = new MemorySnapshot(id, version, null, undefined);\n  }\n  return snapshot;\n};\n\n// `id`, and `v` should be on every returned snapshot\nfunction MemorySnapshot(id, version, type, data, meta) {\n  this.id = id;\n  this.v = version;\n  this.type = type;\n  this.data = data;\n  if (meta) this.m = meta;\n}\n\nMemoryDB.prototype._getOpLogSync = function(collection, id) {\n  var collectionOps = this.ops[collection] || (this.ops[collection] = {});\n  return collectionOps[id] || (collectionOps[id] = []);\n};\n\nMemoryDB.prototype._getVersionSync = function(collection, id) {\n  var collectionOps = this.ops[collection];\n  return (collectionOps && collectionOps[id] && collectionOps[id].length) || 0;\n};\n\nfunction clone(obj) {\n  return (obj === undefined) ? undefined : JSON.parse(JSON.stringify(obj));\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/sharedb/lib/db/memory.js\n// module id = 19\n// module chunks = 0","var async = require('async');\nvar ShareDBError = require('../error');\n\nfunction DB(options) {\n  // pollDebounce is the minimum time in ms between query polls\n  this.pollDebounce = options && options.pollDebounce;\n}\nmodule.exports = DB;\n\nDB.prototype.projectsSnapshots = false;\nDB.prototype.disableSubscribe = false;\n\nDB.prototype.close = function(callback) {\n  if (callback) callback();\n};\n\nDB.prototype.commit = function(collection, id, op, snapshot, options, callback) {\n  callback(new ShareDBError(5011, 'commit DB method unimplemented'));\n};\n\nDB.prototype.getSnapshot = function(collection, id, fields, options, callback) {\n  callback(new ShareDBError(5012, 'getSnapshot DB method unimplemented'));\n};\n\nDB.prototype.getSnapshotBulk = function(collection, ids, fields, options, callback) {\n  var results = {};\n  var db = this;\n  async.each(ids, function(id, eachCb) {\n    db.getSnapshot(collection, id, fields, options, function(err, snapshot) {\n      if (err) return eachCb(err);\n      results[id] = snapshot;\n      eachCb();\n    });\n  }, function(err) {\n    if (err) return callback(err);\n    callback(null, results);\n  });\n};\n\nDB.prototype.getOps = function(collection, id, from, to, options, callback) {\n  callback(new ShareDBError(5013, 'getOps DB method unimplemented'));\n};\n\nDB.prototype.getOpsToSnapshot = function(collection, id, from, snapshot, options, callback) {\n  var to = snapshot.v;\n  this.getOps(collection, id, from, to, options, callback);\n};\n\nDB.prototype.getOpsBulk = function(collection, fromMap, toMap, options, callback) {\n  var results = {};\n  var db = this;\n  async.forEachOf(fromMap, function(from, id, eachCb) {\n    var to = toMap && toMap[id];\n    db.getOps(collection, id, from, to, options, function(err, ops) {\n      if (err) return eachCb(err);\n      results[id] = ops;\n      eachCb();\n    });\n  }, function(err) {\n    if (err) return callback(err);\n    callback(null, results);\n  });\n};\n\nDB.prototype.getCommittedOpVersion = function(collection, id, snapshot, op, options, callback) {\n  this.getOpsToSnapshot(collection, id, 0, snapshot, options, function(err, ops) {\n    if (err) return callback(err);\n    for (var i = ops.length; i--;) {\n      var item = ops[i];\n      if (op.src === item.src && op.seq === item.seq) {\n        return callback(null, item.v);\n      }\n    }\n    callback();\n  });\n};\n\nDB.prototype.query = function(collection, query, fields, options, callback) {\n  callback(new ShareDBError(4022, 'query DB method unimplemented'));\n};\n\nDB.prototype.queryPoll = function(collection, query, options, callback) {\n  var fields = {};\n  this.query(collection, query, fields, options, function(err, snapshots, extra) {\n    if (err) return callback(err);\n    var ids = [];\n    for (var i = 0; i < snapshots.length; i++) {\n      ids.push(snapshots[i].id);\n    }\n    callback(null, ids, extra);\n  });\n};\n\nDB.prototype.queryPollDoc = function(collection, id, query, options, callback) {\n  callback(new ShareDBError(5014, 'queryPollDoc DB method unimplemented'));\n};\n\nDB.prototype.canPollDoc = function() {\n  return false;\n};\n\nDB.prototype.skipPoll = function() {\n  return false;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/sharedb/lib/db/index.js\n// module id = 20\n// module chunks = 0","var PubSub = require('./index');\n\n// In-memory ShareDB pub/sub\n//\n// This is a fully functional implementation. Since ShareDB does not require\n// persistence of pub/sub state, it may be used in production environments\n// requiring only a single stand alone server process. Additionally, it is\n// easy to swap in an external pub/sub adapter if/when additional server\n// processes are desired. No pub/sub APIs are adapter specific.\n\nfunction MemoryPubSub(options) {\n  if (!(this instanceof MemoryPubSub)) return new MemoryPubSub(options);\n  PubSub.call(this, options);\n}\nmodule.exports = MemoryPubSub;\n\nMemoryPubSub.prototype = Object.create(PubSub.prototype);\n\nMemoryPubSub.prototype._subscribe = function(channel, callback) {\n  if (callback) process.nextTick(callback);\n};\n\nMemoryPubSub.prototype._unsubscribe = function(channel, callback) {\n  if (callback) process.nextTick(callback);\n};\n\nMemoryPubSub.prototype._publish = function(channels, data, callback) {\n  var pubsub = this;\n  process.nextTick(function() {\n    for (var i = 0; i < channels.length; i++) {\n      var channel = channels[i];\n      if (pubsub.subscribed[channel]) {\n        pubsub._emit(channel, data);\n      }\n    }\n    if (callback) callback();\n  });\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/sharedb/lib/pubsub/memory.js\n// module id = 21\n// module chunks = 0","var OpStream = require('../op-stream');\nvar ShareDBError = require('../error');\nvar util = require('../util');\n\nfunction PubSub(options) {\n  this.prefix = options && options.prefix;\n  this.nextStreamId = 1;\n  this.streamsCount = 0;\n  // Maps channel -> id -> stream\n  this.streams = {};\n  // State for tracking subscriptions. We track this.subscribed separately from\n  // the streams, since the stream gets added synchronously, and the subscribe\n  // isn't complete until the callback returns from Redis\n  // Maps channel -> true\n  this.subscribed = {};\n}\nmodule.exports = PubSub;\n\nPubSub.prototype.close = function(callback) {\n  for (var channel in this.streams) {\n    var map = this.streams[channel];\n    for (var id in map) {\n      map[id].destroy();\n    }\n  }\n  if (callback) callback();\n};\n\nPubSub.prototype._subscribe = function(channel, callback) {\n  callback(new ShareDBError(5015, '_subscribe PubSub method unimplemented'));\n};\n\nPubSub.prototype._unsubscribe = function(channel, callback) {\n  callback(new ShareDBError(5016, '_unsubscribe PubSub method unimplemented'));\n};\n\nPubSub.prototype._publish = function(channels, data, callback) {\n  callback(new ShareDBError(5017, '_publish PubSub method unimplemented'));\n};\n\nPubSub.prototype.subscribe = function(channel, callback) {\n  if (this.prefix) {\n    channel = this.prefix + ' ' + channel;\n  }\n\n  var pubsub = this;\n  if (this.subscribed[channel]) {\n    process.nextTick(function() {\n      var stream = pubsub._createStream(channel);\n      callback(null, stream);\n    });\n    return;\n  }\n  this._subscribe(channel, function(err) {\n    if (err) return callback(err);\n    pubsub.subscribed[channel] = true;\n    var stream = pubsub._createStream(channel);\n    callback(null, stream);\n  });\n};\n\nPubSub.prototype.publish = function(channels, data, callback) {\n  if (this.prefix) {\n    for (var i = 0; i < channels.length; i++) {\n      channels[i] = this.prefix + ' ' + channels[i];\n    }\n  }\n  this._publish(channels, data, callback);\n};\n\nPubSub.prototype._emit = function(channel, data) {\n  var channelStreams = this.streams[channel];\n  if (channelStreams) {\n    for (var id in channelStreams) {\n      var copy = shallowCopy(data);\n      channelStreams[id].pushOp(copy.c, copy.d, copy);\n    }\n  }\n};\n\nPubSub.prototype._createStream = function(channel) {\n  var stream = new OpStream();\n  var pubsub = this;\n  stream.once('close', function() {\n    pubsub._removeStream(channel, stream);\n  });\n\n  this.streamsCount++;\n  var map = this.streams[channel] || (this.streams[channel] = {});\n  stream.id = this.nextStreamId++;\n  map[stream.id] = stream;\n\n  return stream;\n};\n\nPubSub.prototype._removeStream = function(channel, stream) {\n  var map = this.streams[channel];\n  if (!map) return;\n\n  this.streamsCount--;\n  delete map[stream.id];\n\n  // Cleanup if this was the last subscribed stream for the channel\n  if (util.hasKeys(map)) return;\n  delete this.streams[channel];\n  // Synchronously clear subscribed state. We won't actually be unsubscribed\n  // until some unkown time in the future. If subscribe is called in this\n  // period, we want to send a subscription message and wait for it to\n  // complete before we can count on being subscribed again\n  delete this.subscribed[channel];\n\n  this._unsubscribe(channel, function(err) {\n    if (err) throw err;\n  });\n};\n\nfunction shallowCopy(object) {\n  var out = {};\n  for (var key in object) {\n    out[key] = object[key];\n  }\n  return out;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/sharedb/lib/pubsub/index.js\n// module id = 22\n// module chunks = 0","module.exports = require(\"util\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"util\"\n// module id = 23\n// module chunks = 0","module.exports = require(\"stream\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"stream\"\n// module id = 24\n// module chunks = 0","var arraydiff = require('arraydiff');\nvar deepEquals = require('deep-is');\nvar ShareDBError = require('./error');\nvar util = require('./util');\n\nfunction QueryEmitter(request, stream, ids, extra) {\n  this.backend = request.backend;\n  this.agent = request.agent;\n  this.db = request.db;\n  this.index = request.index;\n  this.query = request.query;\n  this.collection = request.collection;\n  this.fields = request.fields;\n  this.options = request.options;\n  this.snapshotProjection = request.snapshotProjection;\n  this.stream = stream;\n  this.ids = ids;\n  this.extra = extra;\n\n  this.skipPoll = this.options.skipPoll || util.doNothing;\n  this.canPollDoc = this.db.canPollDoc(this.collection, this.query);\n  this.pollDebounce =\n    (typeof this.options.pollDebounce === 'number') ? this.options.pollDebounce :\n    (typeof this.db.pollDebounce === 'number') ? this.db.pollDebounce : 0;\n  this.pollInterval =\n    (typeof this.options.pollInterval === 'number') ? this.options.pollInterval :\n    (typeof this.db.pollInterval === 'number') ? this.db.pollInterval : 0;\n\n  this._polling = false;\n  this._pendingPoll = null;\n  this._pollDebounceId = null;\n  this._pollIntervalId = null;\n}\nmodule.exports = QueryEmitter;\n\n// Start processing events from the stream\nQueryEmitter.prototype._open = function() {\n  var emitter = this;\n  this._defaultCallback = function(err) {\n    if (err) emitter.onError(err);\n  };\n  emitter.stream.on('data', function(data) {\n    if (data.error) {\n      return emitter.onError(data.error);\n    }\n    emitter._update(data);\n  });\n  emitter.stream.on('end', function() {\n    emitter.destroy();\n  });\n  // Make sure we start polling if pollInterval is being used\n  this._flushPoll();\n};\n\nQueryEmitter.prototype.destroy = function() {\n  clearTimeout(this._pollDebounceId);\n  clearTimeout(this._pollIntervalId);\n  this.stream.destroy();\n};\n\nQueryEmitter.prototype._emitTiming = function(action, start) {\n  this.backend.emit('timing', action, Date.now() - start, this);\n};\n\nQueryEmitter.prototype._update = function(op) {\n  var id = op.d;\n\n  // Check if the op's id matches the query before updating the query results\n  // and send it through immediately if it does. The current snapshot\n  // (including the op) for a newly matched document will get sent in the\n  // insert diff, so we don't need to send the op that caused the doc to\n  // match. If the doc already exists in the client and isn't otherwise\n  // subscribed, the client will need to request the op when it receives the\n  // snapshot from the query to bring itself up to date.\n  //\n  // The client may see the result of the op get reflected before the query\n  // results update. This might prove janky in some cases, since a doc could\n  // get deleted before it is removed from the results, for example. However,\n  // it will mean that ops which don't end up changing the results are\n  // received sooner even if query polling takes a while.\n  //\n  // Alternatively, we could send the op message only after the query has\n  // updated, and it would perhaps be ideal to send in the same message to\n  // avoid the user seeing transitional states where the doc is updated but\n  // the results order is not.\n  //\n  // We should send the op even if it is the op that causes the document to no\n  // longer match the query. If client-side filters are applied to the model\n  // to figure out which documents to render in a list, we will want the op\n  // that removed the doc from the query to cause the client-side computed\n  // list to update.\n  if (this.ids.indexOf(id) !== -1) {\n    this.onOp(op);\n  }\n\n  // Ignore if the database or user function says we don't need to poll\n  try {\n    if (this.db.skipPoll(this.collection, id, op, this.query)) return this._defaultCallback();\n    if (this.skipPoll(this.collection, id, op, this.query)) return this._defaultCallback();\n  } catch (err) {\n    return this._defaultCallback(err);\n  }\n  if (this.canPollDoc) {\n    // We can query against only the document that was modified to see if the\n    // op has changed whether or not it matches the results\n    this.queryPollDoc(id, this._defaultCallback);\n  } else {\n    // We need to do a full poll of the query, because the query uses limits,\n    // sorts, or something special\n    this.queryPoll(this._defaultCallback);\n  }\n};\n\nQueryEmitter.prototype._flushPoll = function() {\n  // Don't send another polling query at the same time or within the debounce\n  // timeout. This function will be called again once the poll that is\n  // currently in progress or the pollDebounce timeout completes\n  if (this._polling || this._pollDebounceId) return;\n\n  // If another polling event happened while we were polling, call poll again,\n  // as the results may have changed\n  if (this._pendingPoll) {\n    this.queryPoll();\n\n  // If a pollInterval is specified, poll if the query doesn't get polled in\n  // the time of the interval\n  } else if (this.pollInterval) {\n    var emitter = this;\n    this._pollIntervalId = setTimeout(function() {\n      emitter._pollIntervalId = null;\n      emitter.queryPoll(emitter._defaultCallback);\n    }, this.pollInterval);\n  }\n};\n\nQueryEmitter.prototype.queryPoll = function(callback) {\n  var emitter = this;\n\n  // Only run a single polling check against mongo at a time per emitter. This\n  // matters for two reasons: First, one callback could return before the\n  // other. Thus, our result diffs could get out of order, and the clients\n  // could end up with results in a funky order and the wrong results being\n  // mutated in the query. Second, only having one query executed\n  // simultaneously per emitter will act as a natural adaptive rate limiting\n  // in case the db is under load.\n  //\n  // This isn't neccessary for the document polling case, since they operate\n  // on a given id and won't accidentally modify the wrong doc. Also, those\n  // queries should be faster and are less likely to be the same, so there is\n  // less benefit to possible load reduction.\n  if (this._polling || this._pollDebounceId) {\n    if (this._pendingPoll) {\n      this._pendingPoll.push(callback);\n    } else {\n      this._pendingPoll = [callback];\n    }\n    return;\n  }\n  this._polling = true;\n  var pending = this._pendingPoll;\n  this._pendingPoll = null;\n  if (this.pollDebounce) {\n    this._pollDebounceId = setTimeout(function() {\n      emitter._pollDebounceId = null;\n      emitter._flushPoll();\n    }, this.pollDebounce);\n  }\n  clearTimeout(this._pollIntervalId);\n\n  var start = Date.now();\n  this.db.queryPoll(this.collection, this.query, this.options, function(err, ids, extra) {\n    if (err) return emitter._finishPoll(err, callback, pending);\n    emitter._emitTiming('queryEmitter.poll', start);\n\n    // Be nice to not have to do this in such a brute force way\n    if (!deepEquals(emitter.extra, extra)) {\n      emitter.extra = extra;\n      emitter.onExtra(extra);\n    }\n\n    var idsDiff = arraydiff(emitter.ids, ids);\n    if (idsDiff.length) {\n      emitter.ids = ids;\n      var inserted = getInserted(idsDiff);\n      if (inserted.length) {\n        emitter.db.getSnapshotBulk(emitter.collection, inserted, emitter.fields, null, function(err, snapshotMap) {\n          if (err) return emitter._finishPoll(err, callback, pending);\n          emitter.backend._sanitizeSnapshotBulk(emitter.agent, emitter.snapshotProjection, emitter.collection, snapshotMap, function(err) {\n            if (err) return emitter._finishPoll(err, callback, pending);\n            emitter._emitTiming('queryEmitter.pollGetSnapshotBulk', start);\n            var diff = mapDiff(idsDiff, snapshotMap);\n            emitter.onDiff(diff);\n            emitter._finishPoll(err, callback, pending);\n          });\n        });\n      } else {\n        emitter.onDiff(idsDiff);\n        emitter._finishPoll(err, callback, pending);\n      }\n    } else {\n      emitter._finishPoll(err, callback, pending);\n    }\n  });\n};\nQueryEmitter.prototype._finishPoll = function(err, callback, pending) {\n  this._polling = false;\n  if (callback) callback(err);\n  if (pending) {\n    for (var i = 0; i < pending.length; i++) {\n      callback = pending[i];\n      if (callback) callback(err);\n    }\n  }\n  this._flushPoll();\n};\n\nQueryEmitter.prototype.queryPollDoc = function(id, callback) {\n  var emitter = this;\n  var start = Date.now();\n  this.db.queryPollDoc(this.collection, id, this.query, this.options, function(err, matches) {\n    if (err) return callback(err);\n    emitter._emitTiming('queryEmitter.pollDoc', start);\n\n    // Check if the document was in the previous results set\n    var i = emitter.ids.indexOf(id);\n\n    if (i === -1 && matches) {\n      // Add doc to the collection. Order isn't important, so we'll just whack\n      // it at the end\n      var index = emitter.ids.push(id) - 1;\n      // We can get the result to send to the client async, since there is a\n      // delay in sending to the client anyway\n      emitter.db.getSnapshot(emitter.collection, id, emitter.fields, null, function(err, snapshot) {\n        if (err) return callback(err);\n        emitter.backend._sanitizeSnapshot(emitter.agent, emitter.snapshotProjection, emitter.collection, id, snapshot, function(err) {\n          if (err) return callback(err);\n          var values = [snapshot];\n          emitter.onDiff([new arraydiff.InsertDiff(index, values)]);\n          emitter._emitTiming('queryEmitter.pollDocGetSnapshot', start);\n          callback();\n        });\n      });\n      return;\n    }\n\n    if (i !== -1 && !matches) {\n      emitter.ids.splice(i, 1);\n      emitter.onDiff([new arraydiff.RemoveDiff(i, 1)]);\n      return callback();\n    }\n\n    callback();\n  });\n};\n\n// Clients must assign each of these functions syncronously after constructing\n// an instance of QueryEmitter. The instance is subscribed to an op stream at\n// construction time, and does not buffer emitted events. Diff events assume\n// all messages are received and applied in order, so it is critical that none\n// are dropped.\nQueryEmitter.prototype.onError =\nQueryEmitter.prototype.onDiff =\nQueryEmitter.prototype.onExtra =\nQueryEmitter.prototype.onOp = function() {\n  throw new ShareDBError(5018, 'Required QueryEmitter listener not assigned');\n};\n\nfunction getInserted(diff) {\n  var inserted = [];\n  for (var i = 0; i < diff.length; i++) {\n    var item = diff[i];\n    if (item instanceof arraydiff.InsertDiff) {\n      for (var j = 0; j < item.values.length; j++) {\n        inserted.push(item.values[j]);\n      }\n    }\n  }\n  return inserted;\n}\n\nfunction mapDiff(idsDiff, snapshotMap) {\n  var diff = [];\n  for (var i = 0; i < idsDiff.length; i++) {\n    var item = idsDiff[i];\n    if (item instanceof arraydiff.InsertDiff) {\n      var values = [];\n      for (var j = 0; j < item.values.length; j++) {\n        var id = item.values[j];\n        values.push(snapshotMap[id]);\n      }\n      diff.push(new arraydiff.InsertDiff(item.index, values));\n    } else {\n      diff.push(item);\n    }\n  }\n  return diff;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/sharedb/lib/query-emitter.js\n// module id = 25\n// module chunks = 0","var ot = require('./ot');\nvar projections = require('./projections');\n\nfunction SubmitRequest(backend, agent, index, id, op, options) {\n  this.backend = backend;\n  this.agent = agent;\n  // If a projection, rewrite the call into a call against the collection\n  var projection = backend.projections[index];\n  this.index = index;\n  this.projection = projection;\n  this.collection = (projection) ? projection.target : index;\n  this.id = id;\n  this.op = op;\n  this.options = options;\n\n  this.start = Date.now();\n  this._addOpMeta();\n\n  // Set as this request is sent through middleware\n  this.action = null;\n  // For custom use in middleware\n  this.custom = {};\n\n  this.suppressPublish = backend.suppressPublish;\n  this.maxRetries = backend.maxSubmitRetries;\n  this.retries = 0;\n\n  // return values\n  this.snapshot = null;\n  this.ops = [];\n  this.channels = null;\n}\nmodule.exports = SubmitRequest;\n\nSubmitRequest.prototype.submit = function(callback) {\n  var request = this;\n  var backend = this.backend;\n  var collection = this.collection;\n  var id = this.id;\n  var op = this.op;\n  // Send a special projection so that getSnapshot knows to return all fields.\n  // With a null projection, it strips document metadata\n  var fields = {$submit: true};\n\n  backend.db.getSnapshot(collection, id, fields, null, function(err, snapshot) {\n    if (err) return callback(err);\n\n    request.snapshot = snapshot;\n    request._addSnapshotMeta();\n\n    if (op.v == null) {\n\n      if (op.create && snapshot.type && op.src) {\n        // If the document was already created by another op, we will return a\n        // 'Document already exists' error in response and fail to submit this\n        // op. However, this could also happen in the case that the op was\n        // already committed and the create op was simply resent. In that\n        // case, we should return a non-fatal 'Op already submitted' error. We\n        // must get the past ops and check their src and seq values to\n        // differentiate.\n        backend.db.getCommittedOpVersion(collection, id, snapshot, op, null, function(err, version) {\n          if (err) return callback(err);\n          if (version == null) {\n            callback(request.alreadyCreatedError());\n          } else {\n            op.v = version;\n            callback(request.alreadySubmittedError());\n          }\n        });\n        return;\n      }\n\n      // Submitting an op with a null version means that it should get the\n      // version from the latest snapshot. Generally this will mean the op\n      // won't be transformed, though transform could be called on it in the\n      // case of a retry from a simultaneous submit\n      op.v = snapshot.v;\n    }\n\n    if (op.v === snapshot.v) {\n      // The snapshot hasn't changed since the op's base version. Apply\n      // without transforming the op\n      return request.apply(callback);\n    }\n\n    if (op.v > snapshot.v) {\n      // The op version should be from a previous snapshot, so it should never\n      // never exceed the current snapshot's version\n      return callback(request.newerVersionError());\n    }\n\n    // Transform the op up to the current snapshot version, then apply\n    var from = op.v;\n    backend.db.getOpsToSnapshot(collection, id, from, snapshot, null, function(err, ops) {\n      if (err) return callback(err);\n\n      if (ops.length !== snapshot.v - from) {\n        return callback(request.missingOpsError());\n      }\n\n      err = request._transformOp(ops);\n      if (err) return callback(err);\n\n      if (op.v !== snapshot.v) {\n        // This shouldn't happen, but is just a final sanity check to make\n        // sure we have transformed the op to the current snapshot version\n        return callback(request.versionAfterTransformError());\n      }\n\n      request.apply(callback);\n    });\n  });\n};\n\nSubmitRequest.prototype.apply = function(callback) {\n  // If we're being projected, verify that the op is allowed\n  var projection = this.projection;\n  if (projection && !projections.isOpAllowed(this.snapshot.type, projection.fields, this.op)) {\n    return callback(this.projectionError());\n  }\n\n  // Always set the channels before each attempt to apply. If the channels are\n  // modified in a middleware and we retry, we want to reset to a new array\n  this.channels = this.backend.getChannels(this.collection, this.id);\n\n  var request = this;\n  this.backend.trigger('apply', this.agent, this, function(err) {\n    if (err) return callback(err);\n\n    // Apply the submitted op to the snapshot\n    err = ot.apply(request.snapshot, request.op);\n    if (err) return callback(err);\n\n    request.commit(callback);\n  });\n};\n\nSubmitRequest.prototype.commit = function(callback) {\n  var request = this;\n  var backend = this.backend;\n  backend.trigger('commit', this.agent, this, function(err) {\n    if (err) return callback(err);\n\n    // Try committing the operation and snapshot to the database atomically\n    backend.db.commit(request.collection, request.id, request.op, request.snapshot, request.options, function(err, succeeded) {\n      if (err) return callback(err);\n      if (!succeeded) {\n        // Between our fetch and our call to commit, another client committed an\n        // operation. We expect this to be relatively infrequent but normal.\n        return request.retry(callback);\n      }\n      if (!request.suppressPublish) {\n        var op = request.op;\n        op.c = request.collection;\n        op.d = request.id;\n        op.m = undefined;\n        // Needed for agent to detect if it can ignore sending the op back to\n        // the client that submitted it in subscriptions\n        if (request.collection !== request.index) op.i = request.index;\n        backend.pubsub.publish(request.channels, op);\n      }\n      callback();\n    });\n  });\n};\n\nSubmitRequest.prototype.retry = function(callback) {\n  this.retries++;\n  if (this.maxRetries != null && this.retries > this.maxRetries) {\n    return callback(this.maxRetriesError());\n  }\n  this.backend.emit('timing', 'submit.retry', Date.now() - this.start, this);\n  this.submit(callback);\n};\n\nSubmitRequest.prototype._transformOp = function(ops) {\n  var type = this.snapshot.type;\n  for (var i = 0; i < ops.length; i++) {\n    var op = ops[i];\n\n    if (this.op.src && this.op.src === op.src && this.op.seq === op.seq) {\n      // The op has already been submitted. There are a variety of ways this\n      // can happen in normal operation, such as a client resending an\n      // unacknowledged operation at reconnect. It's important we don't apply\n      // the same op twice\n      return this.alreadySubmittedError();\n    }\n\n    if (this.op.v !== op.v) {\n      return this.versionDuringTransformError();\n    }\n\n    var err = ot.transform(type, this.op, op);\n    if (err) return err;\n    this.ops.push(op);\n  }\n};\n\nSubmitRequest.prototype._addOpMeta = function() {\n  this.op.m = {\n    ts: this.start\n  };\n  if (this.op.create) {\n    // Consistently store the full URI of the type, not just its short name\n    this.op.create.type = ot.normalizeType(this.op.create.type);\n  }\n};\n\nSubmitRequest.prototype._addSnapshotMeta = function() {\n  var meta = this.snapshot.m || (this.snapshot.m = {});\n  if (this.op.create) {\n    meta.ctime = this.start;\n  } else if (this.op.del) {\n    this.op.m.data = this.snapshot.data;\n  }\n  meta.mtime = this.start;\n};\n\n// Non-fatal client errors:\nSubmitRequest.prototype.alreadySubmittedError = function() {\n  return {code: 4001, message: 'Op already submitted'};\n};\nSubmitRequest.prototype.rejectedError = function() {\n  return {code: 4002, message: 'Op submit rejected'};\n};\n// Fatal client errors:\nSubmitRequest.prototype.alreadyCreatedError = function() {\n  return {code: 4010, message: 'Invalid op submitted. Document already created'};\n};\nSubmitRequest.prototype.newerVersionError = function() {\n  return {code: 4011, message: 'Invalid op submitted. Op version newer than current snapshot'};\n};\nSubmitRequest.prototype.projectionError = function() {\n  return {code: 4012, message: 'Invalid op submitted. Operation invalid in projected collection'};\n};\n// Fatal internal errors:\nSubmitRequest.prototype.missingOpsError = function() {\n  return {code: 5001, message: 'Op submit failed. DB missing ops needed to transform it up to the current snapshot version'};\n};\nSubmitRequest.prototype.versionDuringTransformError = function() {\n  return {code: 5002, message: 'Op submit failed. Versions mismatched during op transform'};\n};\nSubmitRequest.prototype.versionAfterTransformError = function() {\n  return {code: 5003, message: 'Op submit failed. Op version mismatches snapshot after op transform'};\n};\nSubmitRequest.prototype.maxRetriesError = function() {\n  return {code: 5004, message: 'Op submit failed. Maximum submit retries exceeded'};\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/sharedb/lib/submit-request.js\n// module id = 26\n// module chunks = 0","import * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport {ArboretumNavigationBar} from './ts/nav_bar';\nimport {ArboretumTab} from './ts/tab';\nimport {ArboretumSidebar, SetServerActiveValue} from './ts/sidebar';\nimport {ipcRenderer, remote, BrowserWindow} from 'electron';\nimport * as url from 'url';\nimport * as _ from 'underscore';\nimport {SDB, SDBDoc} from '../utils/sharedb_wrapper';\nimport {ArboretumChat} from '../utils/chat_doc';\n\nexport type BrowserTabID = number;\n\ntype ArboretumProps = {\n    urls:Array<string>\n};\ntype ArboretumState = {\n    tabs:Array<{url:string, id:number, selected:boolean}>,\n    webViews:Array<JSX.Element>,\n    selectedTab:ArboretumTab,\n    showingSidebar:boolean,\n    serverActive:boolean,\n    activeWebViewEl:JSX.Element\n};\n\nexport class Arboretum extends React.Component<ArboretumProps, ArboretumState> {\n    private navBar:ArboretumNavigationBar;\n    private sidebar:ArboretumSidebar;\n    private tabCounter:number = 0;\n    private tabs:Map<BrowserTabID, ArboretumTab> = new Map<BrowserTabID, ArboretumTab>();\n    private socket:WebSocket;\n    private sdb:SDB;\n    private chat:ArboretumChat;\n    constructor(props) {\n        super(props);\n        this.state = {\n            tabs: this.props.urls.map((url, index) => {\n                return {\n                    selected: index===0,\n                    id: this.tabCounter++,\n                    url: url\n                };\n            }),\n            webViews: [],\n            selectedTab:null,\n            showingSidebar:false,\n            serverActive:false,\n            activeWebViewEl:null\n        };\n        this.updateWebViews();\n    };\n\n    private goBack = ():void => {\n        const {selectedTab} = this.state;\n        if(selectedTab) { selectedTab.goBack(); }\n    };\n    private goForward = ():void => {\n        const {selectedTab} = this.state;\n        if(selectedTab) { selectedTab.goForward(); }\n    };\n    private reload = ():void => {\n        const {selectedTab} = this.state;\n        if(selectedTab) { selectedTab.reload(); }\n    };\n    private toggleSidebar = ():void => {\n    };\n    private navigate = (url:string):void => {\n        const {selectedTab} = this.state;\n        if(selectedTab) { selectedTab.navigate(url); }\n    };\n    private navBarRef = (el:ArboretumNavigationBar):void => {\n        this.navBar = el;\n        this.updateNavBarState();\n    };\n    private updateNavBarState():void {\n        const {selectedTab} = this.state;\n        if(selectedTab && this.navBar) {\n            const {canGoBack, canGoForward, isLoading, loadedURL} = selectedTab.state;\n            this.navBar.setState({canGoBack, canGoForward, isLoading});\n            if(!this.navBar.state.urlBarFocused) {\n                this.navBar.setState({urlText:loadedURL});\n            }\n        }\n    };\n    private async sendIPCMessage(message:any):Promise<any> {\n        ipcRenderer.send('asynchronous-message', message);\n        const reply = await new Promise<any>((resolve, reject) => {\n            ipcRenderer.once('asynchronous-reply', (event:Electron.IpcMessageEvent, data:any) => {\n                resolve(data);\n            });\n        });\n        return reply;\n    };\n    private setServerActive = async (active:boolean):Promise<SetServerActiveValue> => {\n        if(active) {\n            const {hostname, port} = await this.sendIPCMessage('startServer');\n            const fullShareURL = url.format({ protocol:'http', hostname, port });\n            const fullAdminURL = url.format({ protocol:'http', hostname, port, pathname:'/admin' });\n            const wsAddress = url.format({ protocol:'ws', hostname, port });\n            this.socket = new WebSocket(wsAddress);\n            this.sdb = new SDB(true, this.socket);\n            this.chat = new ArboretumChat(this.sdb);\n            console.log(this.chat);\n\n            if(this.sidebar) {\n                this.sidebar.setSDB(this.sdb);\n                this.sidebar.setChat(this.chat);\n            }\n\n            this.chat.addUser('Admin');\n\n            const [shareURL, adminURL] = await Promise.all([\n                this.getShortcut(fullShareURL), this.getShortcut(fullAdminURL)\n            ]);\n            return {shareURL, adminURL};\n        } else {\n            if(this.sidebar) {\n                this.sidebar.setSDB(null);\n                this.sidebar.setChat(null);\n            }\n            if(this.sdb) {\n                await this.sdb.close();\n                this.sdb = null;\n            }\n            if(this.socket) {\n                this.socket.close();\n                this.socket = null;\n            }\n            if(this.chat) {\n                this.chat = null;\n            }\n            await this.sendIPCMessage('stopServer');\n            return {\n                shareURL:'',\n                adminURL:''\n            };\n        }\n    };\n    private async getShortcut(url:string):Promise<string> {\n        return url;\n    };\n    private sendMessage = (message:string):void => {\n        if(this.chat) {\n            this.chat.addTextMessage(message);\n        }\n    };\n    private postTask(sandbox:boolean):void {\n        console.log('post task', sandbox);\n    };\n    private selectedTabURLChanged = (url:string):void => { this.updateNavBarState(); };\n    private selectedTabLoadingChanged = (isLoading:boolean):void => { this.updateNavBarState(); };\n    private selectedTabCanGoBackChanged = (canGoBack:boolean):void => { this.updateNavBarState(); };\n    private selectedTabCanGoForwardChanged = (canGoForward:boolean):void => { this.updateNavBarState(); };\n    private selectedTabPageTitleChanged = (title:string):void => {\n        if(!title) {\n            title='Arboretum';\n        }\n        document.title = title;\n    };\n    private addTab = ():void => {\n        const tabs = this.state.tabs.map((tab) => {\n            return _.extend(tab, {selected: false});\n        }).concat([{\n            id: this.tabCounter++,\n            url:'http://www.cmu.edu/',\n            selected: false\n        }]);\n        this.setState({tabs}, () => {\n            this.updateWebViews();\n        });\n    };\n\n    private updateWebViews():void {\n        const webViews:Array<JSX.Element> = this.state.tabs.map((tab) => {\n            const {id} = tab;\n            if(this.tabs.has(id)) {\n                const arboretumTab = this.tabs.get(id);\n                return arboretumTab.webViewEl;\n            } else {\n                return null;\n            }\n        });\n        this.setState({webViews});\n    };\n\n    private selectTab = (selectedTab:ArboretumTab):void => {\n        if(selectedTab !== this.state.selectedTab) {\n            this.tabs.forEach((t) => {\n                const isSelected = t===selectedTab;\n                t.markSelected(isSelected);\n                if(t.webView) {\n                    t.webView.setAttribute('class', isSelected?'':'hidden');\n                }\n            });\n            const activeWebViewEl = selectedTab ? selectedTab.webViewEl : null;\n            this.setState({selectedTab, activeWebViewEl}, () => {\n                this.updateNavBarState();\n                if(this.state.selectedTab) {\n                    this.selectedTabPageTitleChanged(selectedTab.state.title);\n                }\n            });\n        }\n    };\n\n    private closeTab = (tab:ArboretumTab):void => {\n        let selectedTab:ArboretumTab = this.state.selectedTab;\n        if(tab === this.state.selectedTab) {\n            const tabIndex:number = this.state.tabs.map((t) => t.id).indexOf(tab.props.tabID);\n            if(this.state.tabs.length === 1) { // was the only tab\n                selectedTab = null;\n            } else if(tabIndex === this.state.tabs.length-1) {\n                selectedTab = this.tabs.get(this.state.tabs[tabIndex-1].id);\n            } else {\n                selectedTab = this.tabs.get(this.state.tabs[tabIndex+1].id);\n            }\n        }\n\n        this.tabs.delete(tab.props.tabID);\n        const tabs = this.state.tabs.filter((tabInfo) => tabInfo.id !== tab.props.tabID);\n        this.setState({tabs}, () => {\n            this.selectTab(selectedTab);\n            this.updateWebViews();\n        });\n    };\n\n    private tabRef = (el:ArboretumTab):void => {\n        if(el) {\n            this.tabs.set(el.props.tabID, el);\n            this.selectTab(el);\n            this.updateWebViews();\n        }\n    };\n\n    private tabIsLoadingChanged = (tab:ArboretumTab, isLoading:boolean):void => {\n        if(tab === this.state.selectedTab) { this.selectedTabLoadingChanged(isLoading); }\n    };\n    private tabCanGoBackChanged = (tab:ArboretumTab, canGoBack:boolean):void => {\n        if(tab === this.state.selectedTab) { this.selectedTabCanGoBackChanged(canGoBack); }\n    };\n    private tabCanGoForwardChanged = (tab:ArboretumTab, canGoForward:boolean):void => {\n        if(tab === this.state.selectedTab) { this.selectedTabCanGoBackChanged(canGoForward); }\n    };\n    private tabURLChanged = (tab:ArboretumTab, url:string):void => {\n        if(tab === this.state.selectedTab) { this.selectedTabURLChanged(url); }\n    };\n    private pageTitleChanged = (tab:ArboretumTab, title:string):void => {\n        if(tab === this.state.selectedTab) { this.selectedTabPageTitleChanged(title); }\n    };\n    private sidebarRef = (sidebar:ArboretumSidebar):void => {\n        this.sidebar = sidebar;\n    };\n\n    public render():React.ReactNode {\n        const tabs = this.state.tabs.map((info, index) =>\n                        <ArboretumTab ref={this.tabRef} selected={info.selected} key={info.id} tabID={info.id} startURL={info.url} onSelect={this.selectTab} onClose={this.closeTab} pageTitleChanged={this.pageTitleChanged} urlChanged={this.tabURLChanged} isLoadingChanged={this.tabIsLoadingChanged} canGoBackChanged={this.tabCanGoBackChanged} canGoForwardChanged={this.tabCanGoForwardChanged} />);\n        return <div className=\"window\">\n            <header className=\"toolbar toolbar-header\">\n                <div id=\"tabsBar\" className=\"tab-group\">\n                    <div id='buttonSpacer' className=\"tab-item tab-item-fixed\"> </div>\n                    {tabs}\n                    <div onClick={this.addTab} className=\"tab-item tab-item-fixed\" id='addTab'>\n                        <span className=\"icon icon-plus\"></span>\n                    </div>\n                </div>\n                <ArboretumNavigationBar ref={this.navBarRef} onBack={this.goBack} onForward={this.goForward} onReload={this.reload} onToggleSidebar={this.toggleSidebar} onNavigate={this.navigate} />\n            </header>\n            <div className=\"window-content\">\n                <div className=\"pane-group\">\n                    <ArboretumSidebar ref={this.sidebarRef} onSendMessage={this.sendMessage} setServerActive={this.setServerActive} isVisible={this.state.showingSidebar} serverActive={this.state.serverActive} onPostTask={this.postTask}/>\n                    <div id=\"browser-pane\" className=\"pane\">\n                        <div id=\"content\">{this.state.webViews}</div>\n                    </div>\n                </div>\n            </div>\n        </div>;\n    };\n};\n\nReactDOM.render(\n    <Arboretum urls={['http://www.umich.edu/']} />,\n    document.getElementById('arboretum_main')\n);\n\n\n\n// WEBPACK FOOTER //\n// ./src/browser/browser_main.tsx","module.exports = ReactDOM;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"ReactDOM\"\n// module id = 28\n// module chunks = 0","import * as React from 'react';\n\nconst ENTER_KEY:number = 13;\n\ntype ArboretumNavigationBarProps = {\n    onBack:()=>void,\n    onForward:()=>void,\n    onReload:()=>void,\n    onToggleSidebar:()=>void,\n    onNavigate:(url:string)=>void\n};\ntype ArboretumNavigationBarState = {\n    urlText:string,\n    canGoBack:boolean,\n    canGoForward:boolean,\n    isLoading:boolean,\n    urlBarFocused:boolean\n};\n\nexport class ArboretumNavigationBar extends React.Component<ArboretumNavigationBarProps, ArboretumNavigationBarState> {\n    constructor(props) {\n        super(props);\n        this.state = {\n            urlText:'',\n            canGoBack:false,\n            canGoForward:false,\n            isLoading:false,\n            urlBarFocused:false\n        };\n    };\n\n    private handleURLChange = (event:React.ChangeEvent<HTMLInputElement>):void => {\n        this.setState({ urlText:event.target.value });\n    };\n\n    private backClicked = ():void => {\n        if(this.props.onBack) { this.props.onBack(); }\n    };\n\n    private forwardClicked = ():void => {\n        if(this.props.onForward) { this.props.onForward(); }\n    };\n\n    private reloadClicked = ():void => {\n        if(this.props.onReload) { this.props.onReload(); }\n    };\n\n    private toggleSidebarClicked = ():void => {\n        if(this.props.onToggleSidebar) { this.props.onToggleSidebar(); }\n    };\n\n    private urlKeyDown = (event:React.KeyboardEvent<HTMLInputElement>):void => {\n        const {keyCode} = event;\n        if(keyCode === ENTER_KEY) { // Enter\n            const {urlText} = this.state;\n            if(this.props.onNavigate) { this.props.onNavigate(urlText); }\n        }\n    };\n\n    private onURLBarFocus = (event:React.FocusEvent<HTMLInputElement>):void => {\n        this.setState({urlBarFocused: true});\n    };\n    private onURLBarBlur = (event:React.FocusEvent<HTMLInputElement>):void => {\n        this.setState({urlBarFocused: false});\n    };\n\n    public render():React.ReactNode {\n        return <div id=\"navBar\">\n                    <div className=\"toolbar-actions\">\n                        <div className=\"btn-group\">\n                            <button disabled={!this.state.canGoBack} onClick={this.backClicked} className = 'btn btn-default btn-mini' id='back'><span className='icon icon-left-open-big'></span></button>\n                            <button disabled={!this.state.canGoForward} onClick={this.forwardClicked} className = 'btn btn-default btn-mini' id='forward'><span className='icon icon-right-open-big'></span></button>\n                        </div>\n                        <div className=\"btn-group\">\n                            <button onClick={this.reloadClicked} className = 'btn btn-default btn-mini' id='reload'><span className={`icon ${this.state.isLoading ? 'icon-cancel' : 'icon-ccw'}`}></span></button>\n                            <button onClick={this.toggleSidebarClicked} className = 'btn btn-default btn-mini' id='task'><span className='icon icon-publish'></span></button>\n                        </div>\n                    </div>\n                    <input value={this.state.urlText} onChange={this.handleURLChange} onKeyDown={this.urlKeyDown} onFocus={this.onURLBarFocus} onBlur={this.onURLBarBlur} id='url' type=\"text\" placeholder=\"Enter URL or Term to Search\" />\n                </div>;\n    };\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/browser/ts/nav_bar.tsx","import * as React from 'react';\nimport * as _ from 'underscore';\nimport {BrowserTabID} from '../browser_main';\n\ntype ArboretumTabProps = {\n    startURL:string,\n    onSelect:(tab:ArboretumTab) => void,\n    onClose:(tab:ArboretumTab) => void,\n    tabID:BrowserTabID,\n    selected:boolean,\n    canGoBackChanged?:(tab:ArboretumTab, canGoBack:boolean) => void,\n    canGoForwardChanged?:(tab:ArboretumTab, canGoForward:boolean) => void,\n    isLoadingChanged?:(tab:ArboretumTab, isLoading:boolean) => void,\n    urlChanged?:(tab:ArboretumTab, url:string) => void,\n    pageTitleChanged?:(tab:ArboretumTab, title:string) => void\n};\ntype ArboretumTabState = {\n    title:string,\n    selected:boolean,\n    loadedURL:string,\n    favIconURL:string,\n    canGoBack:boolean,\n    canGoForward:boolean,\n    isLoading:boolean\n};\n\nexport class ArboretumTab extends React.Component<ArboretumTabProps, ArboretumTabState> {\n    public webViewEl:JSX.Element;\n    public webView:Electron.WebviewTag;\n    constructor(props) {\n        super(props);\n        this.state = {\n            title:this.props.startURL,\n            selected:this.props.selected,\n            loadedURL:this.props.startURL,\n            favIconURL:null,\n            canGoBack:false,\n            canGoForward:false,\n            isLoading:false\n        };\n        this.webViewEl = <webview id={`${this.props.tabID}`} key={this.props.tabID} ref={this.webViewRef} src={this.props.startURL}/>;\n    };\n\n    private webViewRef = (el:Electron.WebviewTag):void => {\n        if(el) {\n            this.webView = el;\n            this.webView.addEventListener('page-title-updated', (event:Electron.PageTitleUpdatedEvent) => {\n                const {title} = event;\n                this.setState({title});\n                if(this.props.pageTitleChanged) { this.props.pageTitleChanged(this, title); }\n            });\n            this.webView.addEventListener('load-commit', (event:Electron.LoadCommitEvent) => {\n                const {isMainFrame, url} = event;\n\n                if(isMainFrame) {\n                    const loadedURL = url;\n                    if(this.props.urlChanged) { this.props.urlChanged(this, url); }\n                    this.setState({loadedURL});\n                }\n            });\n            this.webView.addEventListener('page-favicon-updated', (event:Electron.PageFaviconUpdatedEvent) => {\n                const {favicons} = event;\n                const favIconURL = favicons[0];\n                this.setState({favIconURL});\n            });\n            this.webView.addEventListener('did-start-loading', (event) => {\n                this.setState({isLoading:true});\n                if(this.props.isLoadingChanged) { this.props.isLoadingChanged(this, true); }\n            });\n            this.webView.addEventListener('did-stop-loading', (event) => {\n                this.setState({isLoading:false});\n                if(this.props.isLoadingChanged) { this.props.isLoadingChanged(this, false); }\n            });\n        }\n    };\n\n    private onSelect = (event:React.MouseEvent<Element>):void => {\n        if(this.props.onSelect) { this.props.onSelect(this); }\n    };\n    private onClose = (event:React.MouseEvent<Element>):void => {\n        event.stopPropagation(); // don't send a select event\n        if(this.props.onClose) { this.props.onClose(this); }\n    };\n    public markSelected(selected:boolean=true):void {\n        this.setState(_.extend(this.state, {selected}));\n    };\n    public goBack():void {\n        this.webView.goBack();\n    };\n    public goForward():void {\n        this.webView.goForward();\n    };\n    public reload():void {\n        if(this.webView.isLoading()) {\n            this.webView.stop();\n        } else {\n            this.webView.reload();\n        }\n    };\n    public navigate(url:string, options?:Electron.LoadURLOptions):void {\n        this.webView.loadURL(url, options);\n    };\n\n    public render():React.ReactNode {\n        return <div onClick={this.onSelect} className={`tab-item ${this.state.selected ? 'active' : 'not-active' }`}>\n            <span onClick={this.onClose} className='icon icon-cancel icon-close-tab'/>\n            <span className='tab-icon'>{ this.state.favIconURL ?\n                <img className='tab-img' src={this.state.favIconURL} /> : null\n            }</span>\n            <span className='tab-title'>{this.state.title}</span>\n        </div>;\n    };\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/browser/ts/tab.tsx","import * as React from 'react';\nimport {ArboretumChatBox} from './chat';\nimport * as Clipboard from 'clipboard';\nimport Switch from 'react-switch';\nimport {SDB, SDBDoc} from '../../utils/sharedb_wrapper';\nimport {ArboretumChat, Message, User} from '../../utils/chat_doc';\n\nconst ENTER_KEY:number = 13;\n\nexport interface SetServerActiveValue {\n    shareURL:string,\n    adminURL:string\n};\n\ntype ArboretumSidebarProps = {\n    isVisible:boolean,\n    serverActive:boolean,\n    setServerActive?:(active:boolean)=>Promise<SetServerActiveValue>,\n    onSendMessage?:(message:string)=>void,\n    onPostTask?:(sandbox:boolean)=>void\n};\ntype ArboretumSidebarState = {\n    isVisible:boolean,\n    serverActive:boolean,\n    shareURL:string,\n    adminURL:string,\n    sandbox:boolean\n};\n\nexport class ArboretumSidebar extends React.Component<ArboretumSidebarProps, ArboretumSidebarState> {\n    private chatbox:ArboretumChatBox;\n    constructor(props) {\n        super(props);\n        this.state = {\n            isVisible:this.props.isVisible,\n            serverActive:this.props.serverActive,\n            shareURL:'',\n            adminURL:'',\n            sandbox:true\n        };\n    };\n    public setVisible(isVisible:boolean):void {\n        this.setState({isVisible});\n    };\n    private handleServerSwitchChange = async (serverActive:boolean):Promise<void> => {\n        this.setState({serverActive});\n        if(this.props.setServerActive) {\n            const shareURLs = await this.props.setServerActive(serverActive);\n            if(serverActive) {\n                const {shareURL, adminURL} = shareURLs;\n                this.setState({shareURL, adminURL});\n            } else {\n                this.setState({shareURL:'', adminURL:''});\n            }\n        }\n    };\n    private sendMessage = (message:string):void => {\n        if(this.props.onSendMessage) { this.props.onSendMessage(message); }\n    };\n    private postToMTurk = ():void => {\n        if(this.props.onPostTask) { this.props.onPostTask(this.state.sandbox); }\n    };\n    private onSandboxChange = (event:React.ChangeEvent<HTMLInputElement>) => {\n        this.setState({sandbox: event.target.checked});\n    };\n    private adminURLRef = (el:HTMLInputElement):void => {\n        if(el) {\n            new Clipboard(el);\n        }\n    };\n    private shareURLRef = (el:HTMLInputElement):void => {\n        if(el) {\n            new Clipboard(el);\n        }\n    };\n    private chatBoxRef = (chatbox:ArboretumChatBox):void => {\n        this.chatbox = chatbox;\n    };\n\n    public setSDB(sdb:SDB):void {\n        if(this.chatbox) {\n            this.chatbox.setSDB(sdb);\n        }\n    };\n    public setChat(chat:ArboretumChat):void {\n        if(this.chatbox) {\n            this.chatbox.setChat(chat);\n        }\n    };\n\n    public render():React.ReactNode {\n        return <div className='sidebar'>\n            <table id=\"server-controls\">\n                <thead>\n                    <tr>\n                        <td>\n                            <h5 className=\"nav-group-title\">Server</h5>\n                        </td>\n                        <td>\n                            <h5 className=\"nav-group-title\">Share URL</h5>\n                        </td>\n                        <td>\n                            <h5 className=\"nav-group-title\">Admin URL</h5>\n                        </td>\n                        <td>\n                            <h5 className=\"nav-group-title\">MTurk</h5>\n                        </td>\n                    </tr>\n                </thead>\n                <tbody>\n                    <tr id=\"control_content\">\n                        <td>\n                            <Switch height={24} width={48} onChange={this.handleServerSwitchChange} checked={this.state.serverActive} />\n                        </td>\n                        <td className=\"copy_area\">\n                            <input ref={this.shareURLRef} value={this.state.shareURL} id=\"share_url\" data-disabled=\"true\"/>\n                            <span ref={(el) => (el)} data-clipboard-target=\"#share_url\" id=\"share_copy\" className=\"icon icon-clipboard\"></span>\n                        </td>\n                        <td className=\"copy_area\">\n                            <input ref={this.adminURLRef} value={this.state.adminURL} id=\"admin_url\" data-disabled=\"true\"/>\n                            <span data-clipboard-target=\"#admin_url\" id=\"admin_copy\" className=\"icon icon-clipboard\"></span>\n                        </td>\n                        <td>\n                            <button onClick={this.postToMTurk} id=\"mturk_post\" className='btn btn-default'><span className=\"icon icon-upload-cloud\"></span>&nbsp;Post</button>\n                            <br />\n                            <label><input type=\"checkbox\" name=\"sandbox\" value=\"sandbox\" id=\"sandbox\" checked={this.state.sandbox} onChange={this.onSandboxChange}/> Sandbox</label>\n                        </td>\n                    </tr>\n                </tbody>\n            </table>\n            <ArboretumChatBox ref={this.chatBoxRef} onSendMessage={this.sendMessage} />\n        </div>;\n    };\n    // populateShareURLs() {\n    //     $('#share_url').val('loading...');\n    //     $('#admin_url').val('loading...');\n    //\n    //     this.getMyShortcut().then(function(url) {\n    //         $('#share_url').val(url.replace('http://', '')).prop('disabled', false);\n    //     });\n    //     this.getMyShortcut('/a').then(function(url) {\n    //         $('#admin_url').val(url.replace('http://', '')).prop('disabled', false);\n    //     });\n    // }\n    //\n    // startServer() {\n    //     this.chat.enable();\n    //     const {ipcRenderer} = require('electron');\n    //     ipcRenderer.send('asynchronous-message', 'startServer');\n    //     // this.populateShareURLs();\n    //     // remote.getCurrentWindow().emit('startServer', () => {\n    //     //     ipcRenderer.send('asynchronous-message','test');\n    //     //     this.chat.connect();\n    //     // });\n    // }\n    //\n    // private stopServer():void {\n    //     ipcRenderer.send('asynchronous-message', 'stopServer');\n    //     $('#share_url').val('').prop('disabled', true);\n    //     $('#admin_url').val('').prop('disabled', true);\n    //     this.chat.clear();\n    //     this.chat.disable();\n    // }\n    //\n    // postToMTurk() {\n    //     console.log($('#sandbox').is(\":checked\"));\n    //\n    //     remote.getCurrentWindow().emit('postHIT', {\n    //         share_url: 'http://'+$('#share_url').val(),\n    //         sandbox: $('#sandbox').is(\":checked\")\n    //     }, _.bind(() => {\n    //         console.log('posted!')\n    //     }, this));\n    // }\n    //\n    // private async getMyShortcut(address:string, path:string):Promise<string> {\n    //     const url = require('url');\n    //     return Sidebar.getIPAddress().then(function(ip) {\n    //         var myLink = url.format({\n    //             protocol: 'http',\n    //             hostname: ip,\n    //             port: 3000,\n    //             pathname: path || '/'\n    //         });\n    //         return Sidebar.getShortcut(myLink)\n    //     }).then(function(result) {\n    //         const shortcut = result.shortcut;\n    //         return url.format({\n    //             protocol: 'http',\n    //             hostname: 'arbor.site',\n    //             pathname: shortcut\n    //         });\n    //     });\n    // }\n    //\n    // private static async getShortcut(url:string):Promise<string> {\n    //     return new Promise<string>((resolve, reject) => {\n    //         $.ajax({\n    //             method: 'PUT',\n    //             url: 'https://api.arbor.site',\n    //             contentType: 'application/json',\n    //             headers: {\n    //                 'x-api-key': API_KEY\n    //             },\n    //             data: JSON.stringify({\n    //                 target: url\n    //             })\n    //         }).done((data) => {\n    //             resolve(data);\n    //         }).fail((err) => {\n    //             reject(err);\n    //         });\n    //     });\n    // }\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/browser/ts/sidebar.tsx","import * as React from 'react';\nimport {SDB, SDBDoc} from '../../utils/sharedb_wrapper';\nimport {ArboretumChat, Message, User} from '../../utils/chat_doc';\n\nconst ENTER_KEY:number = 13;\n\ntype ArboretumChatProps = {\n    onSendMessage:(message:string)=>void,\n    chatText?:string\n};\ntype ArboretumChatState = {\n    chatText:string,\n    messages:Array<Message>,\n    users:Array<User>\n};\n\nexport class ArboretumChatBox extends React.Component<ArboretumChatProps, ArboretumChatState> {\n    private sdb:SDB;\n    private chat:ArboretumChat;\n    constructor(props) {\n        super(props);\n        this.state = {\n            chatText:this.props.chatText||'',\n            messages:[],\n            users:[]\n        };\n    };\n    public setChat(chat:ArboretumChat) {\n        this.chat = chat;\n        if(this.chat) {\n            this.chat.messageAdded(this.updateMessagesState);\n            this.chat.userJoined(this.updateUsersState);\n            this.chat.ready(() => {\n                this.updateMessagesState();\n                this.updateUsersState();\n            });\n        }\n    };\n    public setSDB(sdb:SDB) {\n        this.sdb = sdb;\n    };\n    private updateMessagesState = async ():Promise<void> => {\n        const messages = await this.chat.getMessages();\n        this.setState({messages});\n    };\n    private updateUsersState = async ():Promise<void> => {\n        const users = await this.chat.getUsers();\n        this.setState({users});\n    };\n\n    private chatKeyDown = (event:React.KeyboardEvent<HTMLTextAreaElement>):void => {\n        const {keyCode, ctrlKey, altKey, metaKey, shiftKey} = event;\n        if(keyCode === ENTER_KEY && !(ctrlKey || altKey || metaKey || shiftKey)) {\n            event.preventDefault();\n            const {chatText} = this.state;\n            if(chatText !== '') {\n                if(this.props.onSendMessage) { this.props.onSendMessage(chatText); }\n                this.setState({chatText:''});\n            }\n        }\n    };\n\n    private onTextareaChange = (event:React.ChangeEvent<HTMLTextAreaElement>):void => {\n        this.setState({ chatText:event.target.value });\n    };\n\n    public render():React.ReactNode {\n        const messages = this.state.messages.map((m:Message) => {\n            return <li className='chat-line'><span className='from'>{m.sender.displayName}</span><span className='message'>{m.content}</span></li>;\n        });\n        let meUserID;\n        if(this.chat) {\n            const meUser = this.chat.getMe();\n            if(meUser) {\n                meUserID = meUser.id;\n            }\n        }\n        const users = this.state.users.map((u) => {\n            const isMe = u.id === meUserID;\n            return <span>{u.displayName}</span>;\n        });\n        return <div className='chat'>\n            <h6 id=\"task_title\"><span className=\"icon icon-chat\"></span><span id='task-name'>Chat</span></h6>\n            <div id=\"chat-participants\">{users}</div>\n            <ul id=\"chat-lines\">\n                {messages}\n            </ul>\n            <form id=\"chat-form\">\n                <textarea id=\"chat-box\" className=\"form-control\" placeholder=\"Send a message\" onChange={this.onTextareaChange} onKeyDown={this.chatKeyDown} value={this.state.chatText}></textarea>\n            </form>\n        </div>;\n    };\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/browser/ts/chat.tsx","module.exports = require(\"clipboard\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"clipboard\"\n// module id = 33\n// module chunks = 0","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _react = require(\"react\");\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _propTypes = require(\"prop-types\");\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _icons = require(\"./icons\");\n\nvar _getBackgroundColor = require(\"./getBackgroundColor\");\n\nvar _getBackgroundColor2 = _interopRequireDefault(_getBackgroundColor);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Switch = function (_Component) {\n  _inherits(Switch, _Component);\n\n  function Switch(props) {\n    _classCallCheck(this, Switch);\n\n    var _this = _possibleConstructorReturn(this, (Switch.__proto__ || Object.getPrototypeOf(Switch)).call(this, props));\n\n    _initialiseProps.call(_this);\n\n    var height = props.height,\n        width = props.width,\n        handleDiameter = props.handleDiameter,\n        checked = props.checked;\n\n    _this.handleDiameter = handleDiameter || height - 2;\n    _this.checkedPos = Math.max(width - height, width - (height + _this.handleDiameter) / 2);\n    _this.uncheckedPos = Math.max(0, (height - _this.handleDiameter) / 2);\n    _this.state = {\n      pos: checked ? _this.checkedPos : _this.uncheckedPos,\n      startX: null,\n      isDragging: false,\n      hasOutline: false\n    };\n    return _this;\n  }\n\n  _createClass(Switch, [{\n    key: \"componentWillReceiveProps\",\n    value: function componentWillReceiveProps(_ref) {\n      var checked = _ref.checked;\n\n      var pos = checked ? this.checkedPos : this.uncheckedPos;\n      this.setState({ pos: pos });\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n\n      var _props = this.props,\n          checked = _props.checked,\n          disabled = _props.disabled,\n          className = _props.className,\n          offColor = _props.offColor,\n          onColor = _props.onColor,\n          offHandleColor = _props.offHandleColor,\n          onHandleColor = _props.onHandleColor,\n          checkedIcon = _props.checkedIcon,\n          uncheckedIcon = _props.uncheckedIcon,\n          boxShadow = _props.boxShadow,\n          activeBoxShadow = _props.activeBoxShadow,\n          height = _props.height,\n          width = _props.width,\n          id = _props.id,\n          ariaLabelledby = _props[\"aria-labelledby\"],\n          ariaLabel = _props[\"aria-label\"];\n      var _state = this.state,\n          pos = _state.pos,\n          isDragging = _state.isDragging,\n          hasOutline = _state.hasOutline;\n\n\n      var rootStyle = {\n        position: \"relative\",\n        display: \"inline-block\",\n        opacity: disabled ? 0.5 : 1,\n        borderRadius: height / 2,\n        WebkitTransition: \"opacity 0.25s\",\n        MozTransition: \"opacity 0.25s\",\n        transition: \"opacity 0.25s\",\n        touchAction: \"none\",\n        WebkitTapHighlightColor: \"rgba(0, 0, 0, 0)\",\n        WebkitUserSelect: \"none\",\n        MozUserSelect: \"none\",\n        msUserSelect: \"none\",\n        userSelect: \"none\"\n      };\n\n      var backgroundStyle = {\n        height: height,\n        width: width,\n        margin: Math.max(0, (this.handleDiameter - height) / 2),\n        position: \"relative\",\n        background: (0, _getBackgroundColor2.default)(pos, this.checkedPos, this.uncheckedPos, offColor, onColor),\n        borderRadius: height / 2,\n        cursor: disabled ? \"default\" : \"pointer\",\n        WebkitTransition: isDragging ? null : \"background 0.25s\",\n        MozTransition: isDragging ? null : \"background 0.25s\",\n        transition: isDragging ? null : \"background 0.25s\"\n      };\n\n      var checkedIconStyle = {\n        height: height,\n        width: Math.min(height * 1.5, width - (this.handleDiameter + height) / 2 + 1),\n        position: \"relative\",\n        opacity: (pos - this.uncheckedPos) / (this.checkedPos - this.uncheckedPos),\n        pointerEvents: \"none\",\n        WebkitTransition: isDragging ? null : \"opacity 0.25s\",\n        MozTransition: isDragging ? null : \"opacity 0.25s\",\n        transition: isDragging ? null : \"opacity 0.25s\"\n      };\n\n      var uncheckedIconStyle = {\n        height: height,\n        width: Math.min(height * 1.5, width - (this.handleDiameter + height) / 2 + 1),\n        position: \"absolute\",\n        opacity: 1 - (pos - this.uncheckedPos) / (this.checkedPos - this.uncheckedPos),\n        right: 0,\n        top: 0,\n        pointerEvents: \"none\",\n        WebkitTransition: isDragging ? null : \"opacity 0.25s\",\n        MozTransition: isDragging ? null : \"opacity 0.25s\",\n        transition: isDragging ? null : \"opacity 0.25s\"\n      };\n\n      var handleStyle = {\n        height: this.handleDiameter,\n        width: this.handleDiameter,\n        background: (0, _getBackgroundColor2.default)(pos, this.checkedPos, this.uncheckedPos, offHandleColor, onHandleColor),\n        cursor: disabled ? \"default\" : \"pointer\",\n        display: \"inline-block\",\n        borderRadius: \"50%\",\n        position: \"absolute\",\n        transform: \"translateX(\" + pos + \"px)\",\n        top: Math.max(0, (height - this.handleDiameter) / 2),\n        outline: 0,\n        boxShadow: hasOutline ? activeBoxShadow : boxShadow,\n        border: 0,\n        WebkitTransition: isDragging ? null : \"background-color 0.25s, transform 0.25s, box-shadow 0.15s\",\n        MozTransition: isDragging ? null : \"background-color 0.25s, transform 0.25s, box-shadow 0.15s\",\n        transition: isDragging ? null : \"background-color 0.25s, transform 0.25s, box-shadow 0.15s\"\n      };\n\n      return _react2.default.createElement(\n        \"div\",\n        { className: className, style: rootStyle },\n        _react2.default.createElement(\n          \"div\",\n          {\n            className: \"react-switch-bg\",\n            style: backgroundStyle,\n            onClick: disabled ? null : this.handleClick\n          },\n          checkedIcon && _react2.default.createElement(\n            \"div\",\n            { style: checkedIconStyle },\n            checkedIcon\n          ),\n          uncheckedIcon && _react2.default.createElement(\n            \"div\",\n            { style: uncheckedIconStyle },\n            uncheckedIcon\n          )\n        ),\n        _react2.default.createElement(\"div\", {\n          className: \"react-switch-handle\",\n          role: \"checkbox\",\n          tabIndex: disabled ? null : 0,\n          onMouseDown: disabled ? null : this.handleMouseDown,\n          onTouchStart: disabled ? null : this.handleTouchStart,\n          onTouchMove: disabled ? null : this.handleTouchMove,\n          onTouchEnd: disabled ? null : this.handleTouchEnd,\n          onTouchCancel: disabled ? null : this.handleTouchCancel,\n          onKeyDown: this.handleKeyDown,\n          onFocus: function onFocus() {\n            return _this2.setState({ hasOutline: true });\n          },\n          onBlur: function onBlur() {\n            return _this2.setState({ hasOutline: false });\n          },\n          style: handleStyle,\n          id: id,\n          \"aria-checked\": checked,\n          \"aria-disabled\": disabled,\n          \"aria-labelledby\": ariaLabelledby,\n          \"aria-label\": ariaLabel\n        })\n      );\n    }\n  }]);\n\n  return Switch;\n}(_react.Component);\n\nvar _initialiseProps = function _initialiseProps() {\n  var _this3 = this;\n\n  this.handleDragStart = function (clientX) {\n    _this3.setState({ startX: clientX, hasOutline: true });\n  };\n\n  this.handleDrag = function (clientX) {\n    var startX = _this3.state.startX;\n    var checked = _this3.props.checked;\n\n    var startPos = checked ? _this3.checkedPos : _this3.uncheckedPos;\n    var newPos = startPos + clientX - startX;\n    var pos = Math.min(_this3.checkedPos, Math.max(_this3.uncheckedPos, newPos));\n    _this3.setState({ pos: pos, isDragging: true });\n  };\n\n  this.handleDragStop = function (event) {\n    var _state2 = _this3.state,\n        pos = _state2.pos,\n        isDragging = _state2.isDragging;\n    var _props2 = _this3.props,\n        checked = _props2.checked,\n        onChange = _props2.onChange,\n        id = _props2.id;\n\n    // Simulate clicking the handle\n\n    if (!isDragging) {\n      _this3.setState({ startX: null, hasOutline: false });\n      onChange(!checked, event, id);\n      return;\n    }\n    if (checked) {\n      if (pos > (_this3.checkedPos + _this3.uncheckedPos) / 2) {\n        _this3.setState({\n          pos: _this3.checkedPos,\n          startX: null,\n          isDragging: false,\n          hasOutline: false\n        });\n        return;\n      }\n      _this3.setState({ startX: null, isDragging: false, hasOutline: false });\n      onChange(false, event, id);\n      return;\n    }\n    if (pos < (_this3.checkedPos + _this3.uncheckedPos) / 2) {\n      _this3.setState({\n        pos: _this3.uncheckedPos,\n        startX: null,\n        isDragging: false,\n        hasOutline: false\n      });\n      return;\n    }\n    _this3.setState({ startX: null, isDragging: false, hasOutline: false });\n    onChange(true, event, id);\n  };\n\n  this.handleMouseDown = function (event) {\n    // Ignore right click and scroll\n    if (typeof event.button === \"number\" && event.button !== 0) {\n      return;\n    }\n\n    _this3.handleDragStart(event.clientX);\n    document.addEventListener(\"mousemove\", _this3.handleMouseMove);\n    document.addEventListener(\"mouseup\", _this3.handleMouseUp);\n  };\n\n  this.handleMouseMove = function (event) {\n    event.preventDefault();\n    _this3.handleDrag(event.clientX);\n  };\n\n  this.handleMouseUp = function (event) {\n    _this3.handleDragStop(event);\n    document.removeEventListener(\"mousemove\", _this3.handleMouseMove);\n    document.removeEventListener(\"mouseup\", _this3.handleMouseUp);\n  };\n\n  this.handleTouchStart = function (event) {\n    _this3.handleDragStart(event.touches[0].clientX);\n  };\n\n  this.handleTouchMove = function (event) {\n    _this3.handleDrag(event.touches[0].clientX);\n  };\n\n  this.handleTouchEnd = function (event) {\n    event.preventDefault();\n    _this3.handleDragStop(event);\n  };\n\n  this.handleTouchCancel = function () {\n    _this3.setState({ startX: null, hasOutline: false });\n  };\n\n  this.handleClick = function (event) {\n    var _props3 = _this3.props,\n        checked = _props3.checked,\n        onChange = _props3.onChange,\n        id = _props3.id;\n\n    onChange(!checked, event, id);\n  };\n\n  this.handleKeyDown = function (event) {\n    var _props4 = _this3.props,\n        checked = _props4.checked,\n        onChange = _props4.onChange,\n        id = _props4.id;\n    var isDragging = _this3.state.isDragging;\n    // Trigger change on spacebar and enter keys (in violation of wai-aria spec).\n\n    if ((event.keyCode === 32 || event.keyCode === 13) && !isDragging) {\n      event.preventDefault();\n      onChange(!checked, event, id);\n    }\n  };\n};\n\nSwitch.propTypes = {\n  checked: _propTypes2.default.bool.isRequired,\n  onChange: _propTypes2.default.func.isRequired,\n  disabled: _propTypes2.default.bool,\n  offColor: _propTypes2.default.string,\n  onColor: _propTypes2.default.string,\n  offHandleColor: _propTypes2.default.string,\n  onHandleColor: _propTypes2.default.string,\n  handleDiameter: _propTypes2.default.number,\n  uncheckedIcon: _propTypes2.default.oneOfType([_propTypes2.default.bool, _propTypes2.default.element]),\n  checkedIcon: _propTypes2.default.oneOfType([_propTypes2.default.bool, _propTypes2.default.element]),\n  boxShadow: _propTypes2.default.string,\n  activeBoxShadow: _propTypes2.default.string,\n  height: _propTypes2.default.number,\n  width: _propTypes2.default.number,\n  className: _propTypes2.default.string,\n  id: _propTypes2.default.string,\n  \"aria-labelledby\": _propTypes2.default.string,\n  \"aria-label\": _propTypes2.default.string\n};\n\nSwitch.defaultProps = {\n  disabled: false,\n  offColor: \"#888\",\n  onColor: \"#080\",\n  offHandleColor: \"#fff\",\n  onHandleColor: \"#fff\",\n  handleDiameter: null,\n  uncheckedIcon: _icons.uncheckedIcon,\n  checkedIcon: _icons.checkedIcon,\n  boxShadow: null,\n  activeBoxShadow: \"0px 0px 2px 3px #33bbff\",\n  height: 28,\n  width: 56,\n  className: null,\n  id: null,\n  \"aria-labelledby\": null,\n  \"aria-label\": null\n};\n\nexports.default = Switch;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/react-switch/dist/index.js\n// module id = 34\n// module chunks = 0","/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nif (process.env.NODE_ENV !== 'production') {\n  var REACT_ELEMENT_TYPE = (typeof Symbol === 'function' &&\n    Symbol.for &&\n    Symbol.for('react.element')) ||\n    0xeac7;\n\n  var isValidElement = function(object) {\n    return typeof object === 'object' &&\n      object !== null &&\n      object.$$typeof === REACT_ELEMENT_TYPE;\n  };\n\n  // By explicitly using `prop-types` you are opting into new development behavior.\n  // http://fb.me/prop-types-in-prod\n  var throwOnDirectAccess = true;\n  module.exports = require('./factoryWithTypeCheckers')(isValidElement, throwOnDirectAccess);\n} else {\n  // By explicitly using `prop-types` you are opting into new production behavior.\n  // http://fb.me/prop-types-in-prod\n  module.exports = require('./factoryWithThrowingShims')();\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/prop-types/index.js\n// module id = 35\n// module chunks = 0","/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nvar emptyFunction = require('fbjs/lib/emptyFunction');\nvar invariant = require('fbjs/lib/invariant');\nvar warning = require('fbjs/lib/warning');\nvar assign = require('object-assign');\n\nvar ReactPropTypesSecret = require('./lib/ReactPropTypesSecret');\nvar checkPropTypes = require('./checkPropTypes');\n\nmodule.exports = function(isValidElement, throwOnDirectAccess) {\n  /* global Symbol */\n  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\n  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.\n\n  /**\n   * Returns the iterator method function contained on the iterable object.\n   *\n   * Be sure to invoke the function with the iterable as context:\n   *\n   *     var iteratorFn = getIteratorFn(myIterable);\n   *     if (iteratorFn) {\n   *       var iterator = iteratorFn.call(myIterable);\n   *       ...\n   *     }\n   *\n   * @param {?object} maybeIterable\n   * @return {?function}\n   */\n  function getIteratorFn(maybeIterable) {\n    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);\n    if (typeof iteratorFn === 'function') {\n      return iteratorFn;\n    }\n  }\n\n  /**\n   * Collection of methods that allow declaration and validation of props that are\n   * supplied to React components. Example usage:\n   *\n   *   var Props = require('ReactPropTypes');\n   *   var MyArticle = React.createClass({\n   *     propTypes: {\n   *       // An optional string prop named \"description\".\n   *       description: Props.string,\n   *\n   *       // A required enum prop named \"category\".\n   *       category: Props.oneOf(['News','Photos']).isRequired,\n   *\n   *       // A prop named \"dialog\" that requires an instance of Dialog.\n   *       dialog: Props.instanceOf(Dialog).isRequired\n   *     },\n   *     render: function() { ... }\n   *   });\n   *\n   * A more formal specification of how these methods are used:\n   *\n   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)\n   *   decl := ReactPropTypes.{type}(.isRequired)?\n   *\n   * Each and every declaration produces a function with the same signature. This\n   * allows the creation of custom validation functions. For example:\n   *\n   *  var MyLink = React.createClass({\n   *    propTypes: {\n   *      // An optional string or URI prop named \"href\".\n   *      href: function(props, propName, componentName) {\n   *        var propValue = props[propName];\n   *        if (propValue != null && typeof propValue !== 'string' &&\n   *            !(propValue instanceof URI)) {\n   *          return new Error(\n   *            'Expected a string or an URI for ' + propName + ' in ' +\n   *            componentName\n   *          );\n   *        }\n   *      }\n   *    },\n   *    render: function() {...}\n   *  });\n   *\n   * @internal\n   */\n\n  var ANONYMOUS = '<<anonymous>>';\n\n  // Important!\n  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.\n  var ReactPropTypes = {\n    array: createPrimitiveTypeChecker('array'),\n    bool: createPrimitiveTypeChecker('boolean'),\n    func: createPrimitiveTypeChecker('function'),\n    number: createPrimitiveTypeChecker('number'),\n    object: createPrimitiveTypeChecker('object'),\n    string: createPrimitiveTypeChecker('string'),\n    symbol: createPrimitiveTypeChecker('symbol'),\n\n    any: createAnyTypeChecker(),\n    arrayOf: createArrayOfTypeChecker,\n    element: createElementTypeChecker(),\n    instanceOf: createInstanceTypeChecker,\n    node: createNodeChecker(),\n    objectOf: createObjectOfTypeChecker,\n    oneOf: createEnumTypeChecker,\n    oneOfType: createUnionTypeChecker,\n    shape: createShapeTypeChecker,\n    exact: createStrictShapeTypeChecker,\n  };\n\n  /**\n   * inlined Object.is polyfill to avoid requiring consumers ship their own\n   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n   */\n  /*eslint-disable no-self-compare*/\n  function is(x, y) {\n    // SameValue algorithm\n    if (x === y) {\n      // Steps 1-5, 7-10\n      // Steps 6.b-6.e: +0 != -0\n      return x !== 0 || 1 / x === 1 / y;\n    } else {\n      // Step 6.a: NaN == NaN\n      return x !== x && y !== y;\n    }\n  }\n  /*eslint-enable no-self-compare*/\n\n  /**\n   * We use an Error-like object for backward compatibility as people may call\n   * PropTypes directly and inspect their output. However, we don't use real\n   * Errors anymore. We don't inspect their stack anyway, and creating them\n   * is prohibitively expensive if they are created too often, such as what\n   * happens in oneOfType() for any type before the one that matched.\n   */\n  function PropTypeError(message) {\n    this.message = message;\n    this.stack = '';\n  }\n  // Make `instanceof Error` still work for returned errors.\n  PropTypeError.prototype = Error.prototype;\n\n  function createChainableTypeChecker(validate) {\n    if (process.env.NODE_ENV !== 'production') {\n      var manualPropTypeCallCache = {};\n      var manualPropTypeWarningCount = 0;\n    }\n    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {\n      componentName = componentName || ANONYMOUS;\n      propFullName = propFullName || propName;\n\n      if (secret !== ReactPropTypesSecret) {\n        if (throwOnDirectAccess) {\n          // New behavior only for users of `prop-types` package\n          invariant(\n            false,\n            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +\n            'Use `PropTypes.checkPropTypes()` to call them. ' +\n            'Read more at http://fb.me/use-check-prop-types'\n          );\n        } else if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined') {\n          // Old behavior for people using React.PropTypes\n          var cacheKey = componentName + ':' + propName;\n          if (\n            !manualPropTypeCallCache[cacheKey] &&\n            // Avoid spamming the console because they are often not actionable except for lib authors\n            manualPropTypeWarningCount < 3\n          ) {\n            warning(\n              false,\n              'You are manually calling a React.PropTypes validation ' +\n              'function for the `%s` prop on `%s`. This is deprecated ' +\n              'and will throw in the standalone `prop-types` package. ' +\n              'You may be seeing this warning due to a third-party PropTypes ' +\n              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.',\n              propFullName,\n              componentName\n            );\n            manualPropTypeCallCache[cacheKey] = true;\n            manualPropTypeWarningCount++;\n          }\n        }\n      }\n      if (props[propName] == null) {\n        if (isRequired) {\n          if (props[propName] === null) {\n            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));\n          }\n          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));\n        }\n        return null;\n      } else {\n        return validate(props, propName, componentName, location, propFullName);\n      }\n    }\n\n    var chainedCheckType = checkType.bind(null, false);\n    chainedCheckType.isRequired = checkType.bind(null, true);\n\n    return chainedCheckType;\n  }\n\n  function createPrimitiveTypeChecker(expectedType) {\n    function validate(props, propName, componentName, location, propFullName, secret) {\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== expectedType) {\n        // `propValue` being instance of, say, date/regexp, pass the 'object'\n        // check, but we can offer a more precise error message here rather than\n        // 'of type `object`'.\n        var preciseType = getPreciseType(propValue);\n\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createAnyTypeChecker() {\n    return createChainableTypeChecker(emptyFunction.thatReturnsNull);\n  }\n\n  function createArrayOfTypeChecker(typeChecker) {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (typeof typeChecker !== 'function') {\n        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');\n      }\n      var propValue = props[propName];\n      if (!Array.isArray(propValue)) {\n        var propType = getPropType(propValue);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));\n      }\n      for (var i = 0; i < propValue.length; i++) {\n        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);\n        if (error instanceof Error) {\n          return error;\n        }\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createElementTypeChecker() {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      if (!isValidElement(propValue)) {\n        var propType = getPropType(propValue);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createInstanceTypeChecker(expectedClass) {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (!(props[propName] instanceof expectedClass)) {\n        var expectedClassName = expectedClass.name || ANONYMOUS;\n        var actualClassName = getClassName(props[propName]);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createEnumTypeChecker(expectedValues) {\n    if (!Array.isArray(expectedValues)) {\n      process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOf, expected an instance of array.') : void 0;\n      return emptyFunction.thatReturnsNull;\n    }\n\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      for (var i = 0; i < expectedValues.length; i++) {\n        if (is(propValue, expectedValues[i])) {\n          return null;\n        }\n      }\n\n      var valuesString = JSON.stringify(expectedValues);\n      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createObjectOfTypeChecker(typeChecker) {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (typeof typeChecker !== 'function') {\n        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');\n      }\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== 'object') {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));\n      }\n      for (var key in propValue) {\n        if (propValue.hasOwnProperty(key)) {\n          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\n          if (error instanceof Error) {\n            return error;\n          }\n        }\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createUnionTypeChecker(arrayOfTypeCheckers) {\n    if (!Array.isArray(arrayOfTypeCheckers)) {\n      process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;\n      return emptyFunction.thatReturnsNull;\n    }\n\n    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {\n      var checker = arrayOfTypeCheckers[i];\n      if (typeof checker !== 'function') {\n        warning(\n          false,\n          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +\n          'received %s at index %s.',\n          getPostfixForTypeWarning(checker),\n          i\n        );\n        return emptyFunction.thatReturnsNull;\n      }\n    }\n\n    function validate(props, propName, componentName, location, propFullName) {\n      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {\n        var checker = arrayOfTypeCheckers[i];\n        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {\n          return null;\n        }\n      }\n\n      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createNodeChecker() {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (!isNode(props[propName])) {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createShapeTypeChecker(shapeTypes) {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== 'object') {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));\n      }\n      for (var key in shapeTypes) {\n        var checker = shapeTypes[key];\n        if (!checker) {\n          continue;\n        }\n        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\n        if (error) {\n          return error;\n        }\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createStrictShapeTypeChecker(shapeTypes) {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== 'object') {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));\n      }\n      // We need to check all keys in case some are required but missing from\n      // props.\n      var allKeys = assign({}, props[propName], shapeTypes);\n      for (var key in allKeys) {\n        var checker = shapeTypes[key];\n        if (!checker) {\n          return new PropTypeError(\n            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +\n            '\\nBad object: ' + JSON.stringify(props[propName], null, '  ') +\n            '\\nValid keys: ' +  JSON.stringify(Object.keys(shapeTypes), null, '  ')\n          );\n        }\n        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\n        if (error) {\n          return error;\n        }\n      }\n      return null;\n    }\n\n    return createChainableTypeChecker(validate);\n  }\n\n  function isNode(propValue) {\n    switch (typeof propValue) {\n      case 'number':\n      case 'string':\n      case 'undefined':\n        return true;\n      case 'boolean':\n        return !propValue;\n      case 'object':\n        if (Array.isArray(propValue)) {\n          return propValue.every(isNode);\n        }\n        if (propValue === null || isValidElement(propValue)) {\n          return true;\n        }\n\n        var iteratorFn = getIteratorFn(propValue);\n        if (iteratorFn) {\n          var iterator = iteratorFn.call(propValue);\n          var step;\n          if (iteratorFn !== propValue.entries) {\n            while (!(step = iterator.next()).done) {\n              if (!isNode(step.value)) {\n                return false;\n              }\n            }\n          } else {\n            // Iterator will provide entry [k,v] tuples rather than values.\n            while (!(step = iterator.next()).done) {\n              var entry = step.value;\n              if (entry) {\n                if (!isNode(entry[1])) {\n                  return false;\n                }\n              }\n            }\n          }\n        } else {\n          return false;\n        }\n\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  function isSymbol(propType, propValue) {\n    // Native Symbol.\n    if (propType === 'symbol') {\n      return true;\n    }\n\n    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'\n    if (propValue['@@toStringTag'] === 'Symbol') {\n      return true;\n    }\n\n    // Fallback for non-spec compliant Symbols which are polyfilled.\n    if (typeof Symbol === 'function' && propValue instanceof Symbol) {\n      return true;\n    }\n\n    return false;\n  }\n\n  // Equivalent of `typeof` but with special handling for array and regexp.\n  function getPropType(propValue) {\n    var propType = typeof propValue;\n    if (Array.isArray(propValue)) {\n      return 'array';\n    }\n    if (propValue instanceof RegExp) {\n      // Old webkits (at least until Android 4.0) return 'function' rather than\n      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/\n      // passes PropTypes.object.\n      return 'object';\n    }\n    if (isSymbol(propType, propValue)) {\n      return 'symbol';\n    }\n    return propType;\n  }\n\n  // This handles more types than `getPropType`. Only used for error messages.\n  // See `createPrimitiveTypeChecker`.\n  function getPreciseType(propValue) {\n    if (typeof propValue === 'undefined' || propValue === null) {\n      return '' + propValue;\n    }\n    var propType = getPropType(propValue);\n    if (propType === 'object') {\n      if (propValue instanceof Date) {\n        return 'date';\n      } else if (propValue instanceof RegExp) {\n        return 'regexp';\n      }\n    }\n    return propType;\n  }\n\n  // Returns a string that is postfixed to a warning about an invalid type.\n  // For example, \"undefined\" or \"of type array\"\n  function getPostfixForTypeWarning(value) {\n    var type = getPreciseType(value);\n    switch (type) {\n      case 'array':\n      case 'object':\n        return 'an ' + type;\n      case 'boolean':\n      case 'date':\n      case 'regexp':\n        return 'a ' + type;\n      default:\n        return type;\n    }\n  }\n\n  // Returns class name of the object, if any.\n  function getClassName(propValue) {\n    if (!propValue.constructor || !propValue.constructor.name) {\n      return ANONYMOUS;\n    }\n    return propValue.constructor.name;\n  }\n\n  ReactPropTypes.checkPropTypes = checkPropTypes;\n  ReactPropTypes.PropTypes = ReactPropTypes;\n\n  return ReactPropTypes;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/prop-types/factoryWithTypeCheckers.js\n// module id = 36\n// module chunks = 0","/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\n\n'use strict';\n/* eslint-disable no-unused-vars */\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n\tif (val === null || val === undefined) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nfunction shouldUseNative() {\n\ttry {\n\t\tif (!Object.assign) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Detect buggy property enumeration order in older V8 versions.\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\t\tvar test1 = new String('abc');  // eslint-disable-line no-new-wrappers\n\t\ttest1[5] = 'de';\n\t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test2 = {};\n\t\tfor (var i = 0; i < 10; i++) {\n\t\t\ttest2['_' + String.fromCharCode(i)] = i;\n\t\t}\n\t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n\t\t\treturn test2[n];\n\t\t});\n\t\tif (order2.join('') !== '0123456789') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test3 = {};\n\t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n\t\t\ttest3[letter] = letter;\n\t\t});\n\t\tif (Object.keys(Object.assign({}, test3)).join('') !==\n\t\t\t\t'abcdefghijklmnopqrst') {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t} catch (err) {\n\t\t// We don't expect any of the above to throw, but better to be safe.\n\t\treturn false;\n\t}\n}\n\nmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\n\tvar from;\n\tvar to = toObject(target);\n\tvar symbols;\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = Object(arguments[s]);\n\n\t\tfor (var key in from) {\n\t\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\t\tto[key] = from[key];\n\t\t\t}\n\t\t}\n\n\t\tif (getOwnPropertySymbols) {\n\t\t\tsymbols = getOwnPropertySymbols(from);\n\t\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/object-assign/index.js\n// module id = 37\n// module chunks = 0","/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nif (process.env.NODE_ENV !== 'production') {\n  var invariant = require('fbjs/lib/invariant');\n  var warning = require('fbjs/lib/warning');\n  var ReactPropTypesSecret = require('./lib/ReactPropTypesSecret');\n  var loggedTypeFailures = {};\n}\n\n/**\n * Assert that the values match with the type specs.\n * Error messages are memorized and will only be shown once.\n *\n * @param {object} typeSpecs Map of name to a ReactPropType\n * @param {object} values Runtime values that need to be type-checked\n * @param {string} location e.g. \"prop\", \"context\", \"child context\"\n * @param {string} componentName Name of the component for error messages.\n * @param {?Function} getStack Returns the component stack.\n * @private\n */\nfunction checkPropTypes(typeSpecs, values, location, componentName, getStack) {\n  if (process.env.NODE_ENV !== 'production') {\n    for (var typeSpecName in typeSpecs) {\n      if (typeSpecs.hasOwnProperty(typeSpecName)) {\n        var error;\n        // Prop type validation may throw. In case they do, we don't want to\n        // fail the render phase where it didn't fail before. So we log it.\n        // After these have been cleaned up, we'll let them throw.\n        try {\n          // This is intentionally an invariant that gets caught. It's the same\n          // behavior as without this statement except with a better message.\n          invariant(typeof typeSpecs[typeSpecName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'the `prop-types` package, but received `%s`.', componentName || 'React class', location, typeSpecName, typeof typeSpecs[typeSpecName]);\n          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);\n        } catch (ex) {\n          error = ex;\n        }\n        warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error);\n        if (error instanceof Error && !(error.message in loggedTypeFailures)) {\n          // Only monitor this failure once because there tends to be a lot of the\n          // same error.\n          loggedTypeFailures[error.message] = true;\n\n          var stack = getStack ? getStack() : '';\n\n          warning(false, 'Failed %s type: %s%s', location, error.message, stack != null ? stack : '');\n        }\n      }\n    }\n  }\n}\n\nmodule.exports = checkPropTypes;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/prop-types/checkPropTypes.js\n// module id = 38\n// module chunks = 0","/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nvar emptyFunction = require('fbjs/lib/emptyFunction');\nvar invariant = require('fbjs/lib/invariant');\nvar ReactPropTypesSecret = require('./lib/ReactPropTypesSecret');\n\nmodule.exports = function() {\n  function shim(props, propName, componentName, location, propFullName, secret) {\n    if (secret === ReactPropTypesSecret) {\n      // It is still safe when called from React.\n      return;\n    }\n    invariant(\n      false,\n      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +\n      'Use PropTypes.checkPropTypes() to call them. ' +\n      'Read more at http://fb.me/use-check-prop-types'\n    );\n  };\n  shim.isRequired = shim;\n  function getShim() {\n    return shim;\n  };\n  // Important!\n  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.\n  var ReactPropTypes = {\n    array: shim,\n    bool: shim,\n    func: shim,\n    number: shim,\n    object: shim,\n    string: shim,\n    symbol: shim,\n\n    any: shim,\n    arrayOf: getShim,\n    element: shim,\n    instanceOf: getShim,\n    node: shim,\n    objectOf: getShim,\n    oneOf: getShim,\n    oneOfType: getShim,\n    shape: getShim,\n    exact: getShim\n  };\n\n  ReactPropTypes.checkPropTypes = emptyFunction;\n  ReactPropTypes.PropTypes = ReactPropTypes;\n\n  return ReactPropTypes;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/prop-types/factoryWithThrowingShims.js\n// module id = 39\n// module chunks = 0","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.checkedIcon = exports.uncheckedIcon = undefined;\n\nvar _react = require(\"react\");\n\nvar _react2 = _interopRequireDefault(_react);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar uncheckedIcon = exports.uncheckedIcon = _react2.default.createElement(\n  \"svg\",\n  {\n    viewBox: \"-2 -5 14 20\",\n    height: \"100%\",\n    width: \"100%\",\n    style: { position: \"absolute\", top: 0 }\n  },\n  _react2.default.createElement(\"path\", {\n    /* eslint-disable max-len */\n    d: \"M9.9 2.12L7.78 0 4.95 2.828 2.12 0 0 2.12l2.83 2.83L0 7.776 2.123 9.9 4.95 7.07 7.78 9.9 9.9 7.776 7.072 4.95 9.9 2.12\"\n    /* eslint-eable max-len */\n    , fill: \"#fff\",\n    fillRule: \"evenodd\"\n  })\n); /*\n   The MIT License (MIT)\n   \n   Copyright (c) 2015 instructure-react\n   \n   Permission is hereby granted, free of charge, to any person obtaining a copy\n   of this software and associated documentation files (the \"Software\"), to deal\n   in the Software without restriction, including without limitation the rights\n   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n   copies of the Software, and to permit persons to whom the Software is\n   furnished to do so, subject to the following conditions:\n   \n   The above copyright notice and this permission notice shall be included in all\n   copies or substantial portions of the Software.\n   \n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   SOFTWARE.\n   */\n\nvar checkedIcon = exports.checkedIcon = _react2.default.createElement(\n  \"svg\",\n  {\n    height: \"100%\",\n    width: \"100%\",\n    viewBox: \"-2 -5 17 21\",\n    style: { position: \"absolute\", top: 0 }\n  },\n  _react2.default.createElement(\"path\", {\n    d: \"M11.264 0L5.26 6.004 2.103 2.847 0 4.95l5.26 5.26 8.108-8.107L11.264 0\",\n    fill: \"#fff\",\n    fillRule: \"evenodd\"\n  })\n);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/react-switch/dist/icons.js\n// module id = 40\n// module chunks = 0","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = getBackgroundColor;\nfunction createBackgroundColor(pos, checkedPos, uncheckedPos, offColor, onColor) {\n  var relativePos = (pos - uncheckedPos) / (checkedPos - uncheckedPos);\n  if (relativePos === 0) {\n    return offColor;\n  }\n  if (relativePos === 1) {\n    return onColor;\n  }\n\n  var newColor = \"#\";\n  for (var i = 1; i < 6; i += 2) {\n    var offComponent = parseInt(offColor.substr(i, 2), 16);\n    var onComponent = parseInt(onColor.substr(i, 2), 16);\n    var weightedValue = Math.round((1 - relativePos) * offComponent + relativePos * onComponent);\n    var newComponent = weightedValue.toString(16);\n    if (newComponent.length === 1) {\n      newComponent = \"0\" + newComponent;\n    }\n    newColor += newComponent;\n  }\n  return newColor;\n}\n\nfunction convertShorthandColor(color) {\n  if (color.length === 7) {\n    return color;\n  }\n  var sixDigitColor = \"#\";\n  for (var i = 1; i < 4; i += 1) {\n    sixDigitColor += color[i] + color[i];\n  }\n  return sixDigitColor;\n}\n\nfunction getBackgroundColor(pos, checkedPos, uncheckedPos, offColor, onColor) {\n  var sixDigitOffColor = convertShorthandColor(offColor);\n  var sixDigitOnColor = convertShorthandColor(onColor);\n  return createBackgroundColor(pos, checkedPos, uncheckedPos, sixDigitOffColor, sixDigitOnColor);\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/react-switch/dist/getBackgroundColor.js\n// module id = 41\n// module chunks = 0","module.exports = require(\"electron\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"electron\"\n// module id = 42\n// module chunks = 0","module.exports = require(\"url\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"url\"\n// module id = 43\n// module chunks = 0","import * as ShareDBClient from 'sharedb/lib/client';\nimport * as ShareDB from 'sharedb';\nimport * as stream from 'stream';\n\ntype DocIdentifier = [string,string];\n\nexport class SDB {\n    private docs:Map<DocIdentifier, SDBDoc<any>> = new Map<DocIdentifier, SDBDoc<any>>();\n    private share:ShareDB|ShareDBClient;\n    private connection:ShareDB.Connection;\n    constructor(client:boolean, connection?:WebSocket) {\n        if(client) {\n            this.connection = new ShareDBClient.Connection(connection);\n        } else {\n            this.share = new ShareDB();\n            this.connection = this.share.connect();\n        }\n    };\n    private getDocIdentifier(collectionName:string, documentID:string):DocIdentifier {\n        return [collectionName, documentID];\n    };\n\n    public listen(stream:stream.Duplex):void {\n        this.share.listen(stream);\n    };\n\n    public get<E>(collectionName:string, documentID:string):SDBDoc<E> {\n        const docIdentifier:DocIdentifier = this.getDocIdentifier(collectionName, documentID);\n        let sdbDoc:SDBDoc<E>;\n        if(this.docs.has(docIdentifier)) {\n            sdbDoc = this.docs.get(docIdentifier);\n        } else {\n            const doc:ShareDB.Doc<E> = this.connection.get(collectionName, documentID);\n            sdbDoc = new SDBDoc<E>(docIdentifier, doc, this);\n            this.docs.set(docIdentifier, sdbDoc);\n        }\n        return sdbDoc;\n    };\n\n    public async close():Promise<void> {\n        await new Promise((resolve, reject) => {\n            this.share.close(()=> {\n                resolve(null);\n            });\n        });\n    };\n\n    public deleteDoc(doc:SDBDoc<any>):void {\n        this.docs.delete(doc.docIdentifier);\n    };\n};\n\nexport class SDBDoc<E> {\n    constructor(public docIdentifier:DocIdentifier, private doc:ShareDB.Doc<E>, private sdb:SDB) {\n    };\n    public async fetch():Promise<ShareDB.Doc<E>> {\n        return new Promise<ShareDB.Doc<E>>((resolve, reject) => {\n            this.doc.fetch((err) => {\n                if(err) {\n                    reject(err);\n                } else {\n                    resolve(this.doc);\n                }\n            });\n        });\n    };\n    public async create(data:E, type?:ShareDB.OTType, options?:ShareDB.ShareDBCreateOptions):Promise<ShareDB.Doc<E>> {\n        return new Promise<ShareDB.Doc<E>>((resolve, reject) => {\n            this.doc.create(data, type, options, () => {\n                resolve(this.doc);\n            });\n        });\n    };\n    public async del(source:boolean=true):Promise<void> {\n        await new Promise<void>((resolve, reject) => {\n            this.doc.del({source}, (err) => {\n                if(err) { reject(err); }\n                else { resolve(); }\n            });\n        });\n        this.sdb.deleteDoc(this);\n    };\n    public subscribe(callback:(op:ShareDB.Op, source:boolean, data:E)=>void):()=>void {\n        this.doc.subscribe((err) => {\n            if(err) { throw(err); }\n            callback(null, null, this.doc.data);\n        });\n        const onOpFunc = (op:ShareDB.Op, source:boolean) => {\n            callback(op, source, this.doc.data);\n        };\n        this.doc.on('op', onOpFunc);\n        return () => {\n            this.doc.removeListener('op', onOpFunc);\n        };\n    };\n    public async submitOp(op:Array<ShareDB.Op>, source:boolean=true):Promise<void> {\n        await new Promise<void>((resolve, reject) => {\n            this.doc.submitOp(op, {source}, (err) => {\n                if(err) {reject(err);}\n                else {resolve();}\n            });\n        });\n    };\n    public async createIfEmpty(data:E, type?:ShareDB.OTType, options?:ShareDB.ShareDBCreateOptions):Promise<ShareDB.Doc<E>> {\n        const doc:ShareDB.Doc<E> = await this.fetch();\n        if(doc.type === null) {\n            return this.create(data, type, options);\n        } else {\n            return doc;\n        }\n    };\n    public getData():E {\n        return this.doc.data;\n    };\n    public destroy():void {\n        this.doc.destroy();\n        this.sdb.deleteDoc(this);\n    };\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils/sharedb_wrapper.ts","exports.Connection = require('./connection');\nexports.Doc = require('./doc');\nexports.Error = require('../error');\nexports.Query = require('./query');\nexports.types = require('../types');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/sharedb/lib/client/index.js\n// module id = 45\n// module chunks = 0","module.exports = require(\"events\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"events\"\n// module id = 46\n// module chunks = 0","// ISC @ Julien Fontanet\n\n'use strict'\n\n// ===================================================================\n\nvar defineProperty = Object.defineProperty\n\n// -------------------------------------------------------------------\n\nvar captureStackTrace = Error.captureStackTrace\nif (!captureStackTrace) {\n  captureStackTrace = function captureStackTrace (error) {\n    var container = new Error()\n\n    defineProperty(error, 'stack', {\n      configurable: true,\n      get: function getStack () {\n        var stack = container.stack\n\n        // Replace property with value for faster future accesses.\n        defineProperty(this, 'stack', {\n          value: stack\n        })\n\n        return stack\n      },\n      set: function setStack (stack) {\n        defineProperty(error, 'stack', {\n          configurable: true,\n          value: stack,\n          writable: true\n        })\n      }\n    })\n  }\n}\n\n// -------------------------------------------------------------------\n\nfunction BaseError (message) {\n  if (message) {\n    defineProperty(this, 'message', {\n      configurable: true,\n      value: message,\n      writable: true\n    })\n  }\n\n  var cname = this.constructor.name\n  if (\n    cname &&\n    cname !== this.name\n  ) {\n    defineProperty(this, 'name', {\n      configurable: true,\n      value: cname,\n      writable: true\n    })\n  }\n\n  captureStackTrace(this, this.constructor)\n}\n\nBaseError.prototype = Object.create(Error.prototype, {\n  // See: https://github.com/JsCommunity/make-error/issues/4\n  constructor: {\n    configurable: true,\n    value: BaseError,\n    writable: true\n  }\n})\n\n// -------------------------------------------------------------------\n\n// Sets the name of a function if possible (depends of the JS engine).\nvar setFunctionName = (function () {\n  function setFunctionName (fn, name) {\n    return defineProperty(fn, 'name', {\n      configurable: true,\n      value: name\n    })\n  }\n  try {\n    var f = function () {}\n    setFunctionName(f, 'foo')\n    if (f.name === 'foo') {\n      return setFunctionName\n    }\n  } catch (_) {}\n})()\n\n// -------------------------------------------------------------------\n\nfunction makeError (constructor, super_) {\n  if (super_ == null || super_ === Error) {\n    super_ = BaseError\n  } else if (typeof super_ !== 'function') {\n    throw new TypeError('super_ should be a function')\n  }\n\n  var name\n  if (typeof constructor === 'string') {\n    name = constructor\n    constructor = function () { super_.apply(this, arguments) }\n\n    // If the name can be set, do it once and for all.\n    if (setFunctionName) {\n      setFunctionName(constructor, name)\n      name = null\n    }\n  } else if (typeof constructor !== 'function') {\n    throw new TypeError('constructor should be either a string or a function')\n  }\n\n  // Also register the super constructor also as `constructor.super_` just\n  // like Node's `util.inherits()`.\n  constructor.super_ = constructor['super'] = super_\n\n  var properties = {\n    constructor: {\n      configurable: true,\n      value: constructor,\n      writable: true\n    }\n  }\n\n  // If the name could not be set on the constructor, set it on the\n  // prototype.\n  if (name != null) {\n    properties.name = {\n      configurable: true,\n      value: name,\n      writable: true\n    }\n  }\n  constructor.prototype = Object.create(super_.prototype, properties)\n\n  return constructor\n}\nexports = module.exports = makeError\nexports.BaseError = BaseError\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/make-error/index.js\n// module id = 47\n// module chunks = 0","/*\n This is the implementation of the JSON OT type.\n\n Spec is here: https://github.com/josephg/ShareJS/wiki/JSON-Operations\n\n Note: This is being made obsolete. It will soon be replaced by the JSON2 type.\n*/\n\n/**\n * UTILITY FUNCTIONS\n */\n\n/**\n * Checks if the passed object is an Array instance. Can't use Array.isArray\n * yet because its not supported on IE8.\n *\n * @param obj\n * @returns {boolean}\n */\nvar isArray = function(obj) {\n  return Object.prototype.toString.call(obj) == '[object Array]';\n};\n\n/**\n * Checks if the passed object is an Object instance.\n * No function call (fast) version\n *\n * @param obj\n * @returns {boolean}\n */\nvar isObject = function(obj) {\n  return (!!obj) && (obj.constructor === Object);\n};\n\n/**\n * Clones the passed object using JSON serialization (which is slow).\n *\n * hax, copied from test/types/json. Apparently this is still the fastest way\n * to deep clone an object, assuming we have browser support for JSON.  @see\n * http://jsperf.com/cloning-an-object/12\n */\nvar clone = function(o) {\n  return JSON.parse(JSON.stringify(o));\n};\n\n/**\n * JSON OT Type\n * @type {*}\n */\nvar json = {\n  name: 'json0',\n  uri: 'http://sharejs.org/types/JSONv0'\n};\n\n// You can register another OT type as a subtype in a JSON document using\n// the following function. This allows another type to handle certain\n// operations instead of the builtin JSON type.\nvar subtypes = {};\njson.registerSubtype = function(subtype) {\n  subtypes[subtype.name] = subtype;\n};\n\njson.create = function(data) {\n  // Null instead of undefined if you don't pass an argument.\n  return data === undefined ? null : clone(data);\n};\n\njson.invertComponent = function(c) {\n  var c_ = {p: c.p};\n\n  // handle subtype ops\n  if (c.t && subtypes[c.t]) {\n    c_.t = c.t;\n    c_.o = subtypes[c.t].invert(c.o);\n  }\n\n  if (c.si !== void 0) c_.sd = c.si;\n  if (c.sd !== void 0) c_.si = c.sd;\n  if (c.oi !== void 0) c_.od = c.oi;\n  if (c.od !== void 0) c_.oi = c.od;\n  if (c.li !== void 0) c_.ld = c.li;\n  if (c.ld !== void 0) c_.li = c.ld;\n  if (c.na !== void 0) c_.na = -c.na;\n\n  if (c.lm !== void 0) {\n    c_.lm = c.p[c.p.length-1];\n    c_.p = c.p.slice(0,c.p.length-1).concat([c.lm]);\n  }\n\n  return c_;\n};\n\njson.invert = function(op) {\n  var op_ = op.slice().reverse();\n  var iop = [];\n  for (var i = 0; i < op_.length; i++) {\n    iop.push(json.invertComponent(op_[i]));\n  }\n  return iop;\n};\n\njson.checkValidOp = function(op) {\n  for (var i = 0; i < op.length; i++) {\n    if (!isArray(op[i].p)) throw new Error('Missing path');\n  }\n};\n\njson.checkList = function(elem) {\n  if (!isArray(elem))\n    throw new Error('Referenced element not a list');\n};\n\njson.checkObj = function(elem) {\n  if (!isObject(elem)) {\n    throw new Error(\"Referenced element not an object (it was \" + JSON.stringify(elem) + \")\");\n  }\n};\n\n// helper functions to convert old string ops to and from subtype ops\nfunction convertFromText(c) {\n  c.t = 'text0';\n  var o = {p: c.p.pop()};\n  if (c.si != null) o.i = c.si;\n  if (c.sd != null) o.d = c.sd;\n  c.o = [o];\n}\n\nfunction convertToText(c) {\n  c.p.push(c.o[0].p);\n  if (c.o[0].i != null) c.si = c.o[0].i;\n  if (c.o[0].d != null) c.sd = c.o[0].d;\n  delete c.t;\n  delete c.o;\n}\n\njson.apply = function(snapshot, op) {\n  json.checkValidOp(op);\n\n  op = clone(op);\n\n  var container = {\n    data: snapshot\n  };\n\n  for (var i = 0; i < op.length; i++) {\n    var c = op[i];\n\n    // convert old string ops to use subtype for backwards compatibility\n    if (c.si != null || c.sd != null)\n      convertFromText(c);\n\n    var parent = null;\n    var parentKey = null;\n    var elem = container;\n    var key = 'data';\n\n    for (var j = 0; j < c.p.length; j++) {\n      var p = c.p[j];\n\n      parent = elem;\n      parentKey = key;\n      elem = elem[key];\n      key = p;\n\n      if (parent == null)\n        throw new Error('Path invalid');\n    }\n\n    // handle subtype ops\n    if (c.t && c.o !== void 0 && subtypes[c.t]) {\n      elem[key] = subtypes[c.t].apply(elem[key], c.o);\n\n    // Number add\n    } else if (c.na !== void 0) {\n      if (typeof elem[key] != 'number')\n        throw new Error('Referenced element not a number');\n\n      elem[key] += c.na;\n    }\n\n    // List replace\n    else if (c.li !== void 0 && c.ld !== void 0) {\n      json.checkList(elem);\n      // Should check the list element matches c.ld\n      elem[key] = c.li;\n    }\n\n    // List insert\n    else if (c.li !== void 0) {\n      json.checkList(elem);\n      elem.splice(key,0, c.li);\n    }\n\n    // List delete\n    else if (c.ld !== void 0) {\n      json.checkList(elem);\n      // Should check the list element matches c.ld here too.\n      elem.splice(key,1);\n    }\n\n    // List move\n    else if (c.lm !== void 0) {\n      json.checkList(elem);\n      if (c.lm != key) {\n        var e = elem[key];\n        // Remove it...\n        elem.splice(key,1);\n        // And insert it back.\n        elem.splice(c.lm,0,e);\n      }\n    }\n\n    // Object insert / replace\n    else if (c.oi !== void 0) {\n      json.checkObj(elem);\n\n      // Should check that elem[key] == c.od\n      elem[key] = c.oi;\n    }\n\n    // Object delete\n    else if (c.od !== void 0) {\n      json.checkObj(elem);\n\n      // Should check that elem[key] == c.od\n      delete elem[key];\n    }\n\n    else {\n      throw new Error('invalid / missing instruction in op');\n    }\n  }\n\n  return container.data;\n};\n\n// Helper to break an operation up into a bunch of small ops.\njson.shatter = function(op) {\n  var results = [];\n  for (var i = 0; i < op.length; i++) {\n    results.push([op[i]]);\n  }\n  return results;\n};\n\n// Helper for incrementally applying an operation to a snapshot. Calls yield\n// after each op component has been applied.\njson.incrementalApply = function(snapshot, op, _yield) {\n  for (var i = 0; i < op.length; i++) {\n    var smallOp = [op[i]];\n    snapshot = json.apply(snapshot, smallOp);\n    // I'd just call this yield, but thats a reserved keyword. Bah!\n    _yield(smallOp, snapshot);\n  }\n\n  return snapshot;\n};\n\n// Checks if two paths, p1 and p2 match.\nvar pathMatches = json.pathMatches = function(p1, p2, ignoreLast) {\n  if (p1.length != p2.length)\n    return false;\n\n  for (var i = 0; i < p1.length; i++) {\n    if (p1[i] !== p2[i] && (!ignoreLast || i !== p1.length - 1))\n      return false;\n  }\n\n  return true;\n};\n\njson.append = function(dest,c) {\n  c = clone(c);\n\n  if (dest.length === 0) {\n    dest.push(c);\n    return;\n  }\n\n  var last = dest[dest.length - 1];\n\n  // convert old string ops to use subtype for backwards compatibility\n  if ((c.si != null || c.sd != null) && (last.si != null || last.sd != null)) {\n    convertFromText(c);\n    convertFromText(last);\n  }\n\n  if (pathMatches(c.p, last.p)) {\n    // handle subtype ops\n    if (c.t && last.t && c.t === last.t && subtypes[c.t]) {\n      last.o = subtypes[c.t].compose(last.o, c.o);\n\n      // convert back to old string ops\n      if (c.si != null || c.sd != null) {\n        var p = c.p;\n        for (var i = 0; i < last.o.length - 1; i++) {\n          c.o = [last.o.pop()];\n          c.p = p.slice();\n          convertToText(c);\n          dest.push(c);\n        }\n\n        convertToText(last);\n      }\n    } else if (last.na != null && c.na != null) {\n      dest[dest.length - 1] = {p: last.p, na: last.na + c.na};\n    } else if (last.li !== undefined && c.li === undefined && c.ld === last.li) {\n      // insert immediately followed by delete becomes a noop.\n      if (last.ld !== undefined) {\n        // leave the delete part of the replace\n        delete last.li;\n      } else {\n        dest.pop();\n      }\n    } else if (last.od !== undefined && last.oi === undefined && c.oi !== undefined && c.od === undefined) {\n      last.oi = c.oi;\n    } else if (last.oi !== undefined && c.od !== undefined) {\n      // The last path component inserted something that the new component deletes (or replaces).\n      // Just merge them.\n      if (c.oi !== undefined) {\n        last.oi = c.oi;\n      } else if (last.od !== undefined) {\n        delete last.oi;\n      } else {\n        // An insert directly followed by a delete turns into a no-op and can be removed.\n        dest.pop();\n      }\n    } else if (c.lm !== undefined && c.p[c.p.length - 1] === c.lm) {\n      // don't do anything\n    } else {\n      dest.push(c);\n    }\n  } else {\n    // convert string ops back\n    if ((c.si != null || c.sd != null) && (last.si != null || last.sd != null)) {\n      convertToText(c);\n      convertToText(last);\n    }\n\n    dest.push(c);\n  }\n};\n\njson.compose = function(op1,op2) {\n  json.checkValidOp(op1);\n  json.checkValidOp(op2);\n\n  var newOp = clone(op1);\n\n  for (var i = 0; i < op2.length; i++) {\n    json.append(newOp,op2[i]);\n  }\n\n  return newOp;\n};\n\njson.normalize = function(op) {\n  var newOp = [];\n\n  op = isArray(op) ? op : [op];\n\n  for (var i = 0; i < op.length; i++) {\n    var c = op[i];\n    if (c.p == null) c.p = [];\n\n    json.append(newOp,c);\n  }\n\n  return newOp;\n};\n\n// Returns the common length of the paths of ops a and b\njson.commonLengthForOps = function(a, b) {\n  var alen = a.p.length;\n  var blen = b.p.length;\n  if (a.na != null || a.t)\n    alen++;\n\n  if (b.na != null || b.t)\n    blen++;\n\n  if (alen === 0) return -1;\n  if (blen === 0) return null;\n\n  alen--;\n  blen--;\n\n  for (var i = 0; i < alen; i++) {\n    var p = a.p[i];\n    if (i >= blen || p !== b.p[i])\n      return null;\n  }\n\n  return alen;\n};\n\n// Returns true if an op can affect the given path\njson.canOpAffectPath = function(op, path) {\n  return json.commonLengthForOps({p:path}, op) != null;\n};\n\n// transform c so it applies to a document with otherC applied.\njson.transformComponent = function(dest, c, otherC, type) {\n  c = clone(c);\n\n  var common = json.commonLengthForOps(otherC, c);\n  var common2 = json.commonLengthForOps(c, otherC);\n  var cplength = c.p.length;\n  var otherCplength = otherC.p.length;\n\n  if (c.na != null || c.t)\n    cplength++;\n\n  if (otherC.na != null || otherC.t)\n    otherCplength++;\n\n  // if c is deleting something, and that thing is changed by otherC, we need to\n  // update c to reflect that change for invertibility.\n  if (common2 != null && otherCplength > cplength && c.p[common2] == otherC.p[common2]) {\n    if (c.ld !== void 0) {\n      var oc = clone(otherC);\n      oc.p = oc.p.slice(cplength);\n      c.ld = json.apply(clone(c.ld),[oc]);\n    } else if (c.od !== void 0) {\n      var oc = clone(otherC);\n      oc.p = oc.p.slice(cplength);\n      c.od = json.apply(clone(c.od),[oc]);\n    }\n  }\n\n  if (common != null) {\n    var commonOperand = cplength == otherCplength;\n\n    // backward compatibility for old string ops\n    var oc = otherC;\n    if ((c.si != null || c.sd != null) && (otherC.si != null || otherC.sd != null)) {\n      convertFromText(c);\n      oc = clone(otherC);\n      convertFromText(oc);\n    }\n\n    // handle subtype ops\n    if (oc.t && subtypes[oc.t]) {\n      if (c.t && c.t === oc.t) {\n        var res = subtypes[c.t].transform(c.o, oc.o, type);\n\n        if (res.length > 0) {\n          // convert back to old string ops\n          if (c.si != null || c.sd != null) {\n            var p = c.p;\n            for (var i = 0; i < res.length; i++) {\n              c.o = [res[i]];\n              c.p = p.slice();\n              convertToText(c);\n              json.append(dest, c);\n            }\n          } else {\n            c.o = res;\n            json.append(dest, c);\n          }\n        }\n\n        return dest;\n      }\n    }\n\n    // transform based on otherC\n    else if (otherC.na !== void 0) {\n      // this case is handled below\n    } else if (otherC.li !== void 0 && otherC.ld !== void 0) {\n      if (otherC.p[common] === c.p[common]) {\n        // noop\n\n        if (!commonOperand) {\n          return dest;\n        } else if (c.ld !== void 0) {\n          // we're trying to delete the same element, -> noop\n          if (c.li !== void 0 && type === 'left') {\n            // we're both replacing one element with another. only one can survive\n            c.ld = clone(otherC.li);\n          } else {\n            return dest;\n          }\n        }\n      }\n    } else if (otherC.li !== void 0) {\n      if (c.li !== void 0 && c.ld === undefined && commonOperand && c.p[common] === otherC.p[common]) {\n        // in li vs. li, left wins.\n        if (type === 'right')\n          c.p[common]++;\n      } else if (otherC.p[common] <= c.p[common]) {\n        c.p[common]++;\n      }\n\n      if (c.lm !== void 0) {\n        if (commonOperand) {\n          // otherC edits the same list we edit\n          if (otherC.p[common] <= c.lm)\n            c.lm++;\n          // changing c.from is handled above.\n        }\n      }\n    } else if (otherC.ld !== void 0) {\n      if (c.lm !== void 0) {\n        if (commonOperand) {\n          if (otherC.p[common] === c.p[common]) {\n            // they deleted the thing we're trying to move\n            return dest;\n          }\n          // otherC edits the same list we edit\n          var p = otherC.p[common];\n          var from = c.p[common];\n          var to = c.lm;\n          if (p < to || (p === to && from < to))\n            c.lm--;\n\n        }\n      }\n\n      if (otherC.p[common] < c.p[common]) {\n        c.p[common]--;\n      } else if (otherC.p[common] === c.p[common]) {\n        if (otherCplength < cplength) {\n          // we're below the deleted element, so -> noop\n          return dest;\n        } else if (c.ld !== void 0) {\n          if (c.li !== void 0) {\n            // we're replacing, they're deleting. we become an insert.\n            delete c.ld;\n          } else {\n            // we're trying to delete the same element, -> noop\n            return dest;\n          }\n        }\n      }\n\n    } else if (otherC.lm !== void 0) {\n      if (c.lm !== void 0 && cplength === otherCplength) {\n        // lm vs lm, here we go!\n        var from = c.p[common];\n        var to = c.lm;\n        var otherFrom = otherC.p[common];\n        var otherTo = otherC.lm;\n        if (otherFrom !== otherTo) {\n          // if otherFrom == otherTo, we don't need to change our op.\n\n          // where did my thing go?\n          if (from === otherFrom) {\n            // they moved it! tie break.\n            if (type === 'left') {\n              c.p[common] = otherTo;\n              if (from === to) // ugh\n                c.lm = otherTo;\n            } else {\n              return dest;\n            }\n          } else {\n            // they moved around it\n            if (from > otherFrom) c.p[common]--;\n            if (from > otherTo) c.p[common]++;\n            else if (from === otherTo) {\n              if (otherFrom > otherTo) {\n                c.p[common]++;\n                if (from === to) // ugh, again\n                  c.lm++;\n              }\n            }\n\n            // step 2: where am i going to put it?\n            if (to > otherFrom) {\n              c.lm--;\n            } else if (to === otherFrom) {\n              if (to > from)\n                c.lm--;\n            }\n            if (to > otherTo) {\n              c.lm++;\n            } else if (to === otherTo) {\n              // if we're both moving in the same direction, tie break\n              if ((otherTo > otherFrom && to > from) ||\n                  (otherTo < otherFrom && to < from)) {\n                if (type === 'right') c.lm++;\n              } else {\n                if (to > from) c.lm++;\n                else if (to === otherFrom) c.lm--;\n              }\n            }\n          }\n        }\n      } else if (c.li !== void 0 && c.ld === undefined && commonOperand) {\n        // li\n        var from = otherC.p[common];\n        var to = otherC.lm;\n        p = c.p[common];\n        if (p > from) c.p[common]--;\n        if (p > to) c.p[common]++;\n      } else {\n        // ld, ld+li, si, sd, na, oi, od, oi+od, any li on an element beneath\n        // the lm\n        //\n        // i.e. things care about where their item is after the move.\n        var from = otherC.p[common];\n        var to = otherC.lm;\n        p = c.p[common];\n        if (p === from) {\n          c.p[common] = to;\n        } else {\n          if (p > from) c.p[common]--;\n          if (p > to) c.p[common]++;\n          else if (p === to && from > to) c.p[common]++;\n        }\n      }\n    }\n    else if (otherC.oi !== void 0 && otherC.od !== void 0) {\n      if (c.p[common] === otherC.p[common]) {\n        if (c.oi !== void 0 && commonOperand) {\n          // we inserted where someone else replaced\n          if (type === 'right') {\n            // left wins\n            return dest;\n          } else {\n            // we win, make our op replace what they inserted\n            c.od = otherC.oi;\n          }\n        } else {\n          // -> noop if the other component is deleting the same object (or any parent)\n          return dest;\n        }\n      }\n    } else if (otherC.oi !== void 0) {\n      if (c.oi !== void 0 && c.p[common] === otherC.p[common]) {\n        // left wins if we try to insert at the same place\n        if (type === 'left') {\n          json.append(dest,{p: c.p, od:otherC.oi});\n        } else {\n          return dest;\n        }\n      }\n    } else if (otherC.od !== void 0) {\n      if (c.p[common] == otherC.p[common]) {\n        if (!commonOperand)\n          return dest;\n        if (c.oi !== void 0) {\n          delete c.od;\n        } else {\n          return dest;\n        }\n      }\n    }\n  }\n\n  json.append(dest,c);\n  return dest;\n};\n\nrequire('./bootstrapTransform')(json, json.transformComponent, json.checkValidOp, json.append);\n\n/**\n * Register a subtype for string operations, using the text0 type.\n */\nvar text = require('./text0');\n\njson.registerSubtype(text);\nmodule.exports = json;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ot-json0/lib/json0.js\n// module id = 48\n// module chunks = 0","// DEPRECATED!\n//\n// This type works, but is not exported. Its included here because the JSON0\n// embedded string operations use this library.\n\n\n// A simple text implementation\n//\n// Operations are lists of components. Each component either inserts or deletes\n// at a specified position in the document.\n//\n// Components are either:\n//  {i:'str', p:100}: Insert 'str' at position 100 in the document\n//  {d:'str', p:100}: Delete 'str' at position 100 in the document\n//\n// Components in an operation are executed sequentially, so the position of components\n// assumes previous components have already executed.\n//\n// Eg: This op:\n//   [{i:'abc', p:0}]\n// is equivalent to this op:\n//   [{i:'a', p:0}, {i:'b', p:1}, {i:'c', p:2}]\n\nvar text = module.exports = {\n  name: 'text0',\n  uri: 'http://sharejs.org/types/textv0',\n  create: function(initial) {\n    if ((initial != null) && typeof initial !== 'string') {\n      throw new Error('Initial data must be a string');\n    }\n    return initial || '';\n  }\n};\n\n/** Insert s2 into s1 at pos. */\nvar strInject = function(s1, pos, s2) {\n  return s1.slice(0, pos) + s2 + s1.slice(pos);\n};\n\n/** Check that an operation component is valid. Throws if its invalid. */\nvar checkValidComponent = function(c) {\n  if (typeof c.p !== 'number')\n    throw new Error('component missing position field');\n\n  if ((typeof c.i === 'string') === (typeof c.d === 'string'))\n    throw new Error('component needs an i or d field');\n\n  if (c.p < 0)\n    throw new Error('position cannot be negative');\n};\n\n/** Check that an operation is valid */\nvar checkValidOp = function(op) {\n  for (var i = 0; i < op.length; i++) {\n    checkValidComponent(op[i]);\n  }\n};\n\n/** Apply op to snapshot */\ntext.apply = function(snapshot, op) {\n  var deleted;\n\n  checkValidOp(op);\n  for (var i = 0; i < op.length; i++) {\n    var component = op[i];\n    if (component.i != null) {\n      snapshot = strInject(snapshot, component.p, component.i);\n    } else {\n      deleted = snapshot.slice(component.p, component.p + component.d.length);\n      if (component.d !== deleted)\n        throw new Error(\"Delete component '\" + component.d + \"' does not match deleted text '\" + deleted + \"'\");\n\n      snapshot = snapshot.slice(0, component.p) + snapshot.slice(component.p + component.d.length);\n    }\n  }\n  return snapshot;\n};\n\n/**\n * Append a component to the end of newOp. Exported for use by the random op\n * generator and the JSON0 type.\n */\nvar append = text._append = function(newOp, c) {\n  if (c.i === '' || c.d === '') return;\n\n  if (newOp.length === 0) {\n    newOp.push(c);\n  } else {\n    var last = newOp[newOp.length - 1];\n\n    if (last.i != null && c.i != null && last.p <= c.p && c.p <= last.p + last.i.length) {\n      // Compose the insert into the previous insert\n      newOp[newOp.length - 1] = {i:strInject(last.i, c.p - last.p, c.i), p:last.p};\n\n    } else if (last.d != null && c.d != null && c.p <= last.p && last.p <= c.p + c.d.length) {\n      // Compose the deletes together\n      newOp[newOp.length - 1] = {d:strInject(c.d, last.p - c.p, last.d), p:c.p};\n\n    } else {\n      newOp.push(c);\n    }\n  }\n};\n\n/** Compose op1 and op2 together */\ntext.compose = function(op1, op2) {\n  checkValidOp(op1);\n  checkValidOp(op2);\n  var newOp = op1.slice();\n  for (var i = 0; i < op2.length; i++) {\n    append(newOp, op2[i]);\n  }\n  return newOp;\n};\n\n/** Clean up an op */\ntext.normalize = function(op) {\n  var newOp = [];\n\n  // Normalize should allow ops which are a single (unwrapped) component:\n  // {i:'asdf', p:23}.\n  // There's no good way to test if something is an array:\n  // http://perfectionkills.com/instanceof-considered-harmful-or-how-to-write-a-robust-isarray/\n  // so this is probably the least bad solution.\n  if (op.i != null || op.p != null) op = [op];\n\n  for (var i = 0; i < op.length; i++) {\n    var c = op[i];\n    if (c.p == null) c.p = 0;\n\n    append(newOp, c);\n  }\n\n  return newOp;\n};\n\n// This helper method transforms a position by an op component.\n//\n// If c is an insert, insertAfter specifies whether the transform\n// is pushed after the insert (true) or before it (false).\n//\n// insertAfter is optional for deletes.\nvar transformPosition = function(pos, c, insertAfter) {\n  // This will get collapsed into a giant ternary by uglify.\n  if (c.i != null) {\n    if (c.p < pos || (c.p === pos && insertAfter)) {\n      return pos + c.i.length;\n    } else {\n      return pos;\n    }\n  } else {\n    // I think this could also be written as: Math.min(c.p, Math.min(c.p -\n    // otherC.p, otherC.d.length)) but I think its harder to read that way, and\n    // it compiles using ternary operators anyway so its no slower written like\n    // this.\n    if (pos <= c.p) {\n      return pos;\n    } else if (pos <= c.p + c.d.length) {\n      return c.p;\n    } else {\n      return pos - c.d.length;\n    }\n  }\n};\n\n// Helper method to transform a cursor position as a result of an op.\n//\n// Like transformPosition above, if c is an insert, insertAfter specifies\n// whether the cursor position is pushed after an insert (true) or before it\n// (false).\ntext.transformCursor = function(position, op, side) {\n  var insertAfter = side === 'right';\n  for (var i = 0; i < op.length; i++) {\n    position = transformPosition(position, op[i], insertAfter);\n  }\n\n  return position;\n};\n\n// Transform an op component by another op component. Asymmetric.\n// The result will be appended to destination.\n//\n// exported for use in JSON type\nvar transformComponent = text._tc = function(dest, c, otherC, side) {\n  //var cIntersect, intersectEnd, intersectStart, newC, otherIntersect, s;\n\n  checkValidComponent(c);\n  checkValidComponent(otherC);\n\n  if (c.i != null) {\n    // Insert.\n    append(dest, {i:c.i, p:transformPosition(c.p, otherC, side === 'right')});\n  } else {\n    // Delete\n    if (otherC.i != null) {\n      // Delete vs insert\n      var s = c.d;\n      if (c.p < otherC.p) {\n        append(dest, {d:s.slice(0, otherC.p - c.p), p:c.p});\n        s = s.slice(otherC.p - c.p);\n      }\n      if (s !== '')\n        append(dest, {d: s, p: c.p + otherC.i.length});\n\n    } else {\n      // Delete vs delete\n      if (c.p >= otherC.p + otherC.d.length)\n        append(dest, {d: c.d, p: c.p - otherC.d.length});\n      else if (c.p + c.d.length <= otherC.p)\n        append(dest, c);\n      else {\n        // They overlap somewhere.\n        var newC = {d: '', p: c.p};\n\n        if (c.p < otherC.p)\n          newC.d = c.d.slice(0, otherC.p - c.p);\n\n        if (c.p + c.d.length > otherC.p + otherC.d.length)\n          newC.d += c.d.slice(otherC.p + otherC.d.length - c.p);\n\n        // This is entirely optional - I'm just checking the deleted text in\n        // the two ops matches\n        var intersectStart = Math.max(c.p, otherC.p);\n        var intersectEnd = Math.min(c.p + c.d.length, otherC.p + otherC.d.length);\n        var cIntersect = c.d.slice(intersectStart - c.p, intersectEnd - c.p);\n        var otherIntersect = otherC.d.slice(intersectStart - otherC.p, intersectEnd - otherC.p);\n        if (cIntersect !== otherIntersect)\n          throw new Error('Delete ops delete different text in the same region of the document');\n\n        if (newC.d !== '') {\n          newC.p = transformPosition(newC.p, otherC);\n          append(dest, newC);\n        }\n      }\n    }\n  }\n\n  return dest;\n};\n\nvar invertComponent = function(c) {\n  return (c.i != null) ? {d:c.i, p:c.p} : {i:c.d, p:c.p};\n};\n\n// No need to use append for invert, because the components won't be able to\n// cancel one another.\ntext.invert = function(op) {\n  // Shallow copy & reverse that sucka.\n  op = op.slice().reverse();\n  for (var i = 0; i < op.length; i++) {\n    op[i] = invertComponent(op[i]);\n  }\n  return op;\n};\n\nrequire('./bootstrapTransform')(text, transformComponent, checkValidOp, append);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ot-json0/lib/text0.js\n// module id = 49\n// module chunks = 0","var Backend = require('./backend');\nmodule.exports = Backend;\n\nBackend.Agent = require('./agent');\nBackend.Backend = Backend;\nBackend.DB = require('./db');\nBackend.Error = require('./error');\nBackend.MemoryDB = require('./db/memory');\nBackend.MemoryPubSub = require('./pubsub/memory');\nBackend.ot = require('./ot');\nBackend.projections = require('./projections');\nBackend.PubSub = require('./pubsub');\nBackend.QueryEmitter = require('./query-emitter');\nBackend.SubmitRequest = require('./submit-request');\nBackend.types = require('./types');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/sharedb/lib/index.js\n// module id = 50\n// module chunks = 0","var async = require('async');\nvar Agent = require('./agent');\nvar Connection = require('./client/connection');\nvar emitter = require('./emitter');\nvar MemoryDB = require('./db/memory');\nvar MemoryPubSub = require('./pubsub/memory');\nvar ot = require('./ot');\nvar projections = require('./projections');\nvar QueryEmitter = require('./query-emitter');\nvar StreamSocket = require('./stream-socket');\nvar SubmitRequest = require('./submit-request');\n\nfunction Backend(options) {\n  if (!(this instanceof Backend)) return new Backend(options);\n  emitter.EventEmitter.call(this);\n\n  if (!options) options = {};\n  this.db = options.db || new MemoryDB();\n  this.pubsub = options.pubsub || new MemoryPubSub();\n  // This contains any extra databases that can be queried\n  this.extraDbs = options.extraDbs || {};\n\n  // Map from projected collection -> {type, fields}\n  this.projections = {};\n\n  this.suppressPublish = !!options.suppressPublish;\n  this.maxSubmitRetries = options.maxSubmitRetries || null;\n\n  // Map from event name to a list of middleware\n  this.middleware = {};\n\n  // The number of open agents for monitoring and testing memory leaks\n  this.agentsCount = 0;\n  this.remoteAgentsCount = 0;\n}\nmodule.exports = Backend;\nemitter.mixin(Backend);\n\nBackend.prototype.close = function(callback) {\n  var wait = 3;\n  var backend = this;\n  function finish(err) {\n    if (err) {\n      if (callback) return callback(err);\n      return backend.emit('error', err);\n    }\n    if (--wait) return;\n    if (callback) callback();\n  }\n  this.pubsub.close(finish);\n  this.db.close(finish);\n  for (var name in this.extraDbs) {\n    wait++;\n    this.extraDbs[name].close(finish);\n  }\n  finish();\n};\n\nBackend.prototype.connect = function(connection, req) {\n  var socket = new StreamSocket();\n  if (connection) {\n    connection.bindToSocket(socket);\n  } else {\n    connection = new Connection(socket);\n  }\n  socket._open();\n  var agent = this.listen(socket.stream, req);\n  // Store a reference to the agent on the connection for convenience. This is\n  // not used internal to ShareDB, but it is handy for server-side only user\n  // code that may cache state on the agent and read it in middleware\n  connection.agent = agent;\n  return connection;\n};\n\n/** A client has connected through the specified stream. Listen for messages.\n *\n * The optional second argument (req) is an initial request which is passed\n * through to any connect() middleware. This is useful for inspecting cookies\n * or an express session or whatever on the request object in your middleware.\n *\n * (The agent is available through all middleware)\n */\nBackend.prototype.listen = function(stream, req) {\n  var agent = new Agent(this, stream);\n  this.trigger('connect', agent, {stream: stream, req: req}, function(err) {\n    if (err) return agent.close(err);\n    agent._open();\n  });\n  return agent;\n};\n\nBackend.prototype.addProjection = function(name, collection, fields) {\n  if (this.projections[name]) {\n    throw new Error('Projection ' + name + ' already exists');\n  }\n\n  for (var key in fields) {\n    if (fields[key] !== true) {\n      throw new Error('Invalid field ' + key + ' - fields must be {somekey: true}. Subfields not currently supported.');\n    }\n  }\n\n  this.projections[name] = {\n    target: collection,\n    fields: fields\n  };\n};\n\n/**\n * Add middleware to an action or array of actions\n */\nBackend.prototype.use = function(action, fn) {\n  if (Array.isArray(action)) {\n    for (var i = 0; i < action.length; i++) {\n      this.use(action[i], fn);\n    }\n    return;\n  }\n  var fns = this.middleware[action] || (this.middleware[action] = []);\n  fns.push(fn);\n  return this;\n};\n\n/**\n * Passes request through the middleware stack\n *\n * Middleware may modify the request object. After all middleware have been\n * invoked we call `callback` with `null` and the modified request. If one of\n * the middleware resturns an error the callback is called with that error.\n */\nBackend.prototype.trigger = function(action, agent, request, callback) {\n  request.action = action;\n  request.agent = agent;\n  request.backend = this;\n\n  var fns = this.middleware[action];\n  if (!fns) return callback();\n\n  // Copying the triggers we'll fire so they don't get edited while we iterate.\n  fns = fns.slice();\n  var next = function(err) {\n    if (err) return callback(err);\n    var fn = fns.shift();\n    if (!fn) return callback();\n    fn(request, next);\n  };\n  next();\n};\n\n// Submit an operation on the named collection/docname. op should contain a\n// {op:}, {create:} or {del:} field. It should probably contain a v: field (if\n// it doesn't, it defaults to the current version).\nBackend.prototype.submit = function(agent, index, id, op, options, callback) {\n  var err = ot.checkOp(op);\n  if (err) return callback(err);\n  var request = new SubmitRequest(this, agent, index, id, op, options);\n  var backend = this;\n  backend.trigger('submit', agent, request, function(err) {\n    if (err) return callback(err);\n    request.submit(function(err) {\n      if (err) return callback(err);\n      backend.trigger('after submit', agent, request, function(err) {\n        if (err) return callback(err);\n        backend._sanitizeOps(agent, request.projection, request.collection, id, request.ops, function(err) {\n          if (err) return callback(err);\n          backend.emit('timing', 'submit.total', Date.now() - request.start, request);\n          callback(err, request.ops);\n        });\n      });\n    });\n  });\n};\n\nBackend.prototype._sanitizeOp = function(agent, projection, collection, id, op, callback) {\n  if (projection) {\n    try {\n      projections.projectOp(projection.fields, op);\n    } catch (err) {\n      return callback(err);\n    }\n  }\n  this.trigger('op', agent, {collection: collection, id: id, op: op}, callback);\n};\nBackend.prototype._sanitizeOps = function(agent, projection, collection, id, ops, callback) {\n  var backend = this;\n  async.each(ops, function(op, eachCb) {\n    backend._sanitizeOp(agent, projection, collection, id, op, eachCb);\n  }, callback);\n};\nBackend.prototype._sanitizeOpsBulk = function(agent, projection, collection, opsMap, callback) {\n  var backend = this;\n  async.forEachOf(opsMap, function(ops, id, eachCb) {\n    backend._sanitizeOps(agent, projection, collection, id, ops, eachCb);\n  }, callback);\n};\n\nBackend.prototype._sanitizeSnapshot = function(agent, projection, collection, id, snapshot, callback) {\n  if (projection) {\n    try {\n      projections.projectSnapshot(projection.fields, snapshot);\n    } catch (err) {\n      return callback(err);\n    }\n  }\n  this.trigger('doc', agent, {collection: collection, id: id, snapshot: snapshot}, callback);\n};\nBackend.prototype._sanitizeSnapshots = function(agent, projection, collection, snapshots, callback) {\n  var backend = this;\n  async.each(snapshots, function(snapshot, eachCb) {\n    backend._sanitizeSnapshot(agent, projection, collection, snapshot.id, snapshot, eachCb);\n  }, callback);\n};\nBackend.prototype._sanitizeSnapshotBulk = function(agent, projection, collection, snapshotMap, callback) {\n  var backend = this;\n  async.forEachOf(snapshotMap, function(snapshot, id, eachCb) {\n    backend._sanitizeSnapshot(agent, projection, collection, id, snapshot, eachCb);\n  }, callback);\n};\n\nBackend.prototype._getSnapshotProjection = function(db, projection) {\n  return (db.projectsSnapshots) ? null : projection;\n};\n\n// Non inclusive - gets ops from [from, to). Ie, all relevant ops. If to is\n// not defined (null or undefined) then it returns all ops.\nBackend.prototype.getOps = function(agent, index, id, from, to, callback) {\n  var start = Date.now();\n  var projection = this.projections[index];\n  var collection = (projection) ? projection.target : index;\n  var backend = this;\n  var request = {\n    agent: agent,\n    index: index,\n    collection: collection,\n    id: id,\n    from: from,\n    to: to\n  };\n  backend.db.getOps(collection, id, from, to, null, function(err, ops) {\n    if (err) return callback(err);\n    backend._sanitizeOps(agent, projection, collection, id, ops, function(err) {\n      if (err) return callback(err);\n      backend.emit('timing', 'getOps', Date.now() - start, request);\n      callback(err, ops);\n    });\n  });\n};\n\nBackend.prototype.getOpsBulk = function(agent, index, fromMap, toMap, callback) {\n  var start = Date.now();\n  var projection = this.projections[index];\n  var collection = (projection) ? projection.target : index;\n  var backend = this;\n  var request = {\n    agent: agent,\n    index: index,\n    collection: collection,\n    fromMap: fromMap,\n    toMap: toMap\n  };\n  backend.db.getOpsBulk(collection, fromMap, toMap, null, function(err, opsMap) {\n    if (err) return callback(err);\n    backend._sanitizeOpsBulk(agent, projection, collection, opsMap, function(err) {\n      if (err) return callback(err);\n      backend.emit('timing', 'getOpsBulk', Date.now() - start, request);\n      callback(err, opsMap);\n    });\n  });\n};\n\nBackend.prototype.fetch = function(agent, index, id, callback) {\n  var start = Date.now();\n  var projection = this.projections[index];\n  var collection = (projection) ? projection.target : index;\n  var fields = projection && projection.fields;\n  var backend = this;\n  var request = {\n    agent: agent,\n    index: index,\n    collection: collection,\n    id: id\n  };\n  backend.db.getSnapshot(collection, id, fields, null, function(err, snapshot) {\n    if (err) return callback(err);\n    var snapshotProjection = backend._getSnapshotProjection(backend.db, projection);\n    backend._sanitizeSnapshot(agent, snapshotProjection, collection, id, snapshot, function(err) {\n      if (err) return callback(err);\n      backend.emit('timing', 'fetch', Date.now() - start, request);\n      callback(null, snapshot);\n    });\n  });\n};\n\nBackend.prototype.fetchBulk = function(agent, index, ids, callback) {\n  var start = Date.now();\n  var projection = this.projections[index];\n  var collection = (projection) ? projection.target : index;\n  var fields = projection && projection.fields;\n  var backend = this;\n  var request = {\n    agent: agent,\n    index: index,\n    collection: collection,\n    ids: ids\n  };\n  backend.db.getSnapshotBulk(collection, ids, fields, null, function(err, snapshotMap) {\n    if (err) return callback(err);\n    var snapshotProjection = backend._getSnapshotProjection(backend.db, projection);\n    backend._sanitizeSnapshotBulk(agent, snapshotProjection, collection, snapshotMap, function(err) {\n      if (err) return callback(err);\n      backend.emit('timing', 'fetchBulk', Date.now() - start, request);\n      callback(null, snapshotMap);\n    });\n  });\n};\n\n// Subscribe to the document from the specified version or null version\nBackend.prototype.subscribe = function(agent, index, id, version, callback) {\n  var start = Date.now();\n  var projection = this.projections[index];\n  var collection = (projection) ? projection.target : index;\n  var channel = this.getDocChannel(collection, id);\n  var backend = this;\n  var request = {\n    agent: agent,\n    index: index,\n    collection: collection,\n    id: id,\n    version: version\n  };\n  backend.pubsub.subscribe(channel, function(err, stream) {\n    if (err) return callback(err);\n    stream.initProjection(backend, agent, projection);\n    if (version == null) {\n      // Subscribing from null means that the agent doesn't have a document\n      // and needs to fetch it as well as subscribing\n      backend.fetch(agent, index, id, function(err, snapshot) {\n        if (err) return callback(err);\n        backend.emit('timing', 'subscribe.snapshot', Date.now() - start, request);\n        callback(null, stream, snapshot);\n      });\n    } else {\n      backend.db.getOps(collection, id, version, null, null, function(err, ops) {\n        if (err) return callback(err);\n        stream.pushOps(collection, id, ops);\n        backend.emit('timing', 'subscribe.ops', Date.now() - start, request);\n        callback(null, stream);\n      });\n    }\n  });\n};\n\nBackend.prototype.subscribeBulk = function(agent, index, versions, callback) {\n  var start = Date.now();\n  var projection = this.projections[index];\n  var collection = (projection) ? projection.target : index;\n  var backend = this;\n  var streams = {};\n  var doFetch = Array.isArray(versions);\n  var ids = (doFetch) ? versions : Object.keys(versions);\n  var request = {\n    agent: agent,\n    index: index,\n    collection: collection,\n    versions: versions\n  };\n  async.each(ids, function(id, eachCb) {\n    var channel = backend.getDocChannel(collection, id);\n    backend.pubsub.subscribe(channel, function(err, stream) {\n      if (err) return eachCb(err);\n      stream.initProjection(backend, agent, projection);\n      streams[id] = stream;\n      eachCb();\n    });\n  }, function(err) {\n    if (err) {\n      destroyStreams(streams);\n      return callback(err);\n    }\n    if (doFetch) {\n      // If an array of ids, get current snapshots\n      backend.fetchBulk(agent, index, ids, function(err, snapshotMap) {\n        if (err) {\n          destroyStreams(streams);\n          return callback(err);\n        }\n        backend.emit('timing', 'subscribeBulk.snapshot', Date.now() - start, request);\n        callback(null, streams, snapshotMap);\n      });\n    } else {\n      // If a versions map, get ops since requested versions\n      backend.db.getOpsBulk(collection, versions, null, null, function(err, opsMap) {\n        if (err) {\n          destroyStreams(streams);\n          return callback(err);\n        }\n        for (var id in opsMap) {\n          var ops = opsMap[id];\n          streams[id].pushOps(collection, id, ops);\n        }\n        backend.emit('timing', 'subscribeBulk.ops', Date.now() - start, request);\n        callback(null, streams);\n      });\n    }\n  });\n};\nfunction destroyStreams(streams) {\n  for (var id in streams) {\n    streams[id].destroy();\n  }\n}\n\nBackend.prototype.queryFetch = function(agent, index, query, options, callback) {\n  var start = Date.now();\n  var backend = this;\n  backend._triggerQuery(agent, index, query, options, function(err, request) {\n    if (err) return callback(err);\n    backend._query(agent, request, function(err, snapshots, extra) {\n      if (err) return callback(err);\n      backend.emit('timing', 'queryFetch', Date.now() - start, request);\n      callback(null, snapshots, extra);\n    });\n  });\n};\n\n// Options can contain:\n// db: The name of the DB (if the DB is specified in the otherDbs when the backend instance is created)\n// skipPoll: function(collection, id, op, query) {return true or false; }\n//  this is a syncronous function which can be used as an early filter for\n//  operations going through the system to reduce the load on the DB.\n// pollDebounce: Minimum delay between subsequent database polls. This is\n//  used to batch updates to reduce load on the database at the expense of\n//  liveness\nBackend.prototype.querySubscribe = function(agent, index, query, options, callback) {\n  var start = Date.now();\n  var backend = this;\n  backend._triggerQuery(agent, index, query, options, function(err, request) {\n    if (err) return callback(err);\n    if (request.db.disableSubscribe) {\n      return callback({code: 4002, message: 'DB does not support subscribe'});\n    }\n    backend.pubsub.subscribe(request.channel, function(err, stream) {\n      if (err) return callback(err);\n      stream.initProjection(backend, agent, request.projection);\n      if (options.ids) {\n        var queryEmitter = new QueryEmitter(request, stream, options.ids);\n        backend.emit('timing', 'querySubscribe.reconnect', Date.now() - start, request);\n        callback(null, queryEmitter);\n        return;\n      }\n      // Issue query on db to get our initial results\n      backend._query(agent, request, function(err, snapshots, extra) {\n        if (err) {\n          stream.destroy();\n          return callback(err);\n        }\n        var ids = pluckIds(snapshots);\n        var queryEmitter = new QueryEmitter(request, stream, ids, extra);\n        backend.emit('timing', 'querySubscribe.initial', Date.now() - start, request);\n        callback(null, queryEmitter, snapshots, extra);\n      });\n    });\n  });\n};\n\nBackend.prototype._triggerQuery = function(agent, index, query, options, callback) {\n  var projection = this.projections[index];\n  var collection = (projection) ? projection.target : index;\n  var fields = projection && projection.fields;\n  var request = {\n    index: index,\n    collection: collection,\n    projection: projection,\n    fields: fields,\n    channel: this.getCollectionChannel(collection),\n    query: query,\n    options: options,\n    db: null,\n    snapshotProjection: null,\n  };\n  var backend = this;\n  backend.trigger('query', agent, request, function(err) {\n    if (err) return callback(err);\n    // Set the DB reference for the request after the middleware trigger so\n    // that the db option can be changed in middleware\n    request.db = (options.db) ? backend.extraDbs[options.db] : backend.db;\n    if (!request.db) return callback({code: 4003, message: 'DB not found'});\n    request.snapshotProjection = backend._getSnapshotProjection(request.db, projection);\n    callback(null, request);\n  });\n};\n\nBackend.prototype._query = function(agent, request, callback) {\n  var backend = this;\n  request.db.query(request.collection, request.query, request.fields, request.options, function(err, snapshots, extra) {\n    if (err) return callback(err);\n    backend._sanitizeSnapshots(agent, request.snapshotProjection, request.collection, snapshots, function(err) {\n      callback(err, snapshots, extra);\n    });\n  });\n};\n\nBackend.prototype.getCollectionChannel = function(collection) {\n  return collection;\n};\n\nBackend.prototype.getDocChannel = function(collection, id) {\n  return collection + '.' + id;\n};\n\nBackend.prototype.getChannels = function(collection, id) {\n  return [\n    this.getCollectionChannel(collection),\n    this.getDocChannel(collection, id)\n  ];\n};\n\nfunction pluckIds(snapshots) {\n  var ids = [];\n  for (var i = 0; i < snapshots.length; i++) {\n    ids.push(snapshots[i].id);\n  }\n  return ids;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/sharedb/lib/backend.js\n// module id = 51\n// module chunks = 0","var hat = module.exports = function (bits, base) {\n    if (!base) base = 16;\n    if (bits === undefined) bits = 128;\n    if (bits <= 0) return '0';\n    \n    var digits = Math.log(Math.pow(2, bits)) / Math.log(base);\n    for (var i = 2; digits === Infinity; i *= 2) {\n        digits = Math.log(Math.pow(2, bits / i)) / Math.log(base) * i;\n    }\n    \n    var rem = digits - Math.floor(digits);\n    \n    var res = '';\n    \n    for (var i = 0; i < Math.floor(digits); i++) {\n        var x = Math.floor(Math.random() * base).toString(base);\n        res = x + res;\n    }\n    \n    if (rem) {\n        var b = Math.pow(base, rem);\n        var x = Math.floor(Math.random() * b).toString(base);\n        res = x + res;\n    }\n    \n    var parsed = parseInt(res, base);\n    if (parsed !== Infinity && parsed >= Math.pow(2, bits)) {\n        return hat(bits, base)\n    }\n    else return res;\n};\n\nhat.rack = function (bits, base, expandBy) {\n    var fn = function (data) {\n        var iters = 0;\n        do {\n            if (iters ++ > 10) {\n                if (expandBy) bits += expandBy;\n                else throw new Error('too many ID collisions, use more bits')\n            }\n            \n            var id = hat(bits, base);\n        } while (Object.hasOwnProperty.call(hats, id));\n        \n        hats[id] = data;\n        return id;\n    };\n    var hats = fn.hats = {};\n    \n    fn.get = function (id) {\n        return fn.hats[id];\n    };\n    \n    fn.set = function (id, value) {\n        fn.hats[id] = value;\n        return fn;\n    };\n    \n    fn.bits = bits || 128;\n    fn.base = base || 16;\n    return fn;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/hat/index.js\n// module id = 52\n// module chunks = 0","var inherits = require('util').inherits;\nvar Readable = require('stream').Readable;\nvar util = require('./util');\n\n// Stream of operations. Subscribe returns one of these\nfunction OpStream() {\n  Readable.call(this, {objectMode: true});\n\n  this.id = null;\n  this.backend = null;\n  this.agent = null;\n  this.projection = null;\n\n  this.open = true;\n}\nmodule.exports = OpStream;\n\ninherits(OpStream, Readable);\n\n// This function is for notifying us that the stream is empty and needs data.\n// For now, we'll just ignore the signal and assume the reader reads as fast\n// as we fill it. I could add a buffer in this function, but really I don't\n// think that is any better than the buffer implementation in nodejs streams\n// themselves.\nOpStream.prototype._read = util.doNothing;\n\nOpStream.prototype.initProjection = function(backend, agent, projection) {\n  this.backend = backend;\n  this.agent = agent;\n  this.projection = projection;\n};\n\nOpStream.prototype.pushOp = function(collection, id, op) {\n  if (this.backend) {\n    var stream = this;\n    this.backend._sanitizeOp(this.agent, this.projection, collection, id, op, function(err) {\n      if (!stream.open) return;\n      stream.push(err ? {error: err} : op);\n    });\n  } else {\n    // Ignore any messages after unsubscribe\n    if (!this.open) return;\n    this.push(op);\n  }\n};\n\nOpStream.prototype.pushOps = function(collection, id, ops) {\n  for (var i = 0; i < ops.length; i++) {\n    this.pushOp(collection, id, ops[i]);\n  }\n};\n\nOpStream.prototype.destroy = function() {\n  if (!this.open) return;\n  this.open = false;\n\n  this.push(null);\n  this.emit('close');\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/sharedb/lib/op-stream.js\n// module id = 53\n// module chunks = 0","module.exports = arrayDiff;\n\n// Based on some rough benchmarking, this algorithm is about O(2n) worst case,\n// and it can compute diffs on random arrays of length 1024 in about 34ms,\n// though just a few changes on an array of length 1024 takes about 0.5ms\n\narrayDiff.InsertDiff = InsertDiff;\narrayDiff.RemoveDiff = RemoveDiff;\narrayDiff.MoveDiff = MoveDiff;\n\nfunction InsertDiff(index, values) {\n  this.index = index;\n  this.values = values;\n}\nInsertDiff.prototype.type = 'insert';\nInsertDiff.prototype.toJSON = function() {\n  return {\n    type: this.type,\n    index: this.index,\n    values: this.values\n  };\n};\n\nfunction RemoveDiff(index, howMany) {\n  this.index = index;\n  this.howMany = howMany;\n}\nRemoveDiff.prototype.type = 'remove';\nRemoveDiff.prototype.toJSON = function() {\n  return {\n    type: this.type,\n    index: this.index,\n    howMany: this.howMany\n  };\n};\n\nfunction MoveDiff(from, to, howMany) {\n  this.from = from;\n  this.to = to;\n  this.howMany = howMany;\n}\nMoveDiff.prototype.type = 'move';\nMoveDiff.prototype.toJSON = function() {\n  return {\n    type: this.type,\n    from: this.from,\n    to: this.to,\n    howMany: this.howMany\n  };\n};\n\nfunction strictEqual(a, b) {\n  return a === b;\n}\n\nfunction arrayDiff(before, after, equalFn) {\n  if (!equalFn) equalFn = strictEqual;\n\n  // Find all items in both the before and after array, and represent them\n  // as moves. Many of these \"moves\" may end up being discarded in the last\n  // pass if they are from an index to the same index, but we don't know this\n  // up front, since we haven't yet offset the indices.\n  //\n  // Also keep a map of all the indices accounted for in the before and after\n  // arrays. These maps are used next to create insert and remove diffs.\n  var beforeLength = before.length;\n  var afterLength = after.length;\n  var moves = [];\n  var beforeMarked = {};\n  var afterMarked = {};\n  for (var beforeIndex = 0; beforeIndex < beforeLength; beforeIndex++) {\n    var beforeItem = before[beforeIndex];\n    for (var afterIndex = 0; afterIndex < afterLength; afterIndex++) {\n      if (afterMarked[afterIndex]) continue;\n      if (!equalFn(beforeItem, after[afterIndex])) continue;\n      var from = beforeIndex;\n      var to = afterIndex;\n      var howMany = 0;\n      do {\n        beforeMarked[beforeIndex++] = afterMarked[afterIndex++] = true;\n        howMany++;\n      } while (\n        beforeIndex < beforeLength &&\n        afterIndex < afterLength &&\n        equalFn(before[beforeIndex], after[afterIndex]) &&\n        !afterMarked[afterIndex]\n      );\n      moves.push(new MoveDiff(from, to, howMany));\n      beforeIndex--;\n      break;\n    }\n  }\n\n  // Create a remove for all of the items in the before array that were\n  // not marked as being matched in the after array as well\n  var removes = [];\n  for (beforeIndex = 0; beforeIndex < beforeLength;) {\n    if (beforeMarked[beforeIndex]) {\n      beforeIndex++;\n      continue;\n    }\n    var index = beforeIndex;\n    var howMany = 0;\n    while (beforeIndex < beforeLength && !beforeMarked[beforeIndex++]) {\n      howMany++;\n    }\n    removes.push(new RemoveDiff(index, howMany));\n  }\n\n  // Create an insert for all of the items in the after array that were\n  // not marked as being matched in the before array as well\n  var inserts = [];\n  for (var afterIndex = 0; afterIndex < afterLength;) {\n    if (afterMarked[afterIndex]) {\n      afterIndex++;\n      continue;\n    }\n    var index = afterIndex;\n    var howMany = 0;\n    while (afterIndex < afterLength && !afterMarked[afterIndex++]) {\n      howMany++;\n    }\n    var values = after.slice(index, index + howMany);\n    inserts.push(new InsertDiff(index, values));\n  }\n\n  var insertsLength = inserts.length;\n  var removesLength = removes.length;\n  var movesLength = moves.length;\n  var i, j;\n\n  // Offset subsequent removes and moves by removes\n  var count = 0;\n  for (i = 0; i < removesLength; i++) {\n    var remove = removes[i];\n    remove.index -= count;\n    count += remove.howMany;\n    for (j = 0; j < movesLength; j++) {\n      var move = moves[j];\n      if (move.from >= remove.index) move.from -= remove.howMany;\n    }\n  }\n\n  // Offset moves by inserts\n  for (i = insertsLength; i--;) {\n    var insert = inserts[i];\n    var howMany = insert.values.length;\n    for (j = movesLength; j--;) {\n      var move = moves[j];\n      if (move.to >= insert.index) move.to -= howMany;\n    }\n  }\n\n  // Offset the to of moves by later moves\n  for (i = movesLength; i-- > 1;) {\n    var move = moves[i];\n    if (move.to === move.from) continue;\n    for (j = i; j--;) {\n      var earlier = moves[j];\n      if (earlier.to >= move.to) earlier.to -= move.howMany;\n      if (earlier.to >= move.from) earlier.to += move.howMany;\n    }\n  }\n\n  // Only output moves that end up having an effect after offsetting\n  var outputMoves = [];\n\n  // Offset the from of moves by earlier moves\n  for (i = 0; i < movesLength; i++) {\n    var move = moves[i];\n    if (move.to === move.from) continue;\n    outputMoves.push(move);\n    for (j = i + 1; j < movesLength; j++) {\n      var later = moves[j];\n      if (later.from >= move.from) later.from -= move.howMany;\n      if (later.from >= move.to) later.from += move.howMany;\n    }\n  }\n\n  return removes.concat(outputMoves, inserts);\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/arraydiff/index.js\n// module id = 54\n// module chunks = 0","var pSlice = Array.prototype.slice;\nvar Object_keys = typeof Object.keys === 'function'\n    ? Object.keys\n    : function (obj) {\n        var keys = [];\n        for (var key in obj) keys.push(key);\n        return keys;\n    }\n;\n\nvar deepEqual = module.exports = function (actual, expected) {\n  // enforce Object.is +0 !== -0\n  if (actual === 0 && expected === 0) {\n    return areZerosEqual(actual, expected);\n\n  // 7.1. All identical values are equivalent, as determined by ===.\n  } else if (actual === expected) {\n    return true;\n\n  } else if (actual instanceof Date && expected instanceof Date) {\n    return actual.getTime() === expected.getTime();\n\n  } else if (isNumberNaN(actual)) {\n    return isNumberNaN(expected);\n\n  // 7.3. Other pairs that do not both pass typeof value == 'object',\n  // equivalence is determined by ==.\n  } else if (typeof actual != 'object' && typeof expected != 'object') {\n    return actual == expected;\n\n  // 7.4. For all other Object pairs, including Array objects, equivalence is\n  // determined by having the same number of owned properties (as verified\n  // with Object.prototype.hasOwnProperty.call), the same set of keys\n  // (although not necessarily the same order), equivalent values for every\n  // corresponding key, and an identical 'prototype' property. Note: this\n  // accounts for both named and indexed properties on Arrays.\n  } else {\n    return objEquiv(actual, expected);\n  }\n};\n\nfunction isUndefinedOrNull(value) {\n  return value === null || value === undefined;\n}\n\nfunction isArguments(object) {\n  return Object.prototype.toString.call(object) == '[object Arguments]';\n}\n\nfunction isNumberNaN(value) {\n  // NaN === NaN -> false\n  return typeof value == 'number' && value !== value;\n}\n\nfunction areZerosEqual(zeroA, zeroB) {\n  // (1 / +0|0) -> Infinity, but (1 / -0) -> -Infinity and (Infinity !== -Infinity)\n  return (1 / zeroA) === (1 / zeroB);\n}\n\nfunction objEquiv(a, b) {\n  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))\n    return false;\n\n  // an identical 'prototype' property.\n  if (a.prototype !== b.prototype) return false;\n  //~~~I've managed to break Object.keys through screwy arguments passing.\n  //   Converting to array solves the problem.\n  if (isArguments(a)) {\n    if (!isArguments(b)) {\n      return false;\n    }\n    a = pSlice.call(a);\n    b = pSlice.call(b);\n    return deepEqual(a, b);\n  }\n  try {\n    var ka = Object_keys(a),\n        kb = Object_keys(b),\n        key, i;\n  } catch (e) {//happens when one is a string literal and the other isn't\n    return false;\n  }\n  // having the same number of owned properties (keys incorporates\n  // hasOwnProperty)\n  if (ka.length != kb.length)\n    return false;\n  //the same set of keys (although not necessarily the same order),\n  ka.sort();\n  kb.sort();\n  //~~~cheap key test\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] != kb[i])\n      return false;\n  }\n  //equivalent values for every corresponding key, and\n  //~~~possibly expensive deep test\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!deepEqual(a[key], b[key])) return false;\n  }\n  return true;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/deep-is/index.js\n// module id = 55\n// module chunks = 0","var Duplex = require('stream').Duplex;\nvar inherits = require('util').inherits;\nvar util = require('./util');\n\nfunction StreamSocket() {\n  this.readyState = 0;\n  this.stream = new ServerStream(this);\n}\nmodule.exports = StreamSocket;\n\nStreamSocket.prototype._open = function() {\n  if (this.readyState !== 0) return;\n  this.readyState = 1;\n  this.onopen();\n};\nStreamSocket.prototype.close = function(reason) {\n  if (this.readyState === 3) return;\n  this.readyState = 3;\n  // Signal data writing is complete. Emits the 'end' event\n  this.stream.push(null);\n  this.onclose(reason || 'closed');\n};\nStreamSocket.prototype.send = function(data) {\n  // Data is an object\n  this.stream.push(JSON.parse(data));\n};\nStreamSocket.prototype.onmessage = util.doNothing;\nStreamSocket.prototype.onclose = util.doNothing;\nStreamSocket.prototype.onerror = util.doNothing;\nStreamSocket.prototype.onopen = util.doNothing;\n\n\nfunction ServerStream(socket) {\n  Duplex.call(this, {objectMode: true});\n\n  this.socket = socket;\n\n  this.on('error', function(error) {\n    console.warn('ShareDB client message stream error', error);\n    socket.close('stopped');\n  });\n\n  // The server ended the writable stream. Triggered by calling stream.end()\n  // in agent.close()\n  this.on('finish', function() {\n    socket.close('stopped');\n  });\n}\ninherits(ServerStream, Duplex);\n\nServerStream.prototype.isServer = true;\n\nServerStream.prototype._read = util.doNothing;\n\nServerStream.prototype._write = function(chunk, encoding, callback) {\n  var socket = this.socket;\n  process.nextTick(function() {\n    if (socket.readyState !== 1) return;\n    socket.onmessage({data: JSON.stringify(chunk)});\n    callback();\n  });\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/sharedb/lib/stream-socket.js\n// module id = 56\n// module chunks = 0","import {SDB, SDBDoc} from './sharedb_wrapper';\nimport {EventEmitter} from './typed_event_emitter';\n\nexport enum TypingStatus { IDLE, ACTIVE, IDLE_TYPED };\n\nexport type UserID = number;\nexport interface User {\n    id:UserID,\n    displayName:string,\n    present:boolean,\n    typing:TypingStatus\n};\nexport interface Message {\n    sender:User,\n    timestamp:number,\n    content?:string\n};\nexport interface TextMessage extends Message{\n};\n\nexport interface ChatDoc {\n    users:Array<User>\n    messages:Array<Message>\n};\n\nexport interface UserJoinedEvent {\n    user:User,\n    after:User\n};\nexport interface UserNotPresentEvent {\n    user:User\n};\nexport interface UserTypingStatusChangedEvent {\n    user:User,\n    typing:TypingStatus\n};\nexport interface MessageAddedEvent {\n    message:Message,\n    after:Message\n};\nexport interface ReadyEvent { };\n\nexport class ArboretumChat extends EventEmitter {\n    private static userCounter:number = 1;\n    private doc:SDBDoc<ChatDoc>;\n    public initialized:Promise<void>;\n    private meUser:User;\n    public userJoined = this.registerEvent<(UserJoinedEvent)=>void>();\n    public userNotPresent = this.registerEvent<(UserNotPresentEvent)=>void>();\n    public userTypingStatusChanged = this.registerEvent<(UserTypingStatusChangedEvent)=>void>();\n    public messageAdded = this.registerEvent<(MessageAddedEvent)=>void>();\n    public ready = this.registerEvent<(ReadyEvent)=>void>();\n    constructor(private sdb:SDB) {\n        super();\n        this.doc = this.sdb.get<ChatDoc>('arboretum', 'chat');\n        this.initialized = this.initializeDoc();\n        this.initialized.catch((err) => {\n            console.error(err);\n        });\n    };\n    private async initializeDoc():Promise<void> {\n        await this.doc.createIfEmpty({\n            users: [],\n            messages: []\n        });\n        this.doc.subscribe((op, source, data) => {\n            if(op) {\n                const opInfo = op[0];\n                const {p, li} = opInfo;\n                if(p[0] === 'users') {\n                    if(p.length === 2 && li) { // user added\n                        this.emit(this.userJoined, {\n                            user:li\n                        });\n                    }\n                } else if(p[0] === 'messages') {\n                    this.emit(this.messageAdded, {\n                        message:li\n                    });\n                }\n            } else {\n                this.emit(this.ready);\n            }\n        });\n    };\n    public getMe():User {\n        return this.meUser;\n    };\n    public async addUser(displayName:string, isMe:boolean=true, present=true):Promise<User> {\n        const id:UserID = ArboretumChat.userCounter++;\n        const user:User = {id, displayName, present, typing:TypingStatus.IDLE};\n        await this.initialized;\n\n        const data:ChatDoc = this.doc.getData();\n        await this.doc.submitOp([{p:['users', data.users.length], li:user}]);\n        if(isMe) { this.meUser = user; }\n        return user;\n    };\n    public async addTextMessage(content:string, sender:User=this.getMe()):Promise<void> {\n        await this.initialized;\n\n        const timestamp:number = (new Date()).getTime()\n        const data:ChatDoc = this.doc.getData();\n        const message:TextMessage = {sender, timestamp, content};\n        await this.doc.submitOp([{p:['messages', data.messages.length], li:message}]);\n    };\n    private async getUserIndex(user:User):Promise<number> {\n        await this.initialized;\n        const data:ChatDoc = this.doc.getData();\n        for(let i = 0; i<data.users.length; i++) {\n            const u = data.users[i];\n            if(user.id === u.id) {\n                return i;\n            }\n        }\n        return -1;\n    };\n    public async markUserNotPresent(user:User):Promise<void> {\n        await this.initialized;\n        const data:ChatDoc = this.doc.getData();\n        const userIndex:number = await this.getUserIndex(user);\n        const oldValue = data.users[userIndex].present;\n        await this.doc.submitOp([{p:['users', userIndex, 'present'], od:oldValue, oi:false}]);\n    };\n    public async setUserTypingStatus(user:User, typingStatus:TypingStatus):Promise<void> {\n        await this.initialized;\n        const data:ChatDoc = this.doc.getData();\n        const userIndex:number = await this.getUserIndex(user);\n        const oldValue = data.users[userIndex].typing;\n        await this.doc.submitOp([{p:['users', userIndex, 'typing'], od:oldValue, oi:typingStatus}]);\n    };\n    public async getMessages():Promise<Array<Message>> {\n        await this.initialized;\n        const data:ChatDoc = this.doc.getData();\n        return data.messages;\n    };\n    public async getUsers(onlyPresent:boolean = true):Promise<Array<User>> {\n        await this.initialized;\n        const data:ChatDoc = this.doc.getData();\n        const {users} = data;\n        if(onlyPresent) {\n            return users.filter((u) => u.present);\n        } else {\n            return users;\n        }\n    };\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils/chat_doc.ts","/******************************************************************************\n * The MIT License (MIT)                                                      *\n *                                                                            *\n * Copyright (c) 2016 Simon \"Tenry\" Burchert                                  *\n *                                                                            *\n * Permission is hereby granted, free of charge, to any person obtaining a    *\n * copy of this software and associated documentation files (the \"Software\"), *\n * to deal in the Software without restriction, including without limitation  *\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,   *\n * and/or sell copies of the Software, and to permit persons to whom the      *\n * Software is furnished to do so, subject to the following conditions:       *\n *                                                                            *\n * The above copyright notice and this permission notice shall be included in *\n * all copies or substantial portions of the Software.                        *\n *                                                                            *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR *\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   *\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    *\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER *\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING    *\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER        *\n * EALINGS IN THE SOFTWARE.                                                   *\n ******************************************************************************/\n\nexport class EventEmitter {\n  private eventListeners: Map<Function, Function[]>;\n\n  constructor() {\n    this.eventListeners = new Map();\n  }\n\n  on(event: Function, listener: Function) {\n    if(!this.eventListeners.has(event)) {\n      this.eventListeners.set(event, [ listener ]);\n    } else {\n      this.eventListeners.get(event).push(listener);\n    }\n\n    return new Listener(this, event, listener);\n  }\n\n  addListener(event: Function, listener: Function) {\n    return this.on(event, listener);\n  }\n\n  removeListener();\n  removeListener(id: Listener);\n  removeListener(event: Function, listener?: Function);\n\n  removeListener() {\n    if(arguments.length == 0) {\n      this.eventListeners.clear();\n    } else if(arguments.length == 1 && typeof arguments[0] == 'object') {\n      let id = arguments[0];\n      this.removeListener(id.event, id.listener);\n    } else if(arguments.length >= 1) {\n      let event = <Function>arguments[0];\n      let listener = <Function>arguments[1];\n\n      if(this.eventListeners.has(event)) {\n        var listeners = this.eventListeners.get(event);\n        var idx;\n        while(!listener || (idx = listeners.indexOf(listener)) != -1) {\n          listeners.splice(idx, 1);\n        }\n      }\n    }\n  }\n\n  /**\n   * Emit event. Calls all bound listeners with args.\n   */\n  protected emit(event: Function, ...args) {\n    if(this.eventListeners.has(event)) {\n      for(var listener of this.eventListeners.get(event)) {\n        listener(...args);\n      }\n    }\n  }\n\n  /**\n   * @typeparam T The event handler signature.\n   */\n  registerEvent<T extends Function>() {\n    let eventBinder = (handler: T) => {\n      return this.addListener(eventBinder, handler);\n    };\n\n    return eventBinder;\n  }\n}\n\nexport class Listener {\n  constructor(public owner: EventEmitter,\n    public event: Function,\n    public listener: Function) {\n\n  }\n\n  unbind() {\n    this.owner.removeListener(this);\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils/typed_event_emitter.ts"],"sourceRoot":""}